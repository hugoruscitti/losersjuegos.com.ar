<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es"
 lang="es" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>referencia:articulos:seno_coseno</title>
<meta name="generator" content="DokuWiki Release 2009-02-14b" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2009-02-15T17:19:19+0300" />
<meta name="keywords" content="referencia,articulos,seno_coseno" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="Losersjuegos" />
<link rel="start" href="../../../../index.html" />
<link rel="contents" href="../../../../referencia/articulos/seno_coseno-do=index.html" title="Indice" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php.rss" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php-mode=list&amp;ns=referencia-articulos.rss" />
<link rel="alternate" type="text/html" title="Plain HTML" href="seno_coseno.html" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../../raw/referencia/articulos/seno_coseno.txt" />
<link rel="stylesheet" media="all" type="text/css" href="../../../../lib/exe/css.php-s=all&amp;t=sidebar.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../../../../lib/exe/css.php-t=sidebar.css" />
<link rel="stylesheet" media="print" type="text/css" href="../../../../lib/exe/css.php-s=print&amp;t=sidebar.css" />
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php-edit=0&amp;write=0.js" ></script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Tabla de Contenidos</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#usando_seno_y_coseno" class="toc">Usando seno y coseno</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#creditos" class="toc">Créditos</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#introduccion" class="toc">Introducción</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#vectores" class="toc">Vectores</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#seno_y_coseno" class="toc">Seno y coseno</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#dibujando_un_circulo" class="toc">dibujando un circulo</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#acerca_de_radianes" class="toc">acerca de radianes</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#usar_numeros_fijos_no_float" class="toc">usar números fijos, no float</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#introduciendo_otra_manera_de_representar_angulos" class="toc">introduciendo otra manera de representar ángulos</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#un_juego_de_autos_de_carrera" class="toc">un juego de autos de carrera</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#otra_cosa_importante_que_puedes_hacer_con_seno_y_coseno" class="toc">otra cosa importante que puedes hacer con seno y coseno</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#dibujando_un_circulo_de_otra_forma" class="toc">dibujando un circulo de otra forma</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#vectores_por_el_otro_lado" class="toc">vectores por el otro lado</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#usando_atan2" class="toc">usando atan2()</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#usando_el_producto_punto" class="toc">usando el producto punto</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#seno_coseno_mapas_de_bit_y_rotacion" class="toc">seno, coseno, mapas de bit y rotación</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#rotacion" class="toc">rotación</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#informacion_adicional_acerca_del_documento" class="toc">Información adicional acerca del documento</a></span></div></li></ul>
</li></ul>
</div>
</div>
<!-- TOC END -->

<p>
<a href="../../../../_media/referencia/articulos/seno_coseno/seno_coseno.pdf" class="media mediafile mf_pdf" title="referencia:articulos:seno_coseno:seno_coseno.pdf">Ver PDF</a>

</p>

<h1><a name="usando_seno_y_coseno" id="usando_seno_y_coseno">Usando seno y coseno</a></h1>
<div class="level1">

</div>
<!-- SECTION "Usando seno y coseno" [63-98] -->
<h2><a name="creditos" id="creditos">Créditos</a></h2>
<div class="level2">
<ul>
<li class="level1"><div class="li"> <strong>Autor:</strong> Amarillion</div>
</li>
<li class="level1"><div class="li"> <strong>Traducido por:</strong> <a href="../../../../comunidad/integrantes/carlos_gabriel_valentin.html" class="wikilink2" title="comunidad:integrantes:carlos_gabriel_valentin" rel="nofollow">Carlos Gabriel Valentin</a></div>
</li>
<li class="level1"><div class="li"> <strong>Fecha:</strong> 15 de Febrero del 2006</div>
</li>
</ul>

</div>
<!-- SECTION "Créditos" [99-260] -->
<h2><a name="introduccion" id="introduccion">Introducción</a></h2>
<div class="level2">

<p>
En este articulo discutiremos algunas técnicas de programación de juegos,
todas en torno a un tema central: las funciones seno y coseno.
</p>

<p>
Se explicará el concepto de seno, coseno, vectores, tangentes y algunos
efectos especiales. Veremos como hacer misiles direccionales y como trabajan
las rotaciones de bitmap.
</p>

<p>
Comenzaré con lo más básico, pero luego cubriré técnicas de programación de
juegos un poco mas avanzadas. Puede descargar todos los códigos de ejempo (12
en total) desde <a href="../../../../_media/referencia/articulos/seno_coseno/codigos_fuentes.tar.gz" class="media mediafile mf_gz" title="referencia:articulos:seno_coseno:codigos_fuentes.tar.gz">aquí</a>. Todos se verificaron con anterioridad utilizando el
compilador DJGPP. Si usted tiene DJGPP, puede descomprimir los fuentes y el
makefile en un directorio y correr “make”. 
</p>

</div>
<!-- SECTION "Introducción" [261-1023] -->
<h2><a name="vectores" id="vectores">Vectores</a></h2>
<div class="level2">

<p>
Empecemos con algo que a veces es difícil de entender para los que recién comienzan, ya que es altamente abstracto, el vector. Este se puede visualizar de diferentes maneras.
</p>

<p>
Primero podemos imaginarnos que es una flecha a un punto en el espacio. En el caso de que sea en 2 dimensiones, necesitamos dos valores para definir el vector. Uno para las coordenada X y otro para la coordenada Y. En el caso de que estemos usando la tercera dimensión, necesitaremos un tercer valor para la coordenada Z. Aunque en este articulo solo trataremos la segunda dimensión. 
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig1.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig1.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig1.png" class="media" alt="" /></a>
</p>

<p>
En la figura de arriba hay un vector dibujado con una coordenada X de valor 3 y una coordenada Y de valor 2. Pero estos dos valores no son el final de la historia. Por ejemplo si dibujamos este vector en papel, podemos medir su largo y obtener el ángulo que define con eje de coordenada X. Su largo será de 3.6 cm de largo y el ángulo será de 34 grados.
</p>

<p>
Si pensamos profundamente, podemos ver que no necesitamos el par (X,Y) del vector si ya conocemos su largo y el ángulo que genera con el X de coordenada. Es perfectamente posible definir un vector por su largo y su ángulo.
</p>

<p>
Con X e Y estamos usando coordenadas cartesianas. Si usamos el largo y el ángulo del vector estamos usando coordenadas polares.
</p>

<p>
Veamos un ejemplo. Supongamos que estamos escribiendo un juego de autos de carrera al estilo Top-down (algo así como Micro Machines). Necesitaremos alguna manera de guardar la velocidad del auto. ¿Como haremos eso? con un vector. Este vector velocidad es en realidad el cambio de posición del auto de un cuadro a otro. La pregunta es ¿deberíamos usar coordenadas cartesianas o coordenadas polares para este vector?.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig2.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig2.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig2.png" class="media" alt="" /></a>
</p>

<p>
Bueno, guardando solo las coordenadas cartesianas tiene la ventaja que es bastante fácil calcular la nueva posición del auto en cada instante. Supongamos que guardamos las coordenadas (X,Y) del vector velocidad en las variables &#039;vel_x&#039; y &#039;vel_y&#039;, y la posición del coche en las variables &#039;pos_x&#039; y &#039;pos_y&#039;. Todo lo que tenemos que hacer en el bucle del juego es: 
</p>
<pre class="code">
pos_x += vel_x;
pos_y += vel_y;
</pre>

<p>
Por otro lado, guardando el ángulo y el largo del vector velocidad tiene la ventaja que hace más fácil el control del auto. Pensemos, si el jugador aprieta LEFT, quieres que el auto doble a la izquierda. Suponiendo que guardamos el ángulo en el entero &#039;car_angle&#039;, podemos hacer uso del siguiente código:
</p>
<pre class="code c"><span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_LEFT<span class="br0">&#93;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
        car_angle <span class="sy0">-=</span> <span class="nu0">1</span>; <span class="co1">// dobla un grado hacia la izquierda</span>
<span class="br0">&#125;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_RIGHT<span class="br0">&#93;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
        car_angle <span class="sy0">+=</span> <span class="nu0">1</span>; <span class="co1">// dobla un grado hacia la derecha</span>
<span class="br0">&#125;</span></pre>
<p>
¿Como haríamos esto guardando el valor X e Y? tendríamos que cambiar las 2 variables y eso sería un poco más difícil que la solución anterior. Además si apretamos UP desearíamos que el auto vaya más rápido, Fácilmente podríamos solucionar esto incrementando el vector del auto.
</p>

</div>
<!-- SECTION "Vectores" [1024-4060] -->
<h2><a name="seno_y_coseno" id="seno_y_coseno">Seno y coseno</a></h2>
<div class="level2">

<p>
Ahora ya sabemos que hay 2 formas de guardar un vector (a travez de coordenadas polares y cartesianas) y que en este caso las 2 tienen sus ventajas. Entonces ¿Cual usamos? Bueno, no tendría que ser un problema si sabemos como calcular el ángulo y la velocidad desde la coordenada X y la coordenada Y o viceversa.
</p>

<p>
Primero hablaré de como convertir desde coordenadas polares a cartesianas. Por supuesto es posible la conversión en el otro sentido, pero hablaré de eso luego. Hay 2 funciones para realizar esto. Estas funciones son el seno y coseno. El seno se puede usar para calcular la coordenada Y del vector, y el coseno se puede usar para calcular la coordenada X. Las funciones seno (sin) y coseno (cos) solo admiten un parámetro: el ángulo. Ellas retornan números entre -1 y 1, si multiplicamos este numero por el largo del vector, obtendremos las coordenadas cartesianas exactas, del vector. Entonces nuestro código se verá así:
</p>
<pre class="code c">speed_x <span class="sy0">=</span> speed_length <span class="sy0">*</span> cos <span class="br0">&#40;</span>speed_angle<span class="br0">&#41;</span>;
speed_y <span class="sy0">=</span> speed_length <span class="sy0">*</span> sin <span class="br0">&#40;</span>speed_angle<span class="br0">&#41;</span>;</pre>
<p>
Eso es todo, para un juego de carrera solo guardamos el ángulo y el largo del vector velocidad. Ajustamos esto en función de la entrada que nos de el jugador y calculemos las coordenadas cuando estemos listos para actualizar la posición del auto.
</p>

</div>
<!-- SECTION "Seno y coseno" [4061-5394] -->
<h2><a name="dibujando_un_circulo" id="dibujando_un_circulo">dibujando un circulo</a></h2>
<div class="level2">

<p>
Daré un ejemplo simple de lo que hace sin y cos. En realidad, este es
probablemente el programa más simple usando sin y cos que veremos.
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> draw_circle <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> x<span class="sy0">,</span> y;
    <span class="kw4">int</span> length <span class="sy0">=</span> <span class="nu0">50</span>;
    <span class="kw4">float</span> angle <span class="sy0">=</span> <span class="nu16">0.0</span>;
    <span class="kw4">float</span> angle_stepsize <span class="sy0">=</span> <span class="nu16">0.1</span>;
&nbsp;
    <span class="co1">// go through all angles from 0 to 2 * PI radians</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span>angle <span class="sy0">&lt;</span> <span class="nu0">2</span> <span class="sy0">*</span> PI<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// calculate x, y from a vector with known length and angle</span>
        x <span class="sy0">=</span> length <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        y <span class="sy0">=</span> length <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
&nbsp;
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
            x <span class="sy0">+</span> SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> y <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        angle <span class="sy0">+=</span> angle_stepsize;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Al ejecutar el programa verá:
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/circ1.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:circ1.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/circ1.png" class="media" alt="" /></a>
</p>

<p>
Lo que hace está función es dibujar 60 puntos distanciados igualmente entre si en la pantalla, que juntos forman un circulo perfecto. Como verá hay una variable llamada &#039;length&#039; y otra llamada &#039;angle&#039;. Estas dos representan el largo y el ángulo de un vector, respectivamente.
</p>

<p>
Primero calculamos la coordenada X y la coordenada Y, usando sin y cos. Después trazamos un pixel en las coordenadas X e Y calculada. Por último incrementamos el ángulo del vector un poco, pero no cambiamos el largo. Lo iteramos varias veces, desplazándonos a través de diferentes ángulos. Si dibujamos un punto a una distancia constante desde un punto fijo en diferentes direcciones, obtendremos un circulo.
</p>

</div>
<!-- SECTION "dibujando un circulo" [5395-6872] -->
<h2><a name="acerca_de_radianes" id="acerca_de_radianes">acerca de radianes</a></h2>
<div class="level2">

<p>
Primero veremos por que la expresión dentro de la ciclo while dice angle ”&lt; 2
* PI”. Y Segundo, por que aunque &#039;angle_increment&#039; es un valor tan bajo los puntos no están cerca unos de otros.
</p>

<p>
La respuesta a lo primero es que sin y cos no toman grados como argumento. Hay 2 * PI radianes en un circulo, PI siendo una constante matemática alrededor de 3,1415927. Entonces hay más o menos 6,282 radianes en un circulo. El siguiente código nos permitirá poder calcular el numero de grados con el número de radianes y viceversa.
</p>
<pre class="code c">degrees <span class="sy0">=</span> radians <span class="sy0">*</span> <span class="nu0">180</span> <span class="sy0">/</span> PI;
radians <span class="sy0">=</span> degrees <span class="sy0">*</span> PI <span class="sy0">/</span> <span class="nu0">180</span>;</pre>
<p>
Consideremos que el incremento del ángulo es de 0,1 radianes. 0,1 radianes = 0,1 * 180 / 3.142 = 5,7 grados. Si vemos la salida, del circulo dibujado anteriormente, notaremos que son los valores más o menos dibujados. Verdaderamente la razón de introducir radianes de esta manera es la siguiente, el largo de la circunferencia es exactamente 2 * PI. Esto significa que el largo de la circunferencia es igual al numero de radianes en un circulo completo.
</p>

</div>
<!-- SECTION "acerca de radianes" [6873-7975] -->
<h2><a name="usar_numeros_fijos_no_float" id="usar_numeros_fijos_no_float">usar números fijos, no float</a></h2>
<div class="level2">

<p>
En computadoras nuevas, no hay mucha diferencia, pero en computadoras viejas la ganancia de velocidad usando números de puntos fijos es significativa frente al uso de floats. Aquí les mostraré la función draw_circle, pero ahora solo usando aritmética de números de puntos fijos.
</p>

<p>
Primero veremos una introducción al tema. Note que si usa C++ puede hacer uso de la clase “fix”, la cual le aliviará un poco el trabajo, aunque no la explicaré aquí. Si programas en C++ y quieres usar la clase “fix”, tendrás que buscarla en la documentación de allegro.
</p>

<p>
Regla #1: Podemos convertir de un float a un número de punto fijo o de int a un número de punto fijo, con las funciones fixtoi, fixtof, itofix y ftofix.
</p>
<pre class="code c">fixed_1 <span class="sy0">=</span> itofix <span class="br0">&#40;</span>int_1<span class="br0">&#41;</span>;
int_1 <span class="sy0">=</span> fixtoi <span class="br0">&#40;</span>fixed_1<span class="br0">&#41;</span>;
float_1 <span class="sy0">=</span> fixtof <span class="br0">&#40;</span>fixed_1<span class="br0">&#41;</span>;</pre>
<p>
Regla #2: podemos sumar y restar 2 números de puntos fijos, pero no un int y un número de punto fijo. Necesitaras convertir el int a un número de punto fijo.
</p>
<pre class="code c">fixed_3 <span class="sy0">=</span> fixed_1 <span class="sy0">+</span> fixed_2;
fixed_3 <span class="sy0">=</span> fixed_1 <span class="sy0">-</span> fixed_2;
fixed_3 <span class="sy0">=</span> fixed_1 <span class="sy0">+</span> itofix <span class="br0">&#40;</span>int_2<span class="br0">&#41;</span>;</pre>
<p>
Regla #3: Podemos dividir y multiplicar por un int, pero no por otro numero de punto fijo. En ese caso necesitaras usar las funciones fmul () y fdiv ().
</p>
<pre class="code c">fixed_3 <span class="sy0">=</span> fixed_1 <span class="sy0">*</span> int_2;
fixed_3 <span class="sy0">=</span> fmul <span class="br0">&#40;</span>fixed_1<span class="sy0">,</span> fixed_2<span class="br0">&#41;</span>;
fixed_3 <span class="sy0">=</span> fdiv <span class="br0">&#40;</span>fixed_1<span class="sy0">,</span> fixed_2<span class="br0">&#41;</span>;</pre>
<p>
Aquí les presento la nueva versión de la función draw_circle:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> draw_circle_fixed <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    fixed x<span class="sy0">,</span> y;
    <span class="kw4">int</span> length <span class="sy0">=</span> <span class="nu0">50</span>;
    fixed angle <span class="sy0">=</span> <span class="nu19">0</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">5</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// go through all angles from 0 to 255</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span>fixtoi <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">256</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// calculate x, y from a vector with known length and angle</span>
        x <span class="sy0">=</span> length <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        y <span class="sy0">=</span> length <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
&nbsp;
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        angle <span class="sy0">+=</span> angle_stepsize;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Note que usamos fsin y fcos cuando usamos números de puntos fijos.
</p>

</div>
<!-- SECTION "usar números fijos, no float" [7976-10061] -->
<h2><a name="introduciendo_otra_manera_de_representar_angulos" id="introduciendo_otra_manera_de_representar_angulos">introduciendo otra manera de representar ángulos</a></h2>
<div class="level2">

<p>
En la nueva versión de la función draw_circle la condición del ciclo while ha cambiado por (fixtoi (angle) &lt; 256 ). Veremos la manera en que los programadores prefieren usar ángulos: Ellos hacen uso de un circulo que esta dividido en 256 partes, con un rango de 0 a 255. Digamos que es parte de cómo maneja ángulos allegro. ¿Por que 256 en lugar de 360? ¿que pasará cuando tenga un ángulo de 361 grados?. Por definición un circulo es redondo, 361 grados representa el mismo punto como 1 grado. De la misma manera que 3 * PI es lo mismo que 1 * PI radianes, y 257 grados de allegro es lo mismo que 1 grado de allegro.
</p>

<p>
Para mantender el rango de valores de un ángulo dentro de los 0 y 360 grados deberemos hacerlo de la siguiente manera:
</p>
<pre class="code c"><span class="kw4">int</span> angle_in_degrees;
<span class="kw1">while</span> <span class="br0">&#40;</span>angle_in_degrees <span class="sy0">&gt;</span> <span class="nu0">360</span><span class="br0">&#41;</span> angle_in_degrees <span class="sy0">-=</span> <span class="nu0">360</span>;
<span class="kw1">while</span> <span class="br0">&#40;</span>angle_in_degrees <span class="sy0">&lt;</span> <span class="nu19">0</span><span class="br0">&#41;</span> angle_in_degrees <span class="sy0">+=</span> <span class="nu0">360</span>;</pre>
<p>
Pero como los grados de allegro tienen un rango de 0 a 255, y este rango puede guardarse en exactamente 8 bits, solo necesitamos reiniciar todos los otros bits y podemos estar seguro de tener un ángulo dentro del rango. Tenemos que desenmascarar todos los otros bits excepto los 8 bits menos significativos. Podemos hacer esto con el operador AND(&amp;)
</p>
<pre class="code c"><span class="kw4">int</span> allegro_degrees;
<span class="co1">// guardar los 8 bits menos significativos</span>
allegro_degrees <span class="sy0">&amp;=</span> <span class="nu12">0xFF</span>;</pre>
<p>
Para los que no entienden el operador AND: creanme, que es un modo bastante seguro de saber que el ángulo esta en el rango. Si usamos números de puntos fijos para representar grados debemos modificar un poco las cosas, ya que también tenemos 16 bits representando la parte derecha del punto. Entonces lo que tenemos que conservar es 16 + 8 = 24 bits. Esto es lo que hacemos:
</p>
<pre class="code c">fixed allegro_degrees;
<span class="co1">// guardar los 24 bits menos significativos</span>
allegro_degrees <span class="sy0">&amp;=</span> <span class="nu12">0xFFFFFF</span>;</pre>
<p>
 Si entiendes esto, entonces entenderás porque la escala de 256 grados es usualmente mejor para programadores de juegos. Si usamos floats lo mejor es usar radianes, porque las funciones sin y cos tienen como parámetros radianes. Si usas números de puntos fijos, como usamos en este ejemplo, es mejor usar los grados de allegro, porque las funciones fsin() y fcos() los usan y es fácil mantener el ángulo dentro del rango con el operador AND.
</p>

<p>
Como hicimos con radianes y grados, podemos calcular grados-allegro teniendo radianes o grados regulares. Aquí tienen el código para poder realizar ello:
</p>
<pre class="code c">allegro_degrees <span class="sy0">=</span> regular_degrees <span class="sy0">*</span> <span class="nu0">256</span> <span class="sy0">/</span> <span class="nu0">360</span>;
allegro_degrees <span class="sy0">=</span> radians <span class="sy0">*</span> <span class="nu0">128</span> <span class="sy0">/</span> PI;</pre>
<p>
Para tener una idea de que hacen seno y coseno escribí la siguiente función.
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> draw_sine <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> length <span class="sy0">=</span> <span class="nu0">50</span>;
    fixed x<span class="sy0">,</span> y;
    fixed angle <span class="sy0">=</span> <span class="nu19">0</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">5</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span>fixtoi<span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">&lt;</span> <span class="nu0">256</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// the angle is plotted along the x-axis</span>
        x <span class="sy0">=</span> angle;
        <span class="co1">// the sine function is plotted along the y-axis</span>
        y <span class="sy0">=</span> length <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
&nbsp;
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
            fixtoi <span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi <span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        angle <span class="sy0">+=</span> angle_stepsize;
    <span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Y verá en pantalla:
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/circ3.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:circ3.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/circ3.png" class="media" alt="" /></a>
</p>

<p>
 La función se ve más o menos parecida a la función draw_circle, pero hace algo diferente. Solo traza la función seno en la pantalla. Como podemos ver la función seno parece una ola. La función seno podría ser usada en nuestro juego para todos los movimientos con una forma oleada.
</p>

<p>
La imagen de abajo fue creada con una modificación en la versión circle3.c. Podemos ver que la función seno está trazada en blanco y la función coseno en rojo. Las funciones son continuas y repetitivas, no paran al llegar a los 256 grados-allegro. Si miramos atentamente veremos que las 2 funciones tiene la misma forma, la única diferencia es que la función coseno esta desplazada un poco. El desplazamiento es exactamente 64 grados-allegro o 90 grados regulares.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig8.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig8.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig8.png" class="media" alt="" /></a>
</p>

<p>
En la tabla de abajo hay algunos valores claves de las funciones seno y coseno. Observemos que las dos funciones llegan a su máximo o su mínimo en los múltiplos de 90 grados regulares.
</p>
<table class="inline">
	<tr class="row0">
		<th class="col0"> normal degrees </th><th class="col1"> radians </th><th class="col2"> allegro degrees </th><th class="col3"> sine </th><th class="col4"> cosine </th>
	</tr>
	<tr class="row1">
		<td class="col0 leftalign">0 	</td><td class="col1 leftalign">0 	</td><td class="col2 leftalign">0 	</td><td class="col3 leftalign">0 	</td><td class="col4">1 </td>
	</tr>
	<tr class="row2">
		<td class="col0 leftalign">90 	</td><td class="col1 leftalign">1/2 pi	</td><td class="col2 leftalign">64 	</td><td class="col3 leftalign">1 	</td><td class="col4">0 </td>
	</tr>
	<tr class="row3">
		<td class="col0 leftalign">180 	</td><td class="col1 leftalign">pi 	</td><td class="col2 leftalign">128 	</td><td class="col3 leftalign">0 	</td><td class="col4">-1 </td>
	</tr>
	<tr class="row4">
		<td class="col0 leftalign">270 	</td><td class="col1 leftalign">3/2 pi	</td><td class="col2 leftalign">192 	</td><td class="col3 leftalign">-1 	</td><td class="col4">0 </td>
	</tr>
	<tr class="row5">
		<td class="col0 leftalign">360 	</td><td class="col1 leftalign">2 pi 	</td><td class="col2 leftalign">256 	</td><td class="col3 leftalign">0 	</td><td class="col4">1 </td>
	</tr>
</table>

</div>
<!-- SECTION "introduciendo otra manera de representar ángulos" [10062-14548] -->
<h2><a name="un_juego_de_autos_de_carrera" id="un_juego_de_autos_de_carrera">un juego de autos de carrera</a></h2>
<div class="level2">

<p>
Hasta ahora conocemos 2 maneras de guardar un vector, ellas son mediante coordenadas cartesianas y polares. También aprendimos a calcular coordenadas cartesianas de un vector si sabemos sus coordenadas polares. Finalmente, vimos 3 modos diferentes de guardar ángulos: grados, radianes y grados-allegro. Pero ahora, vamos al ejemplo con el que empezamos este articulo, el auto de carrera. En realidad el auto es un circulo con una linea representando la dirección de el auto, pero con un poco de imaginación puede ser un auto de carrera:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> racing_car <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// length and angle of the racing car´s velocity vector</span>
    fixed angle <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span>;
    fixed length <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span>;
    <span class="co1">// x- and y-coordinates of the velocity vector</span>
    fixed vel_x<span class="sy0">,</span> vel_y;
&nbsp;
    <span class="co1">// x- and y-position of the racing car</span>
    fixed x <span class="sy0">=</span> itofix <span class="br0">&#40;</span>SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
    fixed y <span class="sy0">=</span> itofix <span class="br0">&#40;</span>SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>key<span class="br0">&#91;</span>KEY_ESC<span class="br0">&#93;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// erase the old image</span>
        circlefill <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> makecol <span class="br0">&#40;</span><span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// check the keys and move the car</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_UP<span class="br0">&#93;</span> <span class="sy0">&amp;&amp;</span> length <span class="sy0">&lt;</span> itofix <span class="br0">&#40;</span><span class="nu0">2</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            length <span class="sy0">+=</span> ftofix <span class="br0">&#40;</span><span class="nu16">0.005</span><span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_DOWN<span class="br0">&#93;</span> <span class="sy0">&amp;&amp;</span> length <span class="sy0">&gt;</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            length <span class="sy0">-=</span> ftofix <span class="br0">&#40;</span><span class="nu16">0.005</span><span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_LEFT<span class="br0">&#93;</span><span class="br0">&#41;</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">-</span> itofix <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>key<span class="br0">&#91;</span>KEY_RIGHT<span class="br0">&#93;</span><span class="br0">&#41;</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">+</span> itofix <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
&nbsp;
        <span class="co1">// calculate the x- and y-coordinates of the velocity vector</span>
        vel_x <span class="sy0">=</span> fmul <span class="br0">&#40;</span>length<span class="sy0">,</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span>;
        vel_y <span class="sy0">=</span> fmul <span class="br0">&#40;</span>length<span class="sy0">,</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// move the car, and make sure it stays within the screen</span>
        x <span class="sy0">+=</span> vel_x;
        <span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy0">&gt;=</span> itofix <span class="br0">&#40;</span>SCREEN_W<span class="br0">&#41;</span><span class="br0">&#41;</span> x <span class="sy0">-=</span> itofix<span class="br0">&#40;</span>SCREEN_W<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy0">&lt;</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span> x <span class="sy0">+=</span> itofix<span class="br0">&#40;</span>SCREEN_W<span class="br0">&#41;</span>;
        y <span class="sy0">+=</span> vel_y;
        <span class="kw1">if</span> <span class="br0">&#40;</span>y <span class="sy0">&gt;=</span> itofix <span class="br0">&#40;</span>SCREEN_H<span class="br0">&#41;</span><span class="br0">&#41;</span> y <span class="sy0">-=</span> itofix<span class="br0">&#40;</span>SCREEN_H<span class="br0">&#41;</span>;
        <span class="kw1">if</span> <span class="br0">&#40;</span>y <span class="sy0">&lt;</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span> y <span class="sy0">+=</span> itofix<span class="br0">&#40;</span>SCREEN_H<span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// draw the racing car</span>
        circle <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> makecol <span class="br0">&#40;</span><span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        line <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi <span class="br0">&#40;</span>x <span class="sy0">+</span> <span class="nu0">9</span> <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi <span class="br0">&#40;</span>y <span class="sy0">+</span> <span class="nu0">9</span> <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// wait for 10 milliseconds, or else we´d go too fast</span>
&nbsp;
        rest <span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
La velocidad del auto de carrera está representada por el ángulo y el largo. Si el jugador aprieta UP, el largo del vector velocidad se incrementa; si aprieta DOWN, el largo del vector velocidad se decrementa, el ángulo cambia si el jugador aprieta LEFT o RIGHT. Con el enmascaramiento de los 24-bits nos aseguramos que el ángulo se mantenga en el rango. Después de que la dirección y la velocidad han sido ajustado, las coordenadas cartesianas &#039;vel_x&#039; y &#039;vel_y&#039; son calculadas con sin() y cos(). En cada iteración del bucle, estas coordenadas son sumadas a las coordenadas del auto.
</p>

</div>
<!-- SECTION "un juego de autos de carrera" [14549-17456] -->
<h2><a name="otra_cosa_importante_que_puedes_hacer_con_seno_y_coseno" id="otra_cosa_importante_que_puedes_hacer_con_seno_y_coseno">otra cosa importante que puedes hacer con seno y coseno</a></h2>
<div class="level2">

<p>
Si entiendes todo esto, no tendremos problema con el siguiente programa. Es otro pequeño ejemplo de lo que podemos hacer con seno y coseno. Esta vez usaremos seno y coseno para animar la orbita de un planeta. El planeta va a ser representado por un pequeño punto, que se moverá alrededor de un circulo. Aquí tenemos el código:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> orbit <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu19">0</span><span class="sy0">,</span> y <span class="sy0">=</span> <span class="nu19">0</span>;
&nbsp;
    fixed angle <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu19">0</span><span class="br0">&#41;</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// These determine the radius of the orbit.</span>
    <span class="co1">// See what happens if you change length_x to 100 :)</span>
    <span class="kw4">int</span> length_x <span class="sy0">=</span> <span class="nu0">50</span>;
    <span class="kw4">int</span> length_y <span class="sy0">=</span> <span class="nu0">50</span>;
&nbsp;
    <span class="co1">// repeat this until a key is pressed</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>keypressed<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// erase the point from the old position</span>
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// calculate the new position</span>
        x <span class="sy0">=</span> length_x <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        y <span class="sy0">=</span> length_y <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// draw the point in the new position</span>
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// increment the angle so that the point moves around in circles</span>
        angle <span class="sy0">+=</span> angle_stepsize;
&nbsp;
        <span class="co1">// make sure angle is in range</span>
        angle <span class="sy0">&amp;=</span> <span class="nu12">0xFFFFFF</span>;
&nbsp;
        <span class="co1">// wait 10 milliseconds, or else it´d go too fast</span>
        rest <span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>

Trata experimentando con diferentes valores de &#039;length_x&#039; y &#039;length_y&#039;. Si estos 2 son diferentes, el resultado sera que el planeta no se moverá formando un circulo, sino que se moverá trazando una elipse.
</p>

</div>
<!-- SECTION "otra cosa importante que puedes hacer con seno y coseno" [17457-19155] -->
<h2><a name="dibujando_un_circulo_de_otra_forma" id="dibujando_un_circulo_de_otra_forma">dibujando un circulo de otra forma</a></h2>
<div class="level2">

<p>
En el primer capitulo expliqué que hay 2 maneras de dibujar un circulo, una usando floats y otra usando números de puntos fijos. Pero si miramos el archivo gfx.c en el directorio allegro/src/ veremos que el código fuente de la función circle() no es como el código fuente de la función draw_circle que está aquí.
</p>

<p>
En realidad no encontraremos una sola función seno y coseno. El código hace uso de que todos los puntos están a la misma distancia del centro.
</p>

<p>
Digamos que empezamos en la parte superior del circulo. Las coordenadas en la parte superior son fácil de calcular: la coordenada X es 0 y la coordenada Y es igual que al radio del circulo (pero negativo en función de las coordenada de la pantalla). Entonces dibujamos un pixel en esa coordenada. Para el próximo pixel o podemos ir un pixel a la derecha, o un pixel abajo y luego un pixel a la derecha.
</p>

<p>
La solución es calcular para las 2 posibilidades la distancia al centro con el teorema de Pitagoras. Dibujamos el pixel cuya distancia desde el centro se aproxima más al radio del circulo.
</p>

<p>

<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig3.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig3.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig3.png" class="media" alt="" /></a>
</p>

<p>

Solo tenemos que hacer esto para la octava parte del circulo. El resto del circulo se puede dibujar haciendo uso de las lineas horizontales, verticales y diagonales de la simetría del circulo, como puedes ver en la figura de abajo. Observemos que podemos dibujar todas las secciones rojas y amarillas por el precio de una, simplemente reflejándolo a través de las lineas verdes.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig4.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig4.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig4.png" class="media" alt="" /></a>
</p>

<p>
Aquí está el código:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> my_draw_circle <span class="br0">&#40;</span>BITMAP <span class="sy0">*</span>bmp<span class="sy0">,</span> <span class="kw4">int</span> center_x<span class="sy0">,</span> <span class="kw4">int</span> center_y<span class="sy0">,</span> <span class="kw4">int</span> r<span class="sy0">,</span> <span class="kw4">int</span> color<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// x and y are the current position in the circle.</span>
    <span class="kw4">int</span> x <span class="sy0">=</span> <span class="nu19">0</span><span class="sy0">,</span> y <span class="sy0">=</span> r;
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span>x <span class="sy0">&lt;=</span> y<span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// We make use of 8 axes of symmetry in a circle.</span>
        <span class="co1">// This way we have fewer points to calculate on its circumference.</span>
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">+</span> x<span class="sy0">,</span> center_y <span class="sy0">+</span> y<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">-</span> x<span class="sy0">,</span> center_y <span class="sy0">+</span> y<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">+</span> x<span class="sy0">,</span> center_y <span class="sy0">-</span> y<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">-</span> x<span class="sy0">,</span> center_y <span class="sy0">-</span> y<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">+</span> y<span class="sy0">,</span> center_y <span class="sy0">+</span> x<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">-</span> y<span class="sy0">,</span> center_y <span class="sy0">+</span> x<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">+</span> y<span class="sy0">,</span> center_y <span class="sy0">-</span> x<span class="sy0">,</span> color<span class="br0">&#41;</span>;
        putpixel <span class="br0">&#40;</span>bmp<span class="sy0">,</span> center_x <span class="sy0">-</span> y<span class="sy0">,</span> center_y <span class="sy0">-</span> x<span class="sy0">,</span> color<span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// This is the most important part of the function.</span>
        <span class="co1">// We go to the right in all cases (x++).</span>
        <span class="co1">// We need to decide whether to go down (y--).</span>
        <span class="co1">// This depends on which point is</span>
        <span class="co1">// closest to the path of the circle.</span>
        <span class="co1">// Good old Pythagoras will tell us what to do.</span>
        x++;
        <span class="kw1">if</span> <span class="br0">&#40;</span>abs <span class="br0">&#40;</span>x<span class="sy0">*</span>x <span class="sy0">+</span> y<span class="sy0">*</span>y <span class="sy0">-</span> r<span class="sy0">*</span>r<span class="br0">&#41;</span> <span class="sy0">&gt;</span>
            abs <span class="br0">&#40;</span>x<span class="sy0">*</span>x <span class="sy0">+</span> <span class="br0">&#40;</span>y<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">*</span><span class="br0">&#40;</span>y<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">-</span> r<span class="sy0">*</span>r<span class="br0">&#41;</span><span class="br0">&#41;</span>
            y--;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Igual este código no se ve como el archivo gfx.c de allegro, pero esto es principalmente por lo siguiente:
</p>
<pre class="code c"><span class="kw1">if</span> <span class="br0">&#40;</span>abs <span class="br0">&#40;</span>x<span class="sy0">*</span>x <span class="sy0">+</span> y<span class="sy0">*</span>y <span class="sy0">-</span> r<span class="sy0">*</span>r<span class="br0">&#41;</span> <span class="sy0">&gt;</span> abs <span class="br0">&#40;</span>x<span class="sy0">*</span>x <span class="sy0">+</span> <span class="br0">&#40;</span>y<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">*</span><span class="br0">&#40;</span>y<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="sy0">-</span> r<span class="sy0">*</span>r<span class="br0">&#41;</span><span class="br0">&#41;</span></pre>
<p>
Puede optimizarse mucho mas, de hecho si le hacemos todas las optimizaciones arribaremos a la función actual circle() de allegro.
</p>

</div>
<!-- SECTION "dibujando un circulo de otra forma" [19156-22354] -->
<h2><a name="vectores_por_el_otro_lado" id="vectores_por_el_otro_lado">vectores por el otro lado</a></h2>
<div class="level2">

<p>
Hemos visto como ir desde coordenadas polares a cartesianas con sin y cos:
</p>
<pre class="code c">x <span class="sy0">=</span> length <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>
y <span class="sy0">=</span> length <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span></pre>
<p>
Ahora explicaré como ir en sentido contrario. Calcular el largo es la parte fácil, porque solo necesitamos el teorema de Pitagoras: a^2 + b^2 = c^2 o más práctico:
</p>
<pre class="code c">length <span class="sy0">=</span> sqrt <span class="br0">&#40;</span>x <span class="sy0">*</span> x <span class="sy0">+</span> y <span class="sy0">*</span> y<span class="br0">&#41;</span></pre>
<p>
Calcular el ángulo es un poco mas difícil. Hay una función matemática llamada tangente, cuya implementación en C es la función tan(), que puede ser usada para calcular la proporción entre Y y X como se muestra a continuación:
</p>
<pre class="code c">tan <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">=</span> y <span class="sy0">/</span> x</pre>
<p>

<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig5.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig5.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig5.png" class="media" alt="" /></a>
</p>

<p>
Esto puede ser escrito como:
</p>
<pre class="code c">tan <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">=</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">/</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span></pre>
<p>

Esto significa que la función “tan” es combinación de las funciones sin y cos. La función inversa de la tangente es llamada arcotangente; en C es atan(). Esta función puede ser usada para calcular el ángulo si conoces la proporción entre Y y X:
</p>
<pre class="code c">angle <span class="sy0">=</span> atan <span class="br0">&#40;</span>y <span class="sy0">/</span> x<span class="br0">&#41;</span></pre>
<p>

Pero existe un problema menor: a veces este cálculo te dará un resultado incorrecto. En la figura de abajo se ven 2 vectores uno rojo y otro amarillo. Los dos tienen la misma proporción entre Y y X. Eso significa que si calculas el arcotangente de los 2 obtendrás el mismo resultado, el cual es 45 grados. Esto es correcto solo para el vector amarillo.
</p>

<p>
Además, tendrás que verificar los casos en donde X es 0, para evitar la división por 0.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig6.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig6.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig6.png" class="media" alt="" /></a>
</p>

<p>

Una solución parcial es la siguiente (parcial porque no comprobamos cuando X es 0).
</p>
<pre class="code c"><span class="kw1">if</span> <span class="br0">&#40;</span>x <span class="sy0">&gt;</span> <span class="nu19">0</span><span class="br0">&#41;</span>
        angle <span class="sy0">=</span> atan <span class="br0">&#40;</span>y <span class="sy0">/</span> x<span class="br0">&#41;</span>;
<span class="kw1">else</span>
        angle <span class="sy0">=</span> PI <span class="sy0">+</span> atan <span class="br0">&#40;</span>y <span class="sy0">/</span> x<span class="br0">&#41;</span></pre>
<p>
Pero para los programadores está la función atan2():
</p>
<pre class="code c">angle <span class="sy0">=</span> atan2 <span class="br0">&#40;</span>y<span class="sy0">,</span> x<span class="br0">&#41;</span></pre>
<p>

Esta función siempre producirá el ángulo correcto para cualquier par (x,y). Por supuesto que para números de puntos fijos, allegro provee la homologa fatan2().
</p>

</div>
<!-- SECTION "vectores por el otro lado" [22355-24413] -->
<h2><a name="usando_atan2" id="usando_atan2">usando atan2()</a></h2>
<div class="level2">

<p>
Supongamos que estamos escribiendo un juego en el que el jugador puede disparar misiles direccionales. Entonces decidimos hacerlo como dijimos.
</p>

<p>
Primero calculamos la dirección del objetivo como mirando desde el misil. Luego comparamos este ángulo con el ángulo actual del misil. Si el ángulo del objetivo es mayor que el ángulo actual, el ángulo tendría que incrementarse y viceversa.
</p>

<p>
Esto es una buena idea, pero ¿como calculamos la dirección del objetivo visto desde el misil? Podemos visualizar esto como un vector desde el misil hasta el objetivo. La coordenada X e Y del vector se pueden calcular muy fácil - solo restamos las coordenadas del vector del misil con las coordenadas del objetivo. Dadas las coordenadas X e Y del vector, podemos calcular el ángulo y el largo, usando la función atan2() como describimos antes. El largo no es importante pero el ángulo sí lo necesitaremos.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/fig7.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:fig7.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/fig7.png" class="media" alt="" /></a>
</p>

<p>
En el siguiente código, la posición del misil es representada por las variables &#039;x&#039; e &#039;y&#039;. La velocidad del misíl está representada por las variables &#039;length&#039; y &#039;angle&#039;. Primero el programa determina si el objetivo ha sido fijado, en caso contrario, el programa elegirá uno al azar.
</p>

<p>
Finalmente el programa determina como debería cambiar el ángulo del misil. El ángulo hacia el objetivo se calcula en esta linea:
</p>
<pre class="code c">target_angle <span class="sy0">=</span> fatan2 <span class="br0">&#40;</span>target_y <span class="sy0">-</span> y<span class="sy0">,</span> target_x <span class="sy0">-</span> x<span class="br0">&#41;</span>;</pre>
<p>
El programa usa este ángulo calculado para determinar si el ángulo dirección del misil debería incrementarse o decrementarse. Calcula la diferencia entre el ángulo del objetivo y el ángulo actual. Después se asegura de que esta diferencia este dentro del rango: &amp;0XFFFFFF. Si el ángulo es menor que 128 grados-allegros (180 grados-normal), el ángulo dirección se decrementa. De otra manera se incrementa.
</p>
<pre class="code c"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>angle<span class="sy0">-</span>target_angle<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> itofix<span class="br0">&#40;</span><span class="nu0">128</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">-</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
        <span class="kw1">else</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">+</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;</pre>
<p>
Aquí tenemos todo el código:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> home_in <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// the x, y position of the homing missile</span>
    fixed x <span class="sy0">=</span> itofix<span class="br0">&#40;</span>SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
    fixed y <span class="sy0">=</span> itofix<span class="br0">&#40;</span>SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
    <span class="co1">// the angle and length of the missile´s velocity vector</span>
    fixed angle <span class="sy0">=</span> <span class="nu19">0</span>;
    <span class="kw4">int</span> length <span class="sy0">=</span> <span class="nu0">1</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">3</span><span class="br0">&#41;</span>;
    <span class="co1">// determines whether the missile has reached</span>
    <span class="co1">// the target and a new one should be chosen</span>
    <span class="kw4">int</span> new_target <span class="sy0">=</span> <span class="kw2">TRUE</span>;
    <span class="co1">// angle to the target</span>
    fixed target_angle;
    <span class="co1">// position of the target</span>
    fixed target_x<span class="sy0">,</span> target_y;
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>keypressed<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        clear <span class="br0">&#40;</span>screen<span class="br0">&#41;</span>;
        <span class="co1">// choose new target randomly when needed</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>new_target<span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
            target_x <span class="sy0">=</span> itofix<span class="br0">&#40;</span><span class="br0">&#40;</span>SCREEN_W <span class="sy0">+</span> rand<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> <span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> SCREEN_W<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">/</span> <span class="nu0">4</span><span class="br0">&#41;</span>;
            target_y <span class="sy0">=</span> itofix<span class="br0">&#40;</span><span class="br0">&#40;</span>SCREEN_H <span class="sy0">+</span> rand<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> <span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> SCREEN_H<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">/</span> <span class="nu0">4</span><span class="br0">&#41;</span>;
            new_target <span class="sy0">=</span> <span class="kw2">FALSE</span>;
        <span class="br0">&#125;</span>
&nbsp;
        <span class="co1">// move the missile</span>
        x <span class="sy0">+=</span> length <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        y <span class="sy0">+=</span> length <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// if we are very close to the target, set a new target</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>abs <span class="br0">&#40;</span>x <span class="sy0">-</span> target_x<span class="br0">&#41;</span> <span class="sy0">+</span> abs <span class="br0">&#40;</span>y <span class="sy0">-</span> target_y<span class="br0">&#41;</span> <span class="sy0">&lt;</span> itofix<span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            new_target <span class="sy0">=</span> <span class="kw2">TRUE</span>;
&nbsp;
        <span class="co1">// draw a pixel where the target is</span>
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>target_x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>target_y<span class="br0">&#41;</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// draw the missile</span>
        <span class="co1">// (actually a circle with a line representing the angle)</span>
        circle <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> makecol <span class="br0">&#40;</span><span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        line <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="sy0">+</span> fixtoi <span class="br0">&#40;</span><span class="nu0">9</span> <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> fixtoi <span class="br0">&#40;</span><span class="nu0">9</span> <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// calculate the angle from the missile to the target</span>
        target_angle <span class="sy0">=</span> fatan2 <span class="br0">&#40;</span>target_y <span class="sy0">-</span> y<span class="sy0">,</span> target_x <span class="sy0">-</span> x<span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// Determine whether we should turn left or right.</span>
        <span class="co1">// Note that itofix (128) represents half a circle.</span>
        <span class="co1">// We use &amp; 0xFFFFFF as a trick to get an angle</span>
        <span class="co1">// between 0 and 256.</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="br0">&#40;</span>angle<span class="sy0">-</span>target_angle<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span><span class="br0">&#41;</span> <span class="sy0">&lt;</span> itofix<span class="br0">&#40;</span><span class="nu0">128</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">-</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
        <span class="kw1">else</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">+</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
&nbsp;
        rest <span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Aquí mostramos la salida. Como podemos ver, el misil es representado por un circulo azul con una linea roja dentro. El objetivo esta representado por un punto blanco.
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/circ6.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:circ6.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/circ6.png" class="media" alt="" /></a>
</p>

</div>
<!-- SECTION "usando atan2()" [24414-28942] -->
<h2><a name="usando_el_producto_punto" id="usando_el_producto_punto">usando el producto punto</a></h2>
<div class="level2">

<p>
La solución anterior enfrenta el problema bastante bien pero no quiere decir que no haya otra solución. En los libros de matemáticas puedes encontrar la siguiente formula para calcular el ángulo entre el vector a y b.
</p>
<pre class="code c">cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span>xa <span class="sy0">*</span> xb <span class="sy0">+</span> ya <span class="sy0">*</span> yb<span class="br0">&#41;</span> <span class="sy0">/</span> <span class="br0">&#40;</span>length <span class="br0">&#40;</span>a<span class="br0">&#41;</span> <span class="sy0">*</span> length <span class="br0">&#40;</span>b<span class="br0">&#41;</span><span class="br0">&#41;</span></pre>
<p>

La expresión (xa * xb + ya * yb) se llama producto punto y es igual al producto de los largos de los vectores multiplicado por el coseno del ángulo entre ellos. Queremos que nuestro misil vaya por un camino si el ángulo entre la dirección actual y el del objetivo esta entre 0 y 180 grados, y que vaya para otro lado si el ángulo entre esta entre 180 y 360 grados.
</p>

<p>
Dada su naturaleza el arcoseno no puede ser usado para determinar la diferencia entre el rango debajo de los 180 grados y por arriba de los 180 grados. Podemos determinar la diferencia entre el rango debajo de los 90 y por arriba de los 270, y el rango entre 90 y 270, porque el coseno es positivo en el primer caso y negativo en el segundo. Si no puedes ver esto, mira la imagen de la ola del coseno de nuevo.
</p>

<p>
Si rotamos un vector por 90 grados, podemos simplemente verificar si el resultado del producto punto es por debajo o por arriba del 0, para ver si tendríamos que doblar a la izquierda o a la derecha. Para hacer esto, hacemos uso de un pequeño truco: cambiamos las coordenadas y le cambiamos el signo de una de ellas. Dicho de otra manera, cambiamos &#039;xa&#039; por &#039;ya&#039; y &#039;ya&#039; por &#039;-xa&#039;.
</p>
<pre class="code">
cos (angle) = (ya * xb - xa * yb) / (length (a) * length (b))
</pre>

<p>

Ya que necesitamos saber si el resultado es positivo o negativo, y no necesitamos el valor actual del resultado, podemos dejar afuera el calculo del largo de los vectores.
</p>
<pre class="code">
result = ya * xb - xa * yb
</pre>

<p>
Si el resultado es positivo doblamos hacia un lugar y si el resultado es negativo, doblamos hacia el otro. Aquí está el código:
</p>
<pre class="code c"><span class="kw1">if</span> <span class="br0">&#40;</span>fmul<span class="br0">&#40;</span>dy<span class="sy0">,</span><span class="br0">&#40;</span>target_x <span class="sy0">-</span> x<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">+</span> fmul<span class="br0">&#40;</span><span class="sy0">-</span>dx<span class="sy0">,</span><span class="br0">&#40;</span>target_y <span class="sy0">-</span> y<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu19">0</span><span class="br0">&#41;</span>
        angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">-</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
<span class="kw1">else</span>
        angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">+</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;</pre>
<p>
En este código, &#039;dx&#039; y &#039;dy&#039; representan el vector velocidad del misil y “target_x - x” e “target_y - y” representan el vector hacia el objetivo. Aquí tenemos el ejemplo completo:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> dot_product_home_in <span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// the position of the homing missile</span>
    fixed x <span class="sy0">=</span> itofix<span class="br0">&#40;</span>SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
    fixed y <span class="sy0">=</span> itofix<span class="br0">&#40;</span>SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="br0">&#41;</span>;
    <span class="co1">// the angle and length of the missile´s velocity vector</span>
    fixed angle <span class="sy0">=</span> <span class="nu19">0</span>;
    <span class="kw4">int</span> length <span class="sy0">=</span> <span class="nu0">1</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">3</span><span class="br0">&#41;</span>;
    <span class="co1">// determines whether the missile has reached</span>
    <span class="co1">// the target and a new one should be chosen</span>
    <span class="kw4">int</span> new_target <span class="sy0">=</span> <span class="kw2">TRUE</span>;
    <span class="co1">// position of the target</span>
    fixed target_x<span class="sy0">,</span> target_y;
    <span class="co1">// vector of missile movement</span>
    fixed dx<span class="sy0">,</span> dy;
&nbsp;
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>keypressed<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        clear <span class="br0">&#40;</span>screen<span class="br0">&#41;</span>;
        <span class="co1">// choose new target randomly when needed</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>new_target<span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
            target_x <span class="sy0">=</span> itofix<span class="br0">&#40;</span><span class="br0">&#40;</span>SCREEN_W <span class="sy0">+</span> rand<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> <span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> SCREEN_W<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">/</span> <span class="nu0">4</span><span class="br0">&#41;</span>;
            target_y <span class="sy0">=</span> itofix<span class="br0">&#40;</span><span class="br0">&#40;</span>SCREEN_H <span class="sy0">+</span> rand<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="sy0">%</span> <span class="br0">&#40;</span><span class="nu0">2</span> <span class="sy0">*</span> SCREEN_H<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">/</span> <span class="nu0">4</span><span class="br0">&#41;</span>;
            new_target <span class="sy0">=</span> <span class="kw2">FALSE</span>;
        <span class="br0">&#125;</span>
&nbsp;
        <span class="co1">// Move the missile</span>
        <span class="co1">// We store dx and dy in variables so that</span>
        <span class="co1">// we can use them later on in the dot product.</span>
        dx <span class="sy0">=</span> length <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        dy <span class="sy0">=</span> length <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
        x <span class="sy0">+=</span> dx;
        y <span class="sy0">+=</span> dy;
&nbsp;
        <span class="co1">// if we are very close to the target, set a new target</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>abs <span class="br0">&#40;</span>x <span class="sy0">-</span> target_x<span class="br0">&#41;</span> <span class="sy0">+</span> abs <span class="br0">&#40;</span>y <span class="sy0">-</span> target_y<span class="br0">&#41;</span> <span class="sy0">&lt;</span> itofix<span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span><span class="br0">&#41;</span>
            new_target <span class="sy0">=</span> <span class="kw2">TRUE</span>;
&nbsp;
        <span class="co1">// draw a pixel where the target is</span>
        putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>target_x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>target_y<span class="br0">&#41;</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// draw the missile</span>
        <span class="co1">// (actually a circle with a line representing the angle)</span>
        circle <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span> <span class="nu0">10</span><span class="sy0">,</span> makecol <span class="br0">&#40;</span><span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        line <span class="br0">&#40;</span>screen<span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span><span class="sy0">,</span> fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>x<span class="br0">&#41;</span> <span class="sy0">+</span> fixtoi <span class="br0">&#40;</span><span class="nu0">9</span> <span class="sy0">*</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            fixtoi<span class="br0">&#40;</span>y<span class="br0">&#41;</span> <span class="sy0">+</span> fixtoi <span class="br0">&#40;</span><span class="nu0">9</span> <span class="sy0">*</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">,</span>
            makecol <span class="br0">&#40;</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu19">0</span><span class="sy0">,</span> <span class="nu19">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
        <span class="co1">// Determine whether we should turn left or right</span>
        <span class="co1">// using the dot product.</span>
        <span class="co1">// We use &amp; 0xFFFFFF as a trick to get an angle</span>
        <span class="co1">// between 0 and 256.</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>fmul<span class="br0">&#40;</span>dy<span class="sy0">,</span><span class="br0">&#40;</span>target_x <span class="sy0">-</span> x<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">+</span> fmul<span class="br0">&#40;</span><span class="sy0">-</span>dx<span class="sy0">,</span><span class="br0">&#40;</span>target_y <span class="sy0">-</span> y<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu19">0</span><span class="br0">&#41;</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">-</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
        <span class="kw1">else</span>
            angle <span class="sy0">=</span> <span class="br0">&#40;</span>angle <span class="sy0">+</span> angle_stepsize<span class="br0">&#41;</span> <span class="sy0">&amp;</span> <span class="nu12">0xFFFFFF</span>;
&nbsp;
        rest <span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Por alguna razón algunos expertos programadores de juegos prefieren no usar atan2() y prefieren por alguna razón el producto punto. ¿sera porque atan2() puede introducir error de redondeo? no estoy seguro. En el caso del misil ambos métodos trabajan bien, y es método a utilizar es una cuestión de preferencia.
</p>

</div>
<!-- SECTION "usando el producto punto" [28943-33755] -->
<h2><a name="seno_coseno_mapas_de_bit_y_rotacion" id="seno_coseno_mapas_de_bit_y_rotacion">seno, coseno, mapas de bit y rotación</a></h2>
<div class="level2">

<p>
 A lo largo del artículo hemos mencionado algunas aplicaciones que se le pueden dar a las funciones seno y coseno. Pero de hecho no hay fin para el uso de estas dos funciones. Daré otro ejemplo: rotación de sprites.
</p>

<p>
No debemos pensar: &#039;esto debe ser probablemente complicado y la biblioteca allegro ya nos provee de ello, entonces no lo necesito&#039;. Pensemos en todas las modificaciones que podemos hacer si sabemos como trabaja la función de rotación de sprites - rotando mapa de tiles por ejemplo.
</p>

<p>
Entonces, ¿como trabaja? Existen 2 maneras de hacer esto. Una, la más obvia, es una iteración a través de todos los pixel del sprite que queremos rotar, calcular para cada pixel donde debe ir en pantalla, y después copiarlo. Esto es ciertamente posible, pero no habrá correspondencia de uno a uno de los pixeles de la pantalla. Entonces deberíamos buscar otra forma.
</p>

<p>
Una alternativa es que iteramos a través de todos los pixeles en el bitmap objetivo (casi siempre la pantalla) y calculamos que pixel del sprite debería ir ahí. Así nos aseguramos que cada pixel se pinta en pantalla, y que ninguno se imprime 2 veces (o mas).
</p>

<p>
Empecemos en la posición (0,0) de la pantalla. ¿Que pixel del bitmap debería ir ahí?. Hacer esto simple, ponemos la posición (0,0) del sprite. Luego nos movemos un lugar a la derecha de la pantalla, a la posición (1,0). ¿Que pixel del sprite debería ir allí?. Eso depende del ángulo que queremos rotar. Si rotamos a 0 grados, ponemos el pixel (1,0) del sprite allí. Si rotamos 270 grados, deberíamos poner el pixel (0,1) allí. Con esté código podemos realizar el cálculo para cualquier ángulo:
</p>
<pre class="code c">sprite_x <span class="sy0">=</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
sprite_y <span class="sy0">=</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;</pre>
<p>
Luego vamos una posición más a la derecha. La posición en el sprite que deberíamos usar ahora es:
</p>
<pre class="code c">sprite_x <span class="sy0">=</span> <span class="nu0">2</span> <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
sprite_y <span class="sy0">=</span> <span class="nu0">2</span> <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;</pre>
<p>
Así sucesivamente. Como estamos trabajando linealmente, simplemente podemos calcular el sin y cos una vez y sumarle esto a la posición en el sprite, cada vez que hacemos un pixel a la derecha en el destino. Mira el siguiente código:
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> my_rotate_sprite <span class="br0">&#40;</span>BITMAP <span class="sy0">*</span>dest_bmp<span class="sy0">,</span> BITMAP <span class="sy0">*</span>src_bmp<span class="sy0">,</span>
    fixed angle<span class="sy0">,</span> fixed scale<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// current position in the source bitmap</span>
    fixed src_x<span class="sy0">,</span> src_y;
&nbsp;
    <span class="co1">// current position in the destination bitmap</span>
    <span class="kw4">int</span> dest_x<span class="sy0">,</span> dest_y;
&nbsp;
    <span class="co1">// src_x and src_y will change each time by dx and dy</span>
    fixed dx<span class="sy0">,</span> dy;
&nbsp;
    <span class="co1">// src_x and src_y will be initialized to start_x and start_y</span>
    <span class="co1">// at the beginning of each new line</span>
    fixed start_x <span class="sy0">=</span> <span class="nu19">0</span><span class="sy0">,</span> start_y <span class="sy0">=</span> <span class="nu19">0</span>;
&nbsp;
    <span class="co1">// We create a bit mask to make sure x and y are in bounds.</span>
    <span class="co1">// Unexpected things will happen</span>
    <span class="co1">// if the width or height are not powers of 2.</span>
    <span class="kw4">int</span> x_mask <span class="sy0">=</span> src_bmp<span class="sy0">-&gt;</span>w <span class="sy0">-</span> <span class="nu0">1</span>;
    <span class="kw4">int</span> y_mask <span class="sy0">=</span> src_bmp<span class="sy0">-&gt;</span>h <span class="sy0">-</span> <span class="nu0">1</span>;
&nbsp;
    <span class="co1">// calculate increments for the coordinates in the source bitmap</span>
    <span class="co1">// for when we move right one pixel on the destination bitmap</span>
    dx <span class="sy0">=</span> fmul <span class="br0">&#40;</span>fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="sy0">,</span> scale<span class="br0">&#41;</span>;
    dy <span class="sy0">=</span> fmul <span class="br0">&#40;</span>fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="sy0">,</span> scale<span class="br0">&#41;</span>;
&nbsp;
    <span class="kw1">for</span> <span class="br0">&#40;</span>dest_y <span class="sy0">=</span> <span class="nu19">0</span>; dest_y <span class="sy0">&lt;</span> dest_bmp<span class="sy0">-&gt;</span>h; dest_y<span class="sy0">++</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// set the position in the source bitmap to the</span>
        <span class="co1">// beginning of this line</span>
        src_x <span class="sy0">=</span> start_x;
        src_y <span class="sy0">=</span> start_y;
&nbsp;
        <span class="kw1">for</span> <span class="br0">&#40;</span>dest_x <span class="sy0">=</span> <span class="nu19">0</span>; dest_x <span class="sy0">&lt;</span> dest_bmp<span class="sy0">-&gt;</span>w; dest_x<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
            <span class="co1">// Copy a pixel.</span>
            <span class="co1">// This can be optimized a lot by using</span>
            <span class="co1">// direct bitmap access.</span>
            putpixel <span class="br0">&#40;</span>dest_bmp<span class="sy0">,</span> dest_x<span class="sy0">,</span> dest_y<span class="sy0">,</span>
                getpixel <span class="br0">&#40;</span>src_bmp<span class="sy0">,</span>
                    fixtoi <span class="br0">&#40;</span>src_x<span class="br0">&#41;</span> <span class="sy0">&amp;</span> x_mask<span class="sy0">,</span>
                    fixtoi <span class="br0">&#40;</span>src_y<span class="br0">&#41;</span> <span class="sy0">&amp;</span> y_mask<span class="br0">&#41;</span><span class="br0">&#41;</span>;
&nbsp;
            <span class="co1">// advance the position in the source bitmap</span>
            src_x <span class="sy0">+=</span> dx;
            src_y <span class="sy0">+=</span> dy;
        <span class="br0">&#125;</span>
&nbsp;
        <span class="co1">// for the next line we have a different starting position</span>
        start_x <span class="sy0">-=</span> dy;
        start_y <span class="sy0">+=</span> dx;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Y su salida en pantalla:
</p>

<p>
<a href="../../../../_detail/referencia/articulos/seno_coseno/ima/circ8.png-id=referencia-articulos-seno_coseno.html" class="media" title="referencia:articulos:seno_coseno:ima:circ8.png"><img src="../../../../_media/referencia/articulos/seno_coseno/ima/circ8.png" class="media" alt="" /></a>
</p>

<p>

Si miramos estas lineas:
</p>
<pre class="code c">dx <span class="sy0">=</span> fmul <span class="br0">&#40;</span>fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="sy0">,</span> scale<span class="br0">&#41;</span>;
dy <span class="sy0">=</span> fmul <span class="br0">&#40;</span>fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="sy0">,</span> scale<span class="br0">&#41;</span>;</pre>
<p>
Aquí calculamos el sin y cos del ángulo. El prefijo “d” en &#039;dx&#039; y &#039;dy&#039; hace referencia a delta. Esto representa el cambio en la posición en el sprite, a medida que avanzamos al próximo pixel en la pantalla. Como puedes ver, se introduce un factor de escala, así podemos hacer un acercamiento y un alejamiento de la imagen.
</p>

<p>
En las siguientes lineas:
</p>
<pre class="code c">putpixel <span class="br0">&#40;</span>dest_bmp<span class="sy0">,</span> dest_x<span class="sy0">,</span> dest_y<span class="sy0">,</span> getpixel <span class="br0">&#40;</span>src_bmp<span class="sy0">,</span>
                fixtoi <span class="br0">&#40;</span>src_x<span class="br0">&#41;</span> <span class="sy0">&amp;</span> x_mask<span class="sy0">,</span>
                fixtoi <span class="br0">&#40;</span>src_y<span class="br0">&#41;</span> <span class="sy0">&amp;</span> y_mask<span class="br0">&#41;</span><span class="br0">&#41;</span></pre>
<p>
 …el pixel se copia desde el bitmap fuente (el sprite) al bitmap objetivo (la pantalla). Por supuesto que &#039;dest&#039; hace referencia a destino (destination en inglés) y &#039;src&#039; a fuente (source en inglés). Se utiliza mascara para asegurarnos que la posición en el bitmap fuente es válida, para no obtener un pixel que esta afuera del bitmap. Esto solo es aplicable si las dimensiones del bitmap fuente son potencia de 2, por ejemplo bitmaps de 32&times;32, o 64&times;256 funcionarían. Pero un bitmap de 100&times;100 no lo haría, porque 100 no es potencia de 2.
</p>

<p>
Con las siguientes lineas, nos movemos a la siguiente posición en la pantalla. &#039;dest_x&#039; es incrementada en el ciclo for, y &#039;src_x&#039; y &#039;src_y&#039; son incrementadas por &#039;dx&#039; y &#039;dy&#039; calculados anteriormente:
</p>
<pre class="code c">src_x <span class="sy0">+=</span> dx;
src_y <span class="sy0">+=</span> dy;</pre>
<p>
Después de que toda la linea se imprime, la posición en el bitmap fuente es devuelta a la posición del comienzo grabada en &#039;start_x&#039; y &#039;start_y&#039;. Por supuesto que &#039;start_x&#039; y &#039;start_y&#039; tienen que cambiar para poder ir una linea mas abajo. Al ser, un pixel para abajo, perpendicular al pixel que esta una posición a la derecha, utilizamos el mismo truco que usamos con el producto punto: remplazamos &#039;dx&#039; con &#039;-dy&#039; y &#039;dy&#039; con &#039;dx&#039;. Entonces aquí tenemos como la posición inicial debería cambiarse:
</p>
<pre class="code c">start_x <span class="sy0">-=</span> dy;
start_y <span class="sy0">+=</span> dx;</pre>
</div>
<!-- SECTION "seno, coseno, mapas de bit y rotación" [33756-39716] -->
<h2><a name="rotacion" id="rotacion">rotación</a></h2>
<div class="level2">

<p>
Supongamos que en cierto juego queremos rotar un punto alrededor de otro punto. Por ejemplo el jugador puede saltar de una cuerda y dar vueltas por ella y por ultimo saltar a una plataforma. Puede representar la vuelta como una rotación del jugador alrededor del punto donde la cuerda esta sujeta. Para poder hacer ello, necesitamos calcular el vector que va del jugador al centro de la rotación, donde la cuerda esta atada, tomamos el ángulo de este vector, incrementamos un poco, y recalculamos la posición del jugador.
</p>

<p>
Esto no es práctico aquí, porque la mayoría de las veces, guardamos la posición del jugador en coordenadas cartesianas. Tendríamos que calcular el ángulo del vector, del jugador hacia el centro de rotación, con atan2(). Después de incrementar el ángulo, podemos calcular las nuevas coordenadas x e y con sin y cos. Aquí esta el ejemplo:
</p>
<pre class="code c">angle <span class="sy0">=</span> atan2 <span class="br0">&#40;</span>y<span class="sy0">,</span> x<span class="br0">&#41;</span>;
length <span class="sy0">=</span> sqrt <span class="br0">&#40;</span>x <span class="sy0">*</span> x <span class="sy0">+</span> y <span class="sy0">*</span> y<span class="br0">&#41;</span>;
angle <span class="sy0">+=</span> <span class="nu0">1</span>;
new_x <span class="sy0">=</span> length <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;
new_y <span class="sy0">=</span> length <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>;</pre>
<p>
Al convertir las coordenadas cartesianas a coordenadas polares y viceversa, podemos perder presición. Existe una manera mejor; podemos hacer uso de una matriz de rotación. Las Matrices de rotación se utilizan frecuentemente en el mundo de gráficos 3D, pero también se pueden utilizar en 2D tranquilamente. Ellas proveen una manera de rotar un vector sin convertirlo a coordenadas polares. Aquí está la ecuación:
</p>
<pre class="code c">new_x <span class="sy0">=</span> x <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">-</span> y <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span>
new_y <span class="sy0">=</span> x <span class="sy0">*</span> sin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span> <span class="sy0">+</span> y <span class="sy0">*</span> cos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span></pre>
<p>
En este caso &#039;angle&#039; es el ángulo con el que queremos rotar el vector. &#039;x&#039; e &#039;y&#039; son las coordenadas viejas del vector, y &#039;new_x&#039; y &#039;new_y&#039; son las nuevas coordenadas del vector. Con este método, podemos realizar rotaciones sin usar atan2. Es lógico precalcular cos y sin, ya que las necesitaremos 2 veces a cada una.
</p>

<p>
Aquí hay un ejemplo completo usando este método. Todo lo que se hace es rotar cuatro puntos alrededor del centro de la pantalla
</p>
<pre class="code c"><span class="br0">&#91;</span>...<span class="br0">&#93;</span>
<span class="kw4">void</span> projection_test<span class="br0">&#40;</span><span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// initialize the coordinates of four dots</span>
    fixed dot_x<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span>itofix<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="br0">&#125;</span>;
    fixed dot_y<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span>itofix<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="sy0">,</span> itofix<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">50</span><span class="br0">&#41;</span><span class="br0">&#125;</span>;
&nbsp;
    fixed angle <span class="sy0">=</span> <span class="nu19">0</span>;
    fixed angle_stepsize <span class="sy0">=</span> itofix <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span>;
&nbsp;
    <span class="co1">// proj_x and proj_y will contain the projection of the dots</span>
    fixed proj_x<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span>;
    fixed proj_y<span class="br0">&#91;</span><span class="nu0">4</span><span class="br0">&#93;</span>;
&nbsp;
    <span class="kw4">int</span> i;
&nbsp;
    <span class="co1">// repeat this loop until Esc is pressed</span>
    <span class="kw1">while</span> <span class="br0">&#40;</span><span class="sy0">!</span>key<span class="br0">&#91;</span>KEY_ESC<span class="br0">&#93;</span><span class="br0">&#41;</span>
    <span class="br0">&#123;</span>
        <span class="co1">// project all the dots to their new positions after rotation</span>
        <span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu19">0</span>; i <span class="sy0">&lt;</span> <span class="nu0">4</span>; i<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
            proj_x<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> fmul <span class="br0">&#40;</span>dot_x<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">-</span>
                fmul <span class="br0">&#40;</span>dot_y<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span>;
            proj_y<span class="br0">&#91;</span>i<span class="br0">&#93;</span> <span class="sy0">=</span> fmul <span class="br0">&#40;</span>dot_x<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> fsin <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">+</span>
                fmul <span class="br0">&#40;</span>dot_y<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="sy0">,</span> fcos <span class="br0">&#40;</span>angle<span class="br0">&#41;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
&nbsp;
        <span class="co1">// draw the four dots</span>
        <span class="kw1">for</span> <span class="br0">&#40;</span>i <span class="sy0">=</span> <span class="nu19">0</span>; i <span class="sy0">&lt;</span> <span class="nu0">4</span>; i<span class="sy0">++</span><span class="br0">&#41;</span>
        <span class="br0">&#123;</span>
            putpixel <span class="br0">&#40;</span>screen<span class="sy0">,</span>
                fixtoi <span class="br0">&#40;</span>proj_x<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_W <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
                fixtoi <span class="br0">&#40;</span>proj_y<span class="br0">&#91;</span>i<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="sy0">+</span> SCREEN_H <span class="sy0">/</span> <span class="nu0">2</span><span class="sy0">,</span>
                makecol <span class="br0">&#40;</span><span class="nu0">255</span> <span class="sy0">,</span><span class="nu0">255</span><span class="sy0">,</span> <span class="nu0">255</span><span class="br0">&#41;</span><span class="br0">&#41;</span>;
        <span class="br0">&#125;</span>
&nbsp;
        rest <span class="br0">&#40;</span><span class="nu0">10</span><span class="br0">&#41;</span>;
        clear <span class="br0">&#40;</span>screen<span class="br0">&#41;</span>;
&nbsp;
        angle <span class="sy0">+=</span> angle_stepsize;
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="br0">&#91;</span>...<span class="br0">&#93;</span></pre>
<p>
Para más información en matrices de rotación consulté este vínculo: <a href="http://www.student.hk-r.se/~pt93mm/thesis/techniques/3d_tutorial/3d.html" class="urlextern" title="http://www.student.hk-r.se/~pt93mm/thesis/techniques/3d_tutorial/3d.html"  rel="nofollow">http://www.student.hk-r.se/~pt93mm/thesis/techniques/3d_tutorial/3d.html</a>
</p>

<p>
Este sitio también contiene información acerca de proyecciones en 3D.
</p>

<p>
Existe un caso especial en rotaciones con matrices; una rotación de 90 grados. Para realizar este tipo de rotación hacemos lo siguiente: supongamos que tenemos un punto con coordenadas (4,8) y queremos rotarlo 90 grados alrededor del origen:
</p>
<pre class="code c">new_x <span class="sy0">=</span> x <span class="sy0">*</span> cos <span class="br0">&#40;</span><span class="nu0">90</span><span class="br0">&#41;</span> <span class="sy0">-</span> y <span class="sy0">*</span> sin <span class="br0">&#40;</span><span class="nu0">90</span><span class="br0">&#41;</span>
new_y <span class="sy0">=</span> x <span class="sy0">*</span> sin <span class="br0">&#40;</span><span class="nu0">90</span><span class="br0">&#41;</span> <span class="sy0">+</span> y <span class="sy0">*</span> cos <span class="br0">&#40;</span><span class="nu0">90</span><span class="br0">&#41;</span></pre>
<p>

cos (90) es 0 y sin (90) es 1, entonces simplifiquemos la formula así:
</p>
<pre class="code c">new_x <span class="sy0">=</span> <span class="sy0">-</span>y;
new_y <span class="sy0">=</span> x;</pre>
<p>
Entonces las nuevas coordenadas son (-8, 4). Usamos este truco 2 veces, ahora ya sabemos porque funciona. Si queremos rotar el punto (4, 8) por 180 grados alrededor del origen, obtenemos lo siguiente:
</p>
<pre class="code c">new_x <span class="sy0">=</span> x <span class="sy0">*</span> cos <span class="br0">&#40;</span><span class="nu0">180</span><span class="br0">&#41;</span> <span class="sy0">-</span> y <span class="sy0">*</span> sin <span class="br0">&#40;</span><span class="nu0">180</span><span class="br0">&#41;</span>;
new_y <span class="sy0">=</span> x <span class="sy0">*</span> sin <span class="br0">&#40;</span><span class="nu0">180</span><span class="br0">&#41;</span> <span class="sy0">+</span> y <span class="sy0">*</span> cos <span class="br0">&#40;</span><span class="nu0">180</span><span class="br0">&#41;</span>;</pre>
<p>

o:
</p>
<pre class="code c">new_x <span class="sy0">=</span> <span class="sy0">-</span>x
new_y <span class="sy0">=</span> <span class="sy0">-</span>y</pre>
<p>
Entonces la nueva coordenada es (-4, -8). En la tabla de abajo podemos ver como rotar por ángulos de 90, 180 y 270 grados.
</p>
<table class="inline">
	<tr class="row0">
		<th class="col0 rightalign">    </th><th class="col1"> 90 degrees </th><th class="col2"> 180 degrees </th><th class="col3"> 270 degrees </th><th class="col4"> 360 degrees </th>
	</tr>
	<tr class="row1">
		<td class="col0">new x value </td><td class="col1 rightalign">	-y</td><td class="col2 rightalign"> 	-x</td><td class="col3 rightalign"> 	y </td><td class="col4 rightalign">	x</td>
	</tr>
	<tr class="row2">
		<td class="col0">new y value </td><td class="col1 rightalign">	x </td><td class="col2 rightalign">	-y</td><td class="col3 rightalign"> 	-x</td><td class="col4 rightalign"> 	y</td>
	</tr>
</table>

</div>
<!-- SECTION "rotación" [39717-44184] -->
<h2><a name="informacion_adicional_acerca_del_documento" id="informacion_adicional_acerca_del_documento">Información adicional acerca del documento</a></h2>
<div class="level2">

<p>
El artículo original (en inglés) fué realizado por Amarillion (amarillion _arroba_ yahoo _dot_ com) para el número 5 de la revista electrónica Pixelate (<a href="http://www.allegro.cc/pixelate" class="urlextern" title="http://www.allegro.cc/pixelate"  rel="nofollow">http://www.allegro.cc/pixelate</a>).
</p>

<p>
La presente versión no es una traducción literal del artículo original, existen ligeras modificaciones a fin de simplificar la redacción y adaptar los términos al español. Si tiene alguna duda por favor cominiquese con nosotros.
</p>

</div>
<!-- SECTION "Información adicional acerca del documento" [44185-] --></div>
</body>
</html>
