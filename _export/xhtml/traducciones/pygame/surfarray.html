<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es"
 lang="es" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>traducciones:pygame:surfarray</title>
<meta name="generator" content="DokuWiki Release 2009-02-14b" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2009-01-31T18:59:16+0300" />
<meta name="keywords" content="traducciones,pygame,surfarray" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="Losersjuegos" />
<link rel="start" href="../../../../index.html" />
<link rel="contents" href="../../../../traducciones/pygame/surfarray-do=index.html" title="Indice" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php.rss" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php-mode=list&amp;ns=traducciones-pygame.rss" />
<link rel="alternate" type="text/html" title="Plain HTML" href="surfarray.html" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../../raw/traducciones/pygame/surfarray.txt" />
<link rel="stylesheet" media="all" type="text/css" href="../../../../lib/exe/css.php-s=all&amp;t=sidebar.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../../../../lib/exe/css.php-t=sidebar.css" />
<link rel="stylesheet" media="print" type="text/css" href="../../../../lib/exe/css.php-s=print&amp;t=sidebar.css" />
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php-edit=0&amp;write=0.js" ></script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Tabla de Contenidos</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#surfarray" class="toc">surfarray</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#array2d" class="toc">array2d</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#pixels2d" class="toc">pixels2d</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#array3d" class="toc">array3d</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#pixels3d" class="toc">pixels3d</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#array_alpha" class="toc">array_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#pixels_alpha" class="toc">pixels_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#array_colorkey" class="toc">array_colorkey</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#make_surface" class="toc">make_surface</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#blit_array" class="toc">blit_array</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#map_array" class="toc">map_array</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#use_arraytype" class="toc">use_arraytype</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_arraytype" class="toc">get_arraytype</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_arraytypes" class="toc">get_arraytypes</a></span></div></li></ul>
</li></ul>
</div>
</div>
<!-- TOC END -->



<h1><a name="surfarray" id="surfarray">surfarray</a></h1>
<div class="level1">



<p>
Módulo de pygame para acceder a los pixels de una superficie
usando una matriz como interfaz.
</p>
<div class='box' style='width: 90%;'>
  <b class='xtop'><b class='xb1'></b><b class='xb2'></b><b class='xb3'></b><b class='xb4'></b></b>
  <div class='xbox'>
<div class='box_content'><p><ul>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#array2d" class="wikilink1" title="traducciones:pygame:surfarray">array2d</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#pixels2d" class="wikilink1" title="traducciones:pygame:surfarray">pixels2d</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#array3d" class="wikilink1" title="traducciones:pygame:surfarray">array3d</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#pixels3d" class="wikilink1" title="traducciones:pygame:surfarray">pixels3d</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#array_alpha" class="wikilink1" title="traducciones:pygame:surfarray">array_alpha</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#pixels_alpha" class="wikilink1" title="traducciones:pygame:surfarray">pixels_alpha</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#array_colorkey" class="wikilink1" title="traducciones:pygame:surfarray">array_colorkey</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#make_surface" class="wikilink1" title="traducciones:pygame:surfarray">make_surface</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#blit_array" class="wikilink1" title="traducciones:pygame:surfarray">blit_array</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#map_array" class="wikilink1" title="traducciones:pygame:surfarray">map_array</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#use_arraytype" class="wikilink1" title="traducciones:pygame:surfarray">use_arraytype</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#get_arraytype" class="wikilink1" title="traducciones:pygame:surfarray">get_arraytype</a></span></div>
</li>
<li class="level1"><div class="li"> <span class="curid"><a href="../../../../traducciones/pygame/surfarray.html#get_arraytypes" class="wikilink1" title="traducciones:pygame:surfarray">get_arraytypes</a></span></div>
</li>
</ul>
</div>
  </div>
  <b class='xbottom'><b class='xb4'></b><b class='xb3'></b><b class='xb2'></b><b class='xb1'></b></b>
</div>



<p>
Funciones para convertir datos de pixel entre matrices y superficies
de pygame. Este módulo solo funcionará cuando pygame puede tener
acceso a los paquetes externos Numpy o Numeric.
</p>



<p>
Cada pixel se almacena como un único valor entero para representar
los colores rojo, verde y azul. Las imágenes de 8 bits usan un
valor de referencia a una paleta de colores. Los pixels que pueden
representar mas colores usan un proceso de empaquetamiento de bits
para agrupar tres o cuatro valores en un único número.
</p>



<p>

La matriz se organiza primero por su eje <code>X</code> y luego su eje
<code>Y</code>. Las Matrices que tratan a los pixels como números empaquetados
se definen como Matrices de dos dimensiones. Este módulo también
puede separar las componentes de color en mas dimensiones; estos
tipos de matrices se definen como matrices de tres dimensiones, donde
el último indice indica con 0 el componente rojo, con 1 el componente
verde y con 2 el azul.
</p>



<p>
Los sistemas de matriz que se utilizan son:
</p>


<ul>
<li class="level1"><div class="li"> numeric</div>
</li>
<li class="level1"><div class="li"> numpy</div>
</li>
</ul>



<p>
Por defecto se utilizará <code>Numeric</code>, siempre y cuando esté instalado. En
otro caso se usará <code>numpy</code> si está instalado. Se lanzará la
excepción <code>ImportError</code> si ninguno de los dos paquetes
está instalado.
</p>



<p>
El sistema que se utilizará se puede cambiar en tiempo de
ejecución usando el método <code>use_arraytype()</code>, que necesita
como argumento el sistema de matriz a utilizar.
</p>



<p>
Nota: numpy y Numeric no son completamente compatibles. Algunas manipulaciones de vectores pueden funcionar en un sistema, pero tener un comportamiento diferente o incluso no funcionar en otro.
</p>



<p>
Además, a diferencia de Numeric, numpy puede usar enteros sin signo de 16 bits. Las imágenes con datos de 16 bits se tratarán como números sin signo. En cambio, Numeric siempre utilizará enteros con signo para la representación, es importante tener esto en mente, ya que usted puede estar utilizando funciones del módulo y sorprenderse por los valores.
</p>



<p>
El soporte para <code>numpy</code> es nuevo en pygame 1.8
</p>

</div>
<!-- SECTION "surfarray" [1-4611] -->
<h2><a name="array2d" id="array2d">array2d</a></h2>
<div class="level2">



<p>
Copia los pixels en una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">array2d</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Copia los pixels desde una superficie a una matriz de dos
dimensiones. La profundidad de colores de la superficie controlará
el tamaño de los valores enteros, y funcionará para
cualquier tipo de formato de pixel.
</p>



<p>
Esta función bloqueará temporalmente la superficie (vea la función
<code>Surface.lock</code> para mas detalles).
</p>

</div>
<!-- SECTION "array2d" [4612-5440] -->
<h2><a name="pixels2d" id="pixels2d">pixels2d</a></h2>
<div class="level2">



<p>
Genera una referencia a los pixels en una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">pixels2d</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Genera una nueva matriz de dos dimensiones que referencia directamente
a los valores de pixels en una superficie. Cualquier cambio
en la matriz afectará a los pixels de la superficie. Esta es una
operación rápida ya que no se duplican los datos.
</p>



<p>
No se pueden crear matrices de referencia para superficies
de 24 bits, pero si de cualquier otro tipo de superficies.
</p>



<p>
La superficie a la que se hace referencia permanecerá bloqueada mientras
dure la vida del objeto matriz (vea el método <code>Surface.lock</code> para
mas detalles).
</p>

</div>
<!-- SECTION "pixels2d" [5441-6626] -->
<h2><a name="array3d" id="array3d">array3d</a></h2>
<div class="level2">



<p>
Copia los pixels en una matriz de tres dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">array3d</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Copia los pixels desde una superficie a una matriz de tres
dimensiones. La profundidad de colores de la superficie controlará
el tamaño de los valores enteros, y funcionará para
cualquier tipo de formato de pixel.
</p>



<p>
Esta función bloqueará temporalmente la superficie (vea la función
<code>Surface.lock</code> para mas detalles).
</p>

</div>
<!-- SECTION "array3d" [6627-7455] -->
<h2><a name="pixels3d" id="pixels3d">pixels3d</a></h2>
<div class="level2">



<p>
Genera una referencia a los pixels en una matriz de tres dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">pixels3d</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Genera una nueva matriz de tres dimensiones que referencia directamente
a los valores de pixels en una superficie. Cualquier cambio
en la matriz afectará a los pixels de la superficie. Esta es una
operación rápida ya que no se duplican los datos.
</p>



<p>
Esta operación solo funciona en superficies que tienen formatos
de 24 o 32 bits. No se puede crear referencias a formatos
de pixel mas bajos.
</p>



<p>
La superficie a la que se hace referencia permanecerá bloqueada mientras
dure la vida del objeto matriz (vea el método <code>Surface.lock</code> para
mas detalles).
</p>

</div>
<!-- SECTION "pixels3d" [7456-8688] -->
<h2><a name="array_alpha" id="array_alpha">array_alpha</a></h2>
<div class="level2">



<p>
Copia los valores alphas a una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">array_alpha</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Copia los valores alpha de los pixel (el grado de transparencia) desde
una superficie a una matriz de dos dimensiones. Esta operación funcionará
para cualquier formato de superficie. Las superficies
que no tienen valores alpha retornarán una matriz con todos
los valores opacos.
</p>



<p>
Esta función bloqueará temporalmente la superficie (vea la función
<code>Surface.lock</code> para mas detalles).
</p>

</div>
<!-- SECTION "array_alpha" [8689-9647] -->
<h2><a name="pixels_alpha" id="pixels_alpha">pixels_alpha</a></h2>
<div class="level2">



<p>
Genera una referencia a los pixels alpha en una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">pixels_alpha</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Genera una nueva matriz de dos dimensiones que referencia directamente
a los valores alpha de una superficie. Cualquier cambio
en la matriz afectará a los pixels de la superficie. Esta es una
operación rápida ya que no se duplican los datos.
</p>



<p>
Solo puede funcionar en superficies de 32 bits con valores alpha
por cada pixel.
</p>



<p>
La superficie a la que se hace referencia permanecerá bloqueada mientras
dure la vida del objeto matriz (vea el método <code>Surface.lock</code> para
mas detalles).
</p>

</div>
<!-- SECTION "pixels_alpha" [9648-10749] -->
<h2><a name="array_colorkey" id="array_colorkey">array_colorkey</a></h2>
<div class="level2">



<p>
Copia los valores clave de una superficie en una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">array_colorkey</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw3">array</span></pre>


<p>
Genera una nueva matriz con los valores de transparencia por color
clave de cada pixel. El pixel será completamente transparente
si coincide con el valor del color clave; en caso contrario el
pixel será completamente opaco.
</p>



<p>
Esta operación funcionará sobre cualquier tupo de formato de superficie. Si
la imagen no tiene color calve se retornará una matriz completamente
sólida.
</p>



<p>
Esta función bloqueará temporalmente la superficie.
</p>

</div>
<!-- SECTION "array_colorkey" [10750-11799] -->
<h2><a name="make_surface" id="make_surface">make_surface</a></h2>
<div class="level2">



<p>
Convierte una matriz en una nueva superficie.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">make_surface</span><span class="br0">&#40;</span><span class="kw3">array</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Genera una nueva superficie que coincide con los datos y el
formato en la matriz. La matriz puede ser de dos o tres dimensiones
con cualquier cantidad de valores enteros.
</p>

</div>
<!-- SECTION "make_surface" [11800-12297] -->
<h2><a name="blit_array" id="blit_array">blit_array</a></h2>
<div class="level2">



<p>
Dibuja directamente sobre los valores de una matriz.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">blit_array</span><span class="br0">&#40;</span>Surface, <span class="kw3">array</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Copia valores directamente desde una matriz sobre una superficie. Esta
operación es mas rápida que convertir la matriz en una superficie
y luego imprimirla. La matriz debe tener las mismas dimensiones
que la superficie y la operación reemplazará complemente todos los
valores de los pixels.
</p>



<p>
Esta función bloqueará temporalmente la superficie como los nuevos
valores que se copian.
</p>

</div>
<!-- SECTION "blit_array" [12298-13198] -->
<h2><a name="map_array" id="map_array">map_array</a></h2>
<div class="level2">



<p>
Convierte una matriz de tres dimensiones a una matriz de dos dimensiones.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">map_array</span><span class="br0">&#40;</span>Surface, array3d<span class="br0">&#41;</span>: <span class="kw1">return</span> array2d</pre>


<p>
Convierte una matriz de tres dimensiones en una matriz de dos dimensiones. Esta
función usará el formato de la superficie dada para controlar
la conversión. Los formatos de superficie basados en una paleta no
están soportados.
</p>

</div>
<!-- SECTION "map_array" [13199-13802] -->
<h2><a name="use_arraytype" id="use_arraytype">use_arraytype</a></h2>
<div class="level2">



<p>
Define el sistema de matriz que se usará para matrices de superficie.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">use_arraytype</span> <span class="br0">&#40;</span>arraytype<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Usa el tipo de matriz indicado para el resto de las funciones
del módulo. Los tipos de matriz disponibles son:
</p>


<ul>
<li class="level1"><div class="li"> numeric </div>
</li>
<li class="level1"><div class="li"> numpy</div>
</li>
</ul>



<p>
Se lanzará una excepción <code>ValueError</code> si el tipo de matriz solicitado
no está disponible.
</p>



<p>
Esta función es nueva a partir de pygame 1.8
</p>

</div>
<!-- SECTION "use_arraytype" [13803-14551] -->
<h2><a name="get_arraytype" id="get_arraytype">get_arraytype</a></h2>
<div class="level2">



<p>
Obtiene el tipo de matriz utilizado actualmente.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">get_arraytype</span> <span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">str</span></pre>


<p>
Retorna el tipo de matriz que que se utiliza actualmente. Este
valor será uno de los que forman parte de la tupla que
devuelve <code>get_arraytypes()</code> e indica que sistema de matriz
que se usará para la creación de matrices.
</p>



<p>
Esta función es nueva en pygame 1.8
</p>

</div>
<!-- SECTION "get_arraytype" [14552-15203] -->
<h2><a name="get_arraytypes" id="get_arraytypes">get_arraytypes</a></h2>
<div class="level2">



<p>
Obtiene los sistema de matriz actualmente soportadas.
</p>
<pre class="code python">pygame.<span class="me1">surfarray</span>.<span class="me1">get_arraytypes</span> <span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">tuple</span></pre>


<p>
Consulta que tipo de sistemas de vector están disponibles y los
retorna como una tupla de cadenas de caracteres. Los valores de la
tupla se pueden usar directamente en el método
<code>pygame.surfarray.use_arraytype()</code>. Si no hay sistema de matriz
disponible se podría obtener <code>None</code> como retorno.
</p>



<p>
Esta función es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "get_arraytypes" [15204-] --></div>
</body>
</html>
