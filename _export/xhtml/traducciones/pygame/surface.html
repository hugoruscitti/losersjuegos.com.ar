<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es"
 lang="es" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>traducciones:pygame:surface</title>
<meta name="generator" content="DokuWiki Release 2009-02-14b" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2009-01-26T00:36:34+0300" />
<meta name="keywords" content="traducciones,pygame,surface" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="Losersjuegos" />
<link rel="start" href="../../../../index.html" />
<link rel="contents" href="../../../../traducciones/pygame/surface-do=index.html" title="Indice" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php.rss" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php-mode=list&amp;ns=traducciones-pygame.rss" />
<link rel="alternate" type="text/html" title="Plain HTML" href="surface.html" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../../raw/traducciones/pygame/surface.txt" />
<link rel="stylesheet" media="all" type="text/css" href="../../../../lib/exe/css.php-s=all&amp;t=sidebar.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../../../../lib/exe/css.php-t=sidebar.css" />
<link rel="stylesheet" media="print" type="text/css" href="../../../../lib/exe/css.php-s=print&amp;t=sidebar.css" />
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php-edit=0&amp;write=0.js" ></script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Tabla de Contenidos</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#surface" class="toc">Surface</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#surface1" class="toc">Surface</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#blit" class="toc">blit</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#convert" class="toc">convert</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#convert_alpha" class="toc">convert_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#copy" class="toc">copy</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#fill" class="toc">fill</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_colorkey" class="toc">set_colorkey</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_colorkey" class="toc">get_colorkey</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_alpha" class="toc">set_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_alpha" class="toc">get_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#lock" class="toc">lock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#unlock" class="toc">unlock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#mustlock" class="toc">mustlock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_locked" class="toc">get_locked</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_locks" class="toc">get_locks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_at" class="toc">get_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_at" class="toc">set_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_palette" class="toc">get_palette</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_palette_at" class="toc">get_palette_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_palette" class="toc">set_palette</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_palette_at" class="toc">set_palette_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#map_rgb" class="toc">map_rgb</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#unmap_rgb" class="toc">unmap_rgb</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_clip" class="toc">set_clip</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_clip" class="toc">get_clip</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#subsurface" class="toc">subsurface</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_parent" class="toc">get_parent</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_abs_parent" class="toc">get_abs_parent</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_offset" class="toc">get_offset</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_abs_offset" class="toc">get_abs_offset</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_size" class="toc">get_size</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_width" class="toc">get_width</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_height" class="toc">get_height</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_rect" class="toc">get_rect</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bitsize" class="toc">get_bitsize</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bytesize" class="toc">get_bytesize</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_flags" class="toc">get_flags</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_pitch" class="toc">get_pitch</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_masks" class="toc">get_masks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_masks" class="toc">set_masks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_shifts" class="toc">get_shifts</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_shifts" class="toc">set_shifts</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_losses" class="toc">get_losses</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bounding_rect" class="toc">get_bounding_rect</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_buffer" class="toc">get_buffer</a></span></div></li></ul>
</li></ul>
</div>
</div>
<!-- TOC END -->



<h1><a name="surface" id="surface">Surface</a></h1>
<div class="level1">



<p>
Objeto de pygame para representar imágenes.
</p>
<div class='box' style='width: 90%;'>
  <b class='xtop'><b class='xb1'></b><b class='xb2'></b><b class='xb3'></b><b class='xb4'></b></b>
  <div class='xbox'>
<div class='box_content'><p><ul>
<li class="level1"><div class="li"> <a href="#surface" title="traducciones:pygame:surface &crarr;" class="wikilink1">Surface</a></div>
</li>
<li class="level1"><div class="li"> <a href="#blit" title="traducciones:pygame:surface &crarr;" class="wikilink1">blit</a></div>
</li>
<li class="level1"><div class="li"> <a href="#convert" title="traducciones:pygame:surface &crarr;" class="wikilink1">convert</a></div>
</li>
<li class="level1"><div class="li"> <a href="#convert_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">convert_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#copy" title="traducciones:pygame:surface &crarr;" class="wikilink1">copy</a></div>
</li>
<li class="level1"><div class="li"> <a href="#fill" title="traducciones:pygame:surface &crarr;" class="wikilink1">fill</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_colorkey" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_colorkey</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_colorkey" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_colorkey</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#lock" title="traducciones:pygame:surface &crarr;" class="wikilink1">lock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#unlock" title="traducciones:pygame:surface &crarr;" class="wikilink1">unlock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#mustlock" title="traducciones:pygame:surface &crarr;" class="wikilink1">mustlock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_locked" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_locked</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_locks" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_locks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_palette" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_palette</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_palette_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_palette_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_palette" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_palette</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_palette_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_palette_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#map_rgb" title="traducciones:pygame:surface &crarr;" class="wikilink1">map_rgb</a></div>
</li>
<li class="level1"><div class="li"> <a href="#unmap_rgb" title="traducciones:pygame:surface &crarr;" class="wikilink1">unmap_rgb</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_clip" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_clip</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_clip" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_clip</a></div>
</li>
<li class="level1"><div class="li"> <a href="#subsurface" title="traducciones:pygame:surface &crarr;" class="wikilink1">subsurface</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_parent" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_parent</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_abs_parent" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_abs_parent</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_offset" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_offset</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_abs_offset" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_abs_offset</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_size" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_size</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_width" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_width</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_height" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_height</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_rect" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_rect</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bitsize" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bitsize</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bytesize" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bytesize</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_flags" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_flags</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_pitch" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_pitch</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_masks" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_masks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_masks" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_masks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_shifts" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_shifts</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_shifts" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_shifts</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_losses" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_losses</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bounding_rect" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bounding_rect</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_buffer" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_buffer</a></div>
</li>
</ul>
</div>
  </div>
  <b class='xbottom'><b class='xb4'></b><b class='xb3'></b><b class='xb2'></b><b class='xb1'></b></b>
</div>

</div>
<!-- SECTION "Surface" [1-1005] -->
<h2><a name="surface1" id="surface1">Surface</a></h2>
<div class="level2">
<pre class="code python">pygame.<span class="me1">Surface</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span>, flags=0, depth=0, masks=<span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
pygame.<span class="me1">Surface</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span>, flags=0, Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Un objeto Surface de pygame se utiliza para representar cualquier imagen.
La superficie tiene un formato de pixel y resolución fija. Las superficies
con pixeles de 8 bits usan una paleta de 256 colores.
</p>



<p>
Invoque <code>pygame.Surface()</code> para crear un nuevo objeto image. La superficie
será completamente negra. El único argumento requerido es el tamaño. La
superficie se creará con el formato que mejor coincida con la pantalla
actual si no se especifican los argumentos adicionales.
</p>



<p>
El formato de pixel se puede controlar especificando la profundidad
de colores o una superficie existente. El argumento <code>flags</code> es una
combinación de características adiciones para la superficie. Puede
utilizar cualquier combinación de estas:
</p>


<ul>
<li class="level1"><div class="li"> HWSURFACE: Genera la imagen en la memoria de video.</div>
</li>
<li class="level1"><div class="li"> SRCALPHA: El formato de pixel incluirá transparencias por pixel.</div>
</li>
</ul>



<p>
Ambas opciones son solo una solicitud, tal vez no sea posible para
todos los modos de video.
</p>



<p>
Los usuarios avanzados pueden combinar un conjunto de opciones con
un valor <code>depth</code>. El argumento <code>masks</code> es un conjunto de 4 números
enteros que especifica cuales bits representan a cada color en el
pixel. Las superficies normales no requieren el argumento <code>mask</code>.
</p>



<p>
Las superficies pueden tener varios atributos adicionales como planos
alpha, colores clave o recortes. Estas funciones afectan principalmente
a la forma en que se imprime la superficie sobre otra. Las rutinas <code>blit</code>
intentarán usar aceleración de hardware cuando sea posible, en caso contrario
usarán métodos de impresión por software muy optimizados.
</p>



<p>

Existen tres tipos de transparencia en pygame: colores clave,
transparencia de superficie, y transparencia de pixel. La transparencia
de superficie se puede combinar con colores clave, pero las imágenes con
transparencia de pixel no puede usar los otros modos. La transparencia
por color clave hace transparente un solo color. No se imprimirán
los pixeles que coincidan con el color clave. La transparencia
de superficie es un valor individual que cambia la transparencia de la
imagen completa. Una transparencia de superficie de 255 será opaca mientras
que un valor de 0 será completamente transparente.
</p>



<p>
La transparencia de pixel es diferente porque se almacena el valor
de transparencia de cada pixel. Esto permite crear efectos de transparencia
mas precisos, pero es algo mas lento. La transparencia de pixel no
se puede mezclar con los otros tipos de transparencia.
</p>



<p>
Existe soporte para acceder a los pixels de la superficie. El acceso
pixels en superficies de hardware es lento y no se recomienda. Estos
métodos son adecuados para acceso simple, pero serán considerablemente
lentos cuando realice mucho trabajo de pixels con ellos. Si planea
realizar mucho trabajo a nivel de pixels se recomienda usar el
módulo <code>pygame.surfarray</code> que puede tratar a las superficies como
vectores de varias dimensiones (y es bastante rápido).
</p>



<p>
Cualquier función que acceda directamente a los datos de pixels de
la superficie necesitarán que la superficie esté bloqueada. Estas
funciones pueden bloquear (<code>block()</code>) o desbloquear (<code>unlock()</code>)
las superficies por ellas mismas si ayuda, pero, si habrá una sobrecarga
muy grande de múltiples bloqueos o desbloqueos si se llama a esta
función muchas veces. Es mejor bloquear manualmente la superficie antes
de llamar a las funciones muchas veces, y luego desbloquear la superficie
cuando se halla finalizado. Todas las funciones que necesitan bloquear
la superficie lo indican en la documentación. Recuerde dejar la superficie
bloqueada solo mientras sea necesario.
</p>



<p>
Los pixels de la superficie se almacenan internamente como un número
individual que tiene todos los colores agrupados. Use las funciones
<code>Surface.map_rgb()</code> y <code>Surface.unmap_rgb()</code> para convertir entre
valores individuales (rojo, verde y azul) en colores agrupados para
la superficie.
</p>



<p>
Las superficies también pueden ser una referencia a una sección
de otra superficie. Se generan con el método <code>Surface.subsurface()</code>. Cualquier cambio en alguna de las dos superficie que verá reflejado
en ambas.
</p>



<p>
Cada superficie contiene un área de recorte. Por defecto el área
de recorte cubre la superficie entera. Si esta área de modifica, todas
las operaciones de dibujado solo afectarán un área mas pequeña.
</p>

</div>
<!-- SECTION "Surface" [1006-9319] -->
<h2><a name="blit" id="blit">blit</a></h2>
<div class="level2">



<p>
Dibuja una imagen sobre otra.
</p>
<pre class="code python">Surface.<span class="me1">blit</span><span class="br0">&#40;</span>source, dest, area=<span class="kw2">None</span>, special_flags = 0<span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Dibuja una superficie <code>source</code> sobre otra. La impresión se puede
posicionar usando el argumento <code>dest</code>. <code>dest</code> puede ser un
par de coordenadas representando la esquina superior izquierda o bien
un rectángulo, cuya esquina superior izquierda representará la posición
destino de impresión. El tamaño de rectángulo destino no afectará
la impresión.
</p>

<p>

 
Se puede pasar un rectángulo opcional como argumento <code>area</code>. Este
representa una porción mas pequeña de la superficie <code>source</code> a imprimir.
</p>



<p>
La opción <code>special_flags</code> puede tomar los siguientes valores:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MAX</div>
</li>
</ul>



<p>
Note, tal vez se agreguen mas opciones de impresión en el futuro.
</p>



<p>
El rectángulo retornado representa el área de los pixels afectados, excluyendo
cualquier pixel fuera de la superficie destino o el área de recorte.
</p>



<p>
Se ignorarán los pixels alpha cuand se imprima sobre una superficie de 8 bits.
</p>



<p>
La opción <code>special_flags</code> es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "blit" [9320-11870] -->
<h2><a name="convert" id="convert">convert</a></h2>
<div class="level2">



<p>
Cambia el formato de pixel de una imagen.
</p>
<pre class="code python">Surface.<span class="me1">convert</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span>depth, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span>masks, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Genera una nueva copia de la superficie con un formato de pixel
modificado. El nuevo formato de pixel se puede determinar a partir de otra
superficie existente. Otra posibilidad es especificar los argumentos <code>depth</code>, 
<code>flags</code> y <code>mask</code>, de manera similar a <code>pygame.Surface()</code>
</p>



<p>
La superficie nueva tendrá el mismo formato de pixel de la pantalla si
no envía ningún argumento. Este formato será el mas rápido de imprimir. Es
una buena idea convertir todas las superficies antes de imprimirlas
varias veces.
</p>



<p>

La superficie convertida podría no tener pixels alpha, dado que serán
eliminados si la superficie original los tenía. Vea la función
<code>Surface.convert_alpha()</code> para crear o preservar superficies con
canal alpha.
</p>

</div>
<!-- SECTION "convert" [11871-13556] -->
<h2><a name="convert_alpha" id="convert_alpha">convert_alpha</a></h2>
<div class="level2">


<pre class="code python">Surface.<span class="me1">convert_alpha</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert_alpha</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Genera una nueva copia de la superficie con el formato de pixel deseado. La
superficie nueva tendrá un formato adecuado para imprimirse mas rápidamente
el formato indicado con canal alpha. Si no se especifica el argumento
<code>surface</code>, la nueva superficie se optimizará para el formato de pantalla
actual.
</p>



<p>
A diferencia del método <code>Surface.convert()</code>, el formato de pixel para la
imagen nueva podría no ser exactamente el mismo que se pide, aunque se
optimizará para imprimirse sobre la superficie destino.
</p>

</div>
<!-- SECTION "convert_alpha" [13557-14753] -->
<h2><a name="copy" id="copy">copy</a></h2>
<div class="level2">



<p>
Genera una nueva copia de la superficie.
</p>
<pre class="code python">Surface.<span class="kw3">copy</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Hace una copia duplicada de un superficie. La superficie nueva tendrá
el mismo formato de pixel, paletas de colores y configuración
de transparencia que la original.
</p>

</div>
<!-- SECTION "copy" [14754-15229] -->
<h2><a name="fill" id="fill">fill</a></h2>
<div class="level2">



<p>
Pinta una superficie con un color solido.
</p>
<pre class="code python">Surface.<span class="me1">fill</span><span class="br0">&#40;</span>color, rect=<span class="kw2">None</span>, special_flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Pinta la superficie con un color solido. Se pintará la superficie entera
si no se especifica el argumento <code>rect</code>. El argumento <code>rect</code> limitará
la modificación al área especificada. La operación de pintado también
se limitará por el área de recorte de la superficie.
</p>



<p>
El argumento <code>color</code> puede ser una secuencia <code>RGB</code>, <code>RGBA</code> o un
índice de una paleta de colores. Si usa el formato <code>RGB</code> se ignorará
el componente alpha (una parte de <code>RGBA</code>) a menos que la superficie
use transparencia por pixel (atributo <code>SRCALPHA</code>).
</p>



<p>
A partir de pygame 1.8.0 puede usar las siguientes opciones adicionales:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_MAX</div>
</li>
</ul>



<p>
Y a partir de pygame 1.8.1 se suman:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_RGBA_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MAX</div>
</li>
</ul>





<p>
Esta función retornará el área afectada de la superficie.
</p>

</div>
<!-- SECTION "fill" [15230-17327] -->
<h2><a name="set_colorkey" id="set_colorkey">set_colorkey</a></h2>
<div class="level2">



<p>
Define el color clave de transparencia.
</p>
<pre class="code python">Surface.<span class="me1">set_colorkey</span><span class="br0">&#40;</span>Color, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_colorkey</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el color clave para la superficie. Cuando imprima esta superficie
sobre otra, cualquier pixel que tenga el mismo color que el color
clave no se imprimirá. El argumento <code>color</code> puede ser un color <code>RGB</code> o
un indice de una paleta de colores. Si se envía <code>None</code> como argumento
entonces se deshabilitará el color clave.
</p>



<p>
Se ignorará el color clave si la superficie tiene un formato para
usar valores alpha por pixel. La transparencia por color clave se
puede mezclar con la transparencia a nivel de superficie.
</p>



<p>
Se puede definir el argumento opcional <code>flags</code> a <code>pygame.RLEACCEL</code>
para obtener mejor rendimiento en pantallas que no tengan aceleración
de video. Una superficie <code>RLEACCEL</code> puede ser mas lenta de modificar, pero
se imprimirá mas rápido.
</p>

</div>
<!-- SECTION "set_colorkey" [17328-18950] -->
<h2><a name="get_colorkey" id="get_colorkey">get_colorkey</a></h2>
<div class="level2">



<p>
Obtiene el color clave de transparencia actual.
</p>
<pre class="code">
Surface.get_colorkey(): return RGB or None
</pre>



<p>
Retorna el color clave actual de la superficie. Si la superficie no tiene
color clave la función retornará <code>None</code>.
</p>

</div>
<!-- SECTION "get_colorkey" [18951-19358] -->
<h2><a name="set_alpha" id="set_alpha">set_alpha</a></h2>
<div class="level2">



<p>
Define el valor de transparencia para toda la superficie.
</p>
<pre class="code python">Surface.<span class="me1">set_alpha</span><span class="br0">&#40;</span>value, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_alpha</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de transparencia para la superficie. Cuando se imprima
esta superficie sobre otra los pixels se dibujarán ligeramente transparentes. El
valor de transparencia es un número entero de 0 a 255, 0 representa completamente
transparente y 255 completamente opaco. Se deshabilitará la transparencia
de la superficie si se pasa <code>None</code> como valor de transparencia.
</p>



<p>
Esta transparencia es diferente a la transparencia por pixel. Se ignorará
este valor de transparencia si la superficie contiene pixels con transparencia. Si
la superficie contiene transparencia por pixel, cuando llame a esta función
con el argumento <code>None</code> se deshabilitará esa transparencia por pixel.
</p>



<p>
El argumento adicional <code>flags</code> se puede definir como <code>pygame.RLEACCEL</code> para
obtener mayor rendimiento en pantallas que no tengan aceleración de video. Una
superficie <code>RLEACCEL</code> será mas lenta de modificar, aunque será mas rápido
imprimirla sobre otra.
</p>

</div>
<!-- SECTION "set_alpha" [19359-21344] -->
<h2><a name="get_alpha" id="get_alpha">get_alpha</a></h2>
<div class="level2">



<p>
Obtiene el valor de transparencia de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_alpha</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> int_value <span class="kw1">or</span> <span class="kw2">None</span></pre>


<p>
Retorna el valor de transparencia actual para la superficie. Se retornará
<code>None</code> si el valor de transparencia no está definido.
</p>

</div>
<!-- SECTION "get_alpha" [21345-21785] -->
<h2><a name="lock" id="lock">lock</a></h2>
<div class="level2">



<p>
Bloquea la memoria de la superficie para acceder a sus pixels.
</p>
<pre class="code python">Surface.<span class="me1">lock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Bloquea los datos de pixel de una superficie para acceder a ellos. En la
superficies aceleradas, los datos de pixels podrían estar almacenados
en memoria de video volátil o en formas no lineales bajo compresión. Cuando
se bloquea una superficie la información de pixels se convierte en un
formato accesible. El código que lee o escribe valores de pixels necesitará
que la superficie se bloquee para realizar esas tareas.
</p>



<p>
Las superficies no deberían permanecer bloqueadas mas de lo necesario. Una
superficie bloqueada podría no mostrarse o ser manipulada por pygame.
</p>



<p>
No todas las superficies necesitan bloquease. El método <code>Surface.mustlock()</code>
puede determinar si la superficie requiere bloquease. De todas formas, no
hay desventaja al bloquear o desbloquear una superficie que no lo necesita.
</p>



<p>
Todas las funciones de pygame bloquearán o desbloquearán automáticamente
los datos de la superficie si es necesario. Si una sección de código hace
varias llamas para modificar la superficie, entonces se bloqueará y
desbloqueará muchas veces la superficie. Por este motivo, es mucho
mas útil bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>



<p>
Es seguro anidar llamas para bloquear y desbloquear. La superficie solo se
desbloqueará después de soltar el último bloqueo.
</p>

</div>
<!-- SECTION "lock" [21786-24358] -->
<h2><a name="unlock" id="unlock">unlock</a></h2>
<div class="level2">



<p>
Desbloquea la memoria de la superficie del acceso a pixels.
</p>
<pre class="code python">Surface.<span class="me1">unlock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Desbloquea los datos de pixels de la superficie  luego de que ha
sido bloqueada. La superficie desbloqueada podrá imprimirse nuevamente
por pygame. Vea la documentación de <code>Surface.lock()</code> para mas detalles.
</p>



<p>
Todas las funciones de pygame bloquearán o desbloquearán automáticamente
los datos de la superficie si es necesario. Si una sección de código hace
varias llamas para modificar la superficie, entonces se bloqueará y
desbloqueará muchas veces la superficie. Por este motivo, es mucho
mas útil bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>



<p>
Es seguro anidar llamas para bloquear y desbloquear. La superficie solo se
desbloqueará después de soltar el último bloqueo.
</p>

</div>
<!-- SECTION "unlock" [24359-25862] -->
<h2><a name="mustlock" id="mustlock">mustlock</a></h2>
<div class="level2">



<p>
Verifica si la superficie necesita bloquearse.
</p>
<pre class="code python">Surface.<span class="me1">mustlock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">bool</span></pre>


<p>
Retorna <code>True</code> si la superficie se debe bloquear para acceder a sus
datos de pixel. Usualmente las superficies de software pura no necesitan
bloquease. Este método no se usa con frecuencia, dado que es seguro
y mas rápido directamente bloquear todas las superficies como sea
necesario.
</p>



<p>
Todas las funciones de pygame bloquearán o desbloquearán automáticamente
los datos de la superficie si es necesario. Si una sección de código hace
varias llamas para modificar la superficie, entonces se bloqueará y
desbloqueará muchas veces la superficie. Por este motivo, es mucho
mas útil bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>

</div>
<!-- SECTION "mustlock" [25863-27222] -->
<h2><a name="get_locked" id="get_locked">get_locked</a></h2>
<div class="level2">



<p>
Consulta si la superficie está bloqueada.
</p>
<pre class="code python">Surface.<span class="me1">get_locked</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">bool</span></pre>


<p>
Retorna <code>True</code> cuando la superficie está bloqueada. Esta función
no se fija o preocupa sobre cuantas veces se ha bloqueado la superficie.
</p>

</div>
<!-- SECTION "get_locked" [27223-27640] -->
<h2><a name="get_locks" id="get_locks">get_locks</a></h2>
<div class="level2">



<p>
Obtiene los bloqueos de la superficie.
</p>
<pre class="code">
Surface.get_locks(): return tuple
</pre>



<p>
Retorna los bloqueos existentes para la superficie.
</p>

</div>
<!-- SECTION "get_locks" [27641-27909] -->
<h2><a name="get_at" id="get_at">get_at</a></h2>
<div class="level2">



<p>
Obtiene el valor de color de un pixel
</p>
<pre class="code python">Surface.<span class="me1">get_at</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span> <span class="br0">&#41;</span>: <span class="kw1">return</span> Color</pre>


<p>
Retorna el valor de color RGBA en la posición indicada. Si la superficie
no tiene transparencia por pixel, entonces el valor alpha del color
será siempre 255 (completamente opaco). Se lanzará una excepción <code>IndexError</code>
si la posición del pixel está fuera del área de la superficie.
</p>



<p>
Obtener y definir los pixels de a uno a la vez es una tarea generalmente lenta
para ser utilizada en un juego o una situación de tiempo real.
</p>



<p>
Esta función bloqueará y desbloqueará la superficie temporalmente como sea
necesario.
</p>

</div>
<!-- SECTION "get_at" [27910-29036] -->
<h2><a name="set_at" id="set_at">set_at</a></h2>
<div class="level2">



<p>
Define el valor de color para un pixel.
</p>
<pre class="code python">Surface.<span class="me1">set_at</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span>, Color<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de color RGBA o entero (si utiliza paleta) de un
pixel. Si la superficie no tiene transparencia por pixel, entonces
el valor alpha se ignorará. No tendrá ningún efecto definir pixels
fuera del área total o el área de recorte de la superficie.
</p>



<p>

Obtener y definir los pixels de a uno a la vez es una tarea generalmente lenta
para ser utilizada en un juego o una situación de tiempo real.
</p>



<p>
Esta función bloqueará y desbloqueará la superficie temporalmente como sea
necesario.
</p>

</div>
<!-- SECTION "set_at" [29037-30142] -->
<h2><a name="get_palette" id="get_palette">get_palette</a></h2>
<div class="level2">



<p>
Obtiene la paleta de colores para una superficie de 8 bits.
</p>
<pre class="code python">Surface.<span class="me1">get_palette</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#91;</span>RGB, RGB, RGB, ...<span class="br0">&#93;</span></pre>


<p>
Retorna una lista de a lo máximo 256 elementos de color que representan
los colores utilizados en una superficie de 8bits. La lista que se retorna
es una copia de la paleta, y los cambios que se realicen en esta copia
no tendrán efecto sobre la superficie.
</p>

</div>
<!-- SECTION "get_palette" [30143-30820] -->
<h2><a name="get_palette_at" id="get_palette_at">get_palette_at</a></h2>
<div class="level2">



<p>
Obtiene el color de una entrada de la paleta de colores.
</p>
<pre class="code python">Surface.<span class="me1">get_palette_at</span><span class="br0">&#40;</span>index<span class="br0">&#41;</span>: <span class="kw1">return</span> RGB</pre>


<p>
Retorna los valores rojo, verde y azul de un elemento de la paleta de colores
de la superficie. El argumento <code>index</code> debería ser un valor entre 0 y 255.
</p>

</div>
<!-- SECTION "get_palette_at" [30821-31321] -->
<h2><a name="set_palette" id="set_palette">set_palette</a></h2>
<div class="level2">



<p>
Define la paleta de colores para una superficie de 8 bits.
</p>
<pre class="code python">Surface.<span class="me1">set_palette</span><span class="br0">&#40;</span><span class="br0">&#91;</span>RGB, RGB, RGB, ...<span class="br0">&#93;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define la paleta completa para una superficie de 8 bits. Esta función
reemplazará los colores de la paleta existente. Se puede enviar una
paleta parcial, de modo que solo se reemplazarán los primeros elementos
de la misma.
</p>



<p>
Esta función no hace nada sobre una superficie con mas de 8 bits por
pixel.
</p>

</div>
<!-- SECTION "set_palette" [31322-32125] -->
<h2><a name="set_palette_at" id="set_palette_at">set_palette_at</a></h2>
<div class="level2">



<p>
Define el color para un solo elemento en una paleta de colores.
</p>
<pre class="code python">Surface.<span class="me1">set_at</span><span class="br0">&#40;</span>index, RGB<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de un color en la paleta de una superficie. El valor del
argumento <code>index</code> debería estar ente 0 y 255.
</p>



<p>
Esta función no hace nada sobre una superficie con mas de 8 bits por
pixel.
</p>

</div>
<!-- SECTION "set_palette_at" [32126-32744] -->
<h2><a name="map_rgb" id="map_rgb">map_rgb</a></h2>
<div class="level2">



<p>
Convierte un color en un formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">map_rgb</span><span class="br0">&#40;</span>Color<span class="br0">&#41;</span>: <span class="kw1">return</span> mapped_int</pre>


<p>
Convierte un color RGBA en un número entero empaquetado para esta superficie. El
número entero retornado no contendrá mas bits que la profundidad de color
de la superficie. Estos valores empaquetados no se usan con frecuencia dentro
de pygame, aunque se pueden pasar como argumento a varias funciones que
soliciten una superficie y un color.
</p>



<p>
Vea la documentación del objeto <code>Surface</code> para obtener mas información
acerca de los colores y los formatos de pixel.
</p>

</div>
<!-- SECTION "map_rgb" [32745-33782] -->
<h2><a name="unmap_rgb" id="unmap_rgb">unmap_rgb</a></h2>
<div class="level2">



<p>
Convierte el valor de un entero empaquetado en un color.
</p>
<pre class="code python">Surface.<span class="me1">map_rgb</span><span class="br0">&#40;</span>mapped_int<span class="br0">&#41;</span>: <span class="kw1">return</span> Color</pre>


<p>
Convierte un color de formato empaquetado en un conjunto de componentes de
color RGB para esta superficie. Estos valores empaquetados no se usan con
frecuencia dentro de pygame, aunque se pueden pasar como argumento a varias
funciones que soliciten una superficie y un color.
</p>



<p>

Vea la documentación del objeto <code>Surface</code> para obtener mas información
acerca de los colores y los formatos de pixel.
</p>

</div>
<!-- SECTION "unmap_rgb" [33783-34699] -->
<h2><a name="set_clip" id="set_clip">set_clip</a></h2>
<div class="level2">



<p>
Define el área de recorte para la superficie.
</p>
<pre class="code python">Surface.<span class="me1">set_clip</span><span class="br0">&#40;</span>rect<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_clip</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Cada superficie tiene una área de recorte activa. Este recorte es un
rectángulo que representa a los pixels que se pueden modificar en una
superficie. Toda la superficie se podrá modificar si se pasa <code>None</code> como
área de recorte.
</p>



<p>

El área de recorte está siempre limitada al área de la superficie en sí misma. Si
el rectángulo de recorte es mas grande, entonces se encogerá para caber dentro
de la superficie.
</p>

</div>
<!-- SECTION "set_clip" [34700-35723] -->
<h2><a name="get_clip" id="get_clip">get_clip</a></h2>
<div class="level2">



<p>
Obtiene el área de recorte actual de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_clip</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Retorna una rectángulo que representa el área de recorte. La superficie
siempre retornará un rectángulo válido que nunca estará por afuera de
los bordes de la superficie. La superficie retornará el área completa de
la misma si no se ha definido un área de recorte.
</p>

</div>
<!-- SECTION "get_clip" [35724-36467] -->
<h2><a name="subsurface" id="subsurface">subsurface</a></h2>
<div class="level2">



<p>
Genera una nueva superficie que hace referencia a su pariente.
</p>
<pre class="code python">Surface.<span class="me1">subsurface</span><span class="br0">&#40;</span>Rect<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna una nueva superficie que comparte sus pixels con su superficie
pariente. La nueva superficie se considera hija de la original. Las modificaciones
a los pixels de cualquier de las dos superficies afectará a la otra. La
información de la superficie como el área de recorte o los colores clave son
únicos para cada superficie.
</p>



<p>
La nueva superficie heredará la paleta, colores clave y configuración
de transparencia de su padre.
</p>



<p>
Es posible tener cualquier número de <em>sub-superficies</em> y <em>sub-sub-superficies</em>
de una superficie. También es posible tener una <em>sub-superficie</em> de la
pantalla principal si el modo de video no está acelerado por software.
</p>



<p>
Vea las funciones <em>Surface.get_offset()</em> y <em>Subsurfaces.get_parent()</em>
para aprender mas acerca del estado de una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "subsurface" [36468-38154] -->
<h2><a name="get_parent" id="get_parent">get_parent</a></h2>
<div class="level2">



<p>
Encuentra el padre de una <em>sub-superficie</em>.
</p>
<pre class="code python">Surface.<span class="me1">get_parent</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna el padre de una <em>sub-superficie</em>. Si el receptor no es una
<em>sub-superficie</em> entonces se retornará None.
</p>

</div>
<!-- SECTION "get_parent" [38155-38551] -->
<h2><a name="get_abs_parent" id="get_abs_parent">get_abs_parent</a></h2>
<div class="level2">



<p>
Obtiene el padre de mayor nivel de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_abs_parent</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna el padre de una <em>sub-superficie</em>. Se retornará <code>None</code> si
el receptor no es una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_abs_parent" [38552-38974] -->
<h2><a name="get_offset" id="get_offset">get_offset</a></h2>
<div class="level2">



<p>
Encuentra la posición la superficie hija dentro del la superficie padre.
</p>
<pre class="code python">Surface.<span class="me1">get_offset</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span></pre>


<p>
Obtiene la posición de desplazamiento de una <em>sub-superficie</em> dentro
de la superficie padre. Retornará (0, 0) si la superficie no es una
<em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_offset" [38975-39492] -->
<h2><a name="get_abs_offset" id="get_abs_offset">get_abs_offset</a></h2>
<div class="level2">



<p>
Obtiene la posición absoluta de una superficie hija en relación a su
padre de mayor nivel.
</p>
<pre class="code python">Surface.<span class="me1">get_abs_offset</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span></pre>


<p>
Obtiene la posición desplazamiento de una superficie hija en relación
a superficie padre de nivel superior. Retornará (0, 0) si la superficie
no es una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_abs_offset" [39493-40092] -->
<h2><a name="get_size" id="get_size">get_size</a></h2>
<div class="level2">



<p>
Obtiene las dimensiones de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_size</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span></pre>


<p>
Retorna el ancho y alto de una superficie medida en pixels.
</p>

</div>
<!-- SECTION "get_size" [40093-40390] -->
<h2><a name="get_width" id="get_width">get_width</a></h2>
<div class="level2">



<p>
Obtiene el ancho de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_width</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> width</pre>


<p>
Retorna el ancho de una superficie medida en pixels.
</p>

</div>
<!-- SECTION "get_width" [40391-40651] -->
<h2><a name="get_height" id="get_height">get_height</a></h2>
<div class="level2">



<p>
Obtiene la altura de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_height</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> height</pre>


<p>
Retorna la altura de una superficies medida en pixels.
</p>

</div>
<!-- SECTION "get_height" [40652-40920] -->
<h2><a name="get_rect" id="get_rect">get_rect</a></h2>
<div class="level2">



<p>
Obtiene el área rectangular de una superficie.
</p>
<pre class="code">
Surface.get_rect(*\*kwargs): return Rect
</pre>



<p>
Retorna un nuevo rectángulo que cubre la superficie entera. Este
rectángulo siempre comenzará en la posición (0, 0) y tendrá el
ancho y alto idéntico al tamaño de la imagen.
</p>



<p>
Puede pasar valores clave como argumentos a esta función. Estos
argumentos se aplicarán a los atributos del rectángulo antes de
ser retornado. Un ejemplo podría ser <code>mysurf.get_rect(center=(100,100))</code>
para crear un rectángulo de la superficie con centro en la posición
(100, 100).
</p>

</div>
<!-- SECTION "get_rect" [40921-41998] -->
<h2><a name="get_bitsize" id="get_bitsize">get_bitsize</a></h2>
<div class="level2">



<p>
Obtiene la profundidad de colores en bits del formato de pixel de la superficie.
</p>
<pre class="code">
Surface.get_bitsize(): return int
</pre>



<p>
Retorna el número de bits utilizados para representar cada pixel. Este valor
podría no coincidir exactamente con el número de bytes usados por pixel. Por
ejemplo, una superficie de 15 bits requiere 2 bytes completos.
</p>

</div>
<!-- SECTION "get_bitsize" [41999-42623] -->
<h2><a name="get_bytesize" id="get_bytesize">get_bytesize</a></h2>
<div class="level2">



<p>
Obtiene el número de bytes utilizados por pixel de la superficie.
</p>
<pre class="code">
Surface.get_bytesize(): return int
</pre>



<p>
Retorna el número de bytes utilizados por pixel.
</p>

</div>
<!-- SECTION "get_bytesize" [42624-42917] -->
<h2><a name="get_flags" id="get_flags">get_flags</a></h2>
<div class="level2">



<p>
Obtiene las opciones adicionales utilizadas por la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_flags</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">int</span></pre>


<p>
Retorna el conjunto de propiedades de la superficie. Cada propiedad es
un bit en la máscara de bits <code>flags</code>. Las propiedades habituales son
<code>HWSURFACE</code>, <code>RLEACCEL</code>, <code>SRCALPHA</code> y <code>SRCCOLORKEY</code>.
</p>



<p>
Esta es una lista mas completa de propiedades. La lista completa de estas
propiedades se puede encontrar en el archivo <a href="../../../../_media/traducciones/pygame/sdl_video.h.html" class="media mediafile mf_ wikilink2" title="traducciones:pygame:sdl_video.h">sdl_video.h</a>.
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> Máscara de bits </th><th class="col2"> Descripción </th>
	</tr>
	<tr class="row1">
		<td class="col0"> SWSURFACE </td><td class="col1"> 0&times;00000000 </td><td class="col2"> La superficie está en la memoria de sistema </td>
	</tr>
	<tr class="row2">
		<td class="col0"> HWSURFACE </td><td class="col1"> 0&times;00000001 </td><td class="col2"> La superficie está en la memoria de video </td>
	</tr>
	<tr class="row3">
		<td class="col0"> ASYNCBLIT </td><td class="col1"> 0&times;00000004 </td><td class="col2"> Usa impresión asíncrona cuando sea posible </td>
	</tr>
</table>



<p>
y algunas disponibles para la función <code>pygame.display.set_mode()</code>:
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> Máscara de bits </th><th class="col2"> Descripción </th>
	</tr>
	<tr class="row1">
		<td class="col0"> ANYFORMAT </td><td class="col1"> 0&times;10000000 </td><td class="col2"> Permite cualquier formato de pixel o color </td>
	</tr>
	<tr class="row2">
		<td class="col0"> HWPALETTE </td><td class="col1"> 0&times;20000000 </td><td class="col2"> La superficie tiene una paleta exclusiva </td>
	</tr>
	<tr class="row3">
		<td class="col0"> DOUBLEBUF </td><td class="col1"> 0&times;40000000 </td><td class="col2"> Define un modo de video con Double Buffer </td>
	</tr>
	<tr class="row4">
		<td class="col0"> FULLSCREEN </td><td class="col1"> 0&times;80000000 </td><td class="col2"> La superficie opera en modo pantalla completa </td>
	</tr>
	<tr class="row5">
		<td class="col0"> OPENGL </td><td class="col1"> 0&times;00000002 </td><td class="col2"> Genera un contexto de impresión para OpenGL </td>
	</tr>
	<tr class="row6">
		<td class="col0"> OPENGLBLIT </td><td class="col1"> 0x0000000A </td><td class="col2"> Genera un contexto de impresión 2D para Opengl (en desuso) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> RESIZABLE </td><td class="col1"> 0&times;00000010 </td><td class="col2"> El modo de video se puede redimensionar </td>
	</tr>
	<tr class="row8">
		<td class="col0"> NOFRAME </td><td class="col1"> 0&times;00000020 </td><td class="col2"> No usar borde o título para esta ventana </td>
	</tr>
</table>



<p>
otras utilizadas internamente (de solo lectura)
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> Máscara de bits </th><th class="col2"> Descripción </th>
	</tr>
	<tr class="row1">
		<td class="col0"> HWACCEL </td><td class="col1"> 0&times;00000100 </td><td class="col2"> La operación de impresión usa aceleración por hardware </td>
	</tr>
	<tr class="row2">
		<td class="col0"> SRCCOLORKEY </td><td class="col1"> 0&times;00001000 </td><td class="col2"> La operación de impresión usa un color clave para simular transparencia </td>
	</tr>
	<tr class="row3">
		<td class="col0"> RLEACCELOK </td><td class="col1"> 0&times;00002000 </td><td class="col2"> Atributo privado </td>
	</tr>
	<tr class="row4">
		<td class="col0"> RLEACCEL </td><td class="col1 leftalign"> 0&times;00004000	</td><td class="col2"> La superficie está empaquetada con el formato RLE </td>
	</tr>
	<tr class="row5">
		<td class="col0"> SRCALPHA </td><td class="col1 leftalign"> 0&times;00010000	</td><td class="col2"> La operación de impresión utiliza la transparencia original </td>
	</tr>
	<tr class="row6">
		<td class="col0"> PREALLOC </td><td class="col1 leftalign"> 0&times;01000000	</td><td class="col2"> La superficie utiliza memoria pre-solicitada </td>
	</tr>
</table>

</div>
<!-- SECTION "get_flags" [42918-46493] -->
<h2><a name="get_pitch" id="get_pitch">get_pitch</a></h2>
<div class="level2">



<p>
Obtiene el número de bytes utilizados por cada fila de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_pitch</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">int</span></pre>


<p>
Retorna el número de bytes que separan a cada fila de pixels en una superficie. Las
superficies en memoria de video no siempre se almacenan en forma lineal. Las <em>sub-superficies</em>
también podrían tener un <code>pitch</code> mas grande que su verdadera longitud.
</p>



<p>
Este valor no es necesario para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_pitch" [46494-47264] -->
<h2><a name="get_masks" id="get_masks">get_masks</a></h2>
<div class="level2">



<p>
Obtiene la máscara de bits necesaria para convertir entre un color
RGB y un color empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_masks</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna la máscara de bits que se utiliza para empaquetar cada
color en un número entero.
</p>



<p>
Este valor no se necesita para el uso normal de pygame.
</p>

</div>
<!-- SECTION "get_masks" [47265-47811] -->
<h2><a name="set_masks" id="set_masks">set_masks</a></h2>
<div class="level2">



<p>
Define la máscara de bits necesaria para convertir entre un color
RGB en un color en formato empaquetado.
</p>
<pre class="code">
Surface.set_masks( (r,g,b,a) ): return None
</pre>



<p>
Esta función no se necesita para el uso habitual de pygame.
</p>



<p>
Es una función nueva a partir de pygame 1.8.1.
</p>

</div>
<!-- SECTION "set_masks" [47812-48276] -->
<h2><a name="get_shifts" id="get_shifts">get_shifts</a></h2>
<div class="level2">



<p>
Obtiene los bits de intercambios necesarios para convertir un
color RGB en un color en formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_shifts</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna los bits de intercambio de pixel necesarios para convertir
el formato de cada color.
</p>



<p>
Este valor no se necesita para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_shifts" [48277-48854] -->
<h2><a name="set_shifts" id="set_shifts">set_shifts</a></h2>
<div class="level2">



<p>
Define los bits de intercambios necesarios para convertir un
color RGB en un color en formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_shifts</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>r,g,b,a<span class="br0">&#41;</span> <span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Esta función no se necesita para el uso habitual de pygame.
</p>



<p>
Esta función es nueva a partir de pygame 1.8.1.
</p>

</div>
<!-- SECTION "set_shifts" [48855-49328] -->
<h2><a name="get_losses" id="get_losses">get_losses</a></h2>
<div class="level2">



<p>
Obtiene los bits significativos que se usan para convertir el
formato de color.
</p>
<pre class="code python">Surface.<span class="me1">get_losses</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna el número menos significativo de bits agrupados por
cada color en un número entero empaquetado.
</p>



<p>

Este valor no se necesita para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_losses" [49329-49904] -->
<h2><a name="get_bounding_rect" id="get_bounding_rect">get_bounding_rect</a></h2>
<div class="level2">



<p>
Obtiene el rectángulo mas pequeño que contiene información.
</p>
<pre class="code python">Surface.<span class="me1">get_bounding_rect</span><span class="br0">&#40;</span>min_alpha = <span class="nu0">1</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Retorna la región rectangular mas pequeña que contiene todos los
pixels en una superficie que tienen un atributo de transparencia
mas grande o igual que le indicado por argumento.
</p>



<p>
Esta función bloqueará y desbloqueará temporalmente la superficie.
</p>



<p>
Esta función es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "get_bounding_rect" [49905-50689] -->
<h2><a name="get_buffer" id="get_buffer">get_buffer</a></h2>
<div class="level2">



<p>
Obtiene un objeto buffer para los pixels de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_buffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> BufferProxy</pre>


<p>
Retorna un objeto buffer para los pixels de la superficie. El buffer
se puede usar para acceder y manipular directamente los pixels.
</p>



<p>
Este método bloquea y desbloquea la superficie de forma implícita. El
bloqueo a la superficie se anulará una vez que el objeto <code>BufferProxy</code>
sea eliminado.
</p>



<p>
Esta función es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "get_buffer" [50690-] --></div>
</body>
</html>
