<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="es"
 lang="es" dir="ltr">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>traducciones:pygame:surface</title>
<meta name="generator" content="DokuWiki Release 2009-02-14b" />
<meta name="robots" content="index,follow" />
<meta name="date" content="2009-01-26T00:36:34+0300" />
<meta name="keywords" content="traducciones,pygame,surface" />
<link rel="search" type="application/opensearchdescription+xml" href="../../../../lib/exe/opensearch.php" title="Losersjuegos" />
<link rel="start" href="../../../../index.html" />
<link rel="contents" href="../../../../traducciones/pygame/surface-do=index.html" title="Indice" />
<link rel="alternate" type="application/rss+xml" title="Recent Changes" href="../../../../feed.php.rss" />
<link rel="alternate" type="application/rss+xml" title="Current Namespace" href="../../../../feed.php-mode=list&amp;ns=traducciones-pygame.rss" />
<link rel="alternate" type="text/html" title="Plain HTML" href="surface.html" />
<link rel="alternate" type="text/plain" title="Wiki Markup" href="../../../raw/traducciones/pygame/surface.txt" />
<link rel="stylesheet" media="all" type="text/css" href="../../../../lib/exe/css.php-s=all&amp;t=sidebar.css" />
<link rel="stylesheet" media="screen" type="text/css" href="../../../../lib/exe/css.php-t=sidebar.css" />
<link rel="stylesheet" media="print" type="text/css" href="../../../../lib/exe/css.php-s=print&amp;t=sidebar.css" />
<script type="text/javascript" charset="utf-8" src="../../../../lib/exe/js.php-edit=0&amp;write=0.js" ></script>
</head>
<body>
<div class="dokuwiki export">
<!-- TOC START -->
<div class="toc">
<div class="tocheader toctoggle" id="toc__header">Tabla de Contenidos</div>
<div id="toc__inside">

<ul class="toc">
<li class="level1"><div class="li"><span class="li"><a href="#surface" class="toc">Surface</a></span></div>
<ul class="toc">
<li class="level2"><div class="li"><span class="li"><a href="#surface1" class="toc">Surface</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#blit" class="toc">blit</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#convert" class="toc">convert</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#convert_alpha" class="toc">convert_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#copy" class="toc">copy</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#fill" class="toc">fill</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_colorkey" class="toc">set_colorkey</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_colorkey" class="toc">get_colorkey</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_alpha" class="toc">set_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_alpha" class="toc">get_alpha</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#lock" class="toc">lock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#unlock" class="toc">unlock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#mustlock" class="toc">mustlock</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_locked" class="toc">get_locked</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_locks" class="toc">get_locks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_at" class="toc">get_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_at" class="toc">set_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_palette" class="toc">get_palette</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_palette_at" class="toc">get_palette_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_palette" class="toc">set_palette</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_palette_at" class="toc">set_palette_at</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#map_rgb" class="toc">map_rgb</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#unmap_rgb" class="toc">unmap_rgb</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_clip" class="toc">set_clip</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_clip" class="toc">get_clip</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#subsurface" class="toc">subsurface</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_parent" class="toc">get_parent</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_abs_parent" class="toc">get_abs_parent</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_offset" class="toc">get_offset</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_abs_offset" class="toc">get_abs_offset</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_size" class="toc">get_size</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_width" class="toc">get_width</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_height" class="toc">get_height</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_rect" class="toc">get_rect</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bitsize" class="toc">get_bitsize</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bytesize" class="toc">get_bytesize</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_flags" class="toc">get_flags</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_pitch" class="toc">get_pitch</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_masks" class="toc">get_masks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_masks" class="toc">set_masks</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_shifts" class="toc">get_shifts</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#set_shifts" class="toc">set_shifts</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_losses" class="toc">get_losses</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_bounding_rect" class="toc">get_bounding_rect</a></span></div></li>
<li class="level2"><div class="li"><span class="li"><a href="#get_buffer" class="toc">get_buffer</a></span></div></li></ul>
</li></ul>
</div>
</div>
<!-- TOC END -->



<h1><a name="surface" id="surface">Surface</a></h1>
<div class="level1">



<p>
Objeto de pygame para representar im√°genes.
</p>
<div class='box' style='width: 90%;'>
  <b class='xtop'><b class='xb1'></b><b class='xb2'></b><b class='xb3'></b><b class='xb4'></b></b>
  <div class='xbox'>
<div class='box_content'><p><ul>
<li class="level1"><div class="li"> <a href="#surface" title="traducciones:pygame:surface &crarr;" class="wikilink1">Surface</a></div>
</li>
<li class="level1"><div class="li"> <a href="#blit" title="traducciones:pygame:surface &crarr;" class="wikilink1">blit</a></div>
</li>
<li class="level1"><div class="li"> <a href="#convert" title="traducciones:pygame:surface &crarr;" class="wikilink1">convert</a></div>
</li>
<li class="level1"><div class="li"> <a href="#convert_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">convert_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#copy" title="traducciones:pygame:surface &crarr;" class="wikilink1">copy</a></div>
</li>
<li class="level1"><div class="li"> <a href="#fill" title="traducciones:pygame:surface &crarr;" class="wikilink1">fill</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_colorkey" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_colorkey</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_colorkey" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_colorkey</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_alpha" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_alpha</a></div>
</li>
<li class="level1"><div class="li"> <a href="#lock" title="traducciones:pygame:surface &crarr;" class="wikilink1">lock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#unlock" title="traducciones:pygame:surface &crarr;" class="wikilink1">unlock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#mustlock" title="traducciones:pygame:surface &crarr;" class="wikilink1">mustlock</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_locked" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_locked</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_locks" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_locks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_palette" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_palette</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_palette_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_palette_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_palette" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_palette</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_palette_at" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_palette_at</a></div>
</li>
<li class="level1"><div class="li"> <a href="#map_rgb" title="traducciones:pygame:surface &crarr;" class="wikilink1">map_rgb</a></div>
</li>
<li class="level1"><div class="li"> <a href="#unmap_rgb" title="traducciones:pygame:surface &crarr;" class="wikilink1">unmap_rgb</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_clip" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_clip</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_clip" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_clip</a></div>
</li>
<li class="level1"><div class="li"> <a href="#subsurface" title="traducciones:pygame:surface &crarr;" class="wikilink1">subsurface</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_parent" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_parent</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_abs_parent" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_abs_parent</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_offset" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_offset</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_abs_offset" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_abs_offset</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_size" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_size</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_width" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_width</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_height" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_height</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_rect" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_rect</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bitsize" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bitsize</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bytesize" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bytesize</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_flags" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_flags</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_pitch" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_pitch</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_masks" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_masks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_masks" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_masks</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_shifts" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_shifts</a></div>
</li>
<li class="level1"><div class="li"> <a href="#set_shifts" title="traducciones:pygame:surface &crarr;" class="wikilink1">set_shifts</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_losses" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_losses</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_bounding_rect" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_bounding_rect</a></div>
</li>
<li class="level1"><div class="li"> <a href="#get_buffer" title="traducciones:pygame:surface &crarr;" class="wikilink1">get_buffer</a></div>
</li>
</ul>
</div>
  </div>
  <b class='xbottom'><b class='xb4'></b><b class='xb3'></b><b class='xb2'></b><b class='xb1'></b></b>
</div>

</div>
<!-- SECTION "Surface" [1-1005] -->
<h2><a name="surface1" id="surface1">Surface</a></h2>
<div class="level2">
<pre class="code python">pygame.<span class="me1">Surface</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span>, flags=0, depth=0, masks=<span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
pygame.<span class="me1">Surface</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span>, flags=0, Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Un objeto Surface de pygame se utiliza para representar cualquier imagen.
La superficie tiene un formato de pixel y resoluci√≥n fija. Las superficies
con pixeles de 8 bits usan una paleta de 256 colores.
</p>



<p>
Invoque <code>pygame.Surface()</code> para crear un nuevo objeto image. La superficie
ser√° completamente negra. El √∫nico argumento requerido es el tama√±o. La
superficie se crear√° con el formato que mejor coincida con la pantalla
actual si no se especifican los argumentos adicionales.
</p>



<p>
El formato de pixel se puede controlar especificando la profundidad
de colores o una superficie existente. El argumento <code>flags</code> es una
combinaci√≥n de caracter√≠sticas adiciones para la superficie. Puede
utilizar cualquier combinaci√≥n de estas:
</p>


<ul>
<li class="level1"><div class="li"> HWSURFACE: Genera la imagen en la memoria de video.</div>
</li>
<li class="level1"><div class="li"> SRCALPHA: El formato de pixel incluir√° transparencias por pixel.</div>
</li>
</ul>



<p>
Ambas opciones son solo una solicitud, tal vez no sea posible para
todos los modos de video.
</p>



<p>
Los usuarios avanzados pueden combinar un conjunto de opciones con
un valor <code>depth</code>. El argumento <code>masks</code> es un conjunto de 4 n√∫meros
enteros que especifica cuales bits representan a cada color en el
pixel. Las superficies normales no requieren el argumento <code>mask</code>.
</p>



<p>
Las superficies pueden tener varios atributos adicionales como planos
alpha, colores clave o recortes. Estas funciones afectan principalmente
a la forma en que se imprime la superficie sobre otra. Las rutinas <code>blit</code>
intentar√°n usar aceleraci√≥n de hardware cuando sea posible, en caso contrario
usar√°n m√©todos de impresi√≥n por software muy optimizados.
</p>



<p>

Existen tres tipos de transparencia en pygame: colores clave,
transparencia de superficie, y transparencia de pixel. La transparencia
de superficie se puede combinar con colores clave, pero las im√°genes con
transparencia de pixel no puede usar los otros modos. La transparencia
por color clave hace transparente un solo color. No se imprimir√°n
los pixeles que coincidan con el color clave. La transparencia
de superficie es un valor individual que cambia la transparencia de la
imagen completa. Una transparencia de superficie de 255 ser√° opaca mientras
que un valor de 0 ser√° completamente transparente.
</p>



<p>
La transparencia de pixel es diferente porque se almacena el valor
de transparencia de cada pixel. Esto permite crear efectos de transparencia
mas precisos, pero es algo mas lento. La transparencia de pixel no
se puede mezclar con los otros tipos de transparencia.
</p>



<p>
Existe soporte para acceder a los pixels de la superficie. El acceso
pixels en superficies de hardware es lento y no se recomienda. Estos
m√©todos son adecuados para acceso simple, pero ser√°n considerablemente
lentos cuando realice mucho trabajo de pixels con ellos. Si planea
realizar mucho trabajo a nivel de pixels se recomienda usar el
m√≥dulo <code>pygame.surfarray</code> que puede tratar a las superficies como
vectores de varias dimensiones (y es bastante r√°pido).
</p>



<p>
Cualquier funci√≥n que acceda directamente a los datos de pixels de
la superficie necesitar√°n que la superficie est√© bloqueada. Estas
funciones pueden bloquear (<code>block()</code>) o desbloquear (<code>unlock()</code>)
las superficies por ellas mismas si ayuda, pero, si habr√° una sobrecarga
muy grande de m√∫ltiples bloqueos o desbloqueos si se llama a esta
funci√≥n muchas veces. Es mejor bloquear manualmente la superficie antes
de llamar a las funciones muchas veces, y luego desbloquear la superficie
cuando se halla finalizado. Todas las funciones que necesitan bloquear
la superficie lo indican en la documentaci√≥n. Recuerde dejar la superficie
bloqueada solo mientras sea necesario.
</p>



<p>
Los pixels de la superficie se almacenan internamente como un n√∫mero
individual que tiene todos los colores agrupados. Use las funciones
<code>Surface.map_rgb()</code> y <code>Surface.unmap_rgb()</code> para convertir entre
valores individuales (rojo, verde y azul) en colores agrupados para
la superficie.
</p>



<p>
Las superficies tambi√©n pueden ser una referencia a una secci√≥n
de otra superficie. Se generan con el m√©todo <code>Surface.subsurface()</code>. Cualquier cambio en alguna de las dos superficie que ver√° reflejado
en ambas.
</p>



<p>
Cada superficie contiene un √°rea de recorte. Por defecto el √°rea
de recorte cubre la superficie entera. Si esta √°rea de modifica, todas
las operaciones de dibujado solo afectar√°n un √°rea mas peque√±a.
</p>

</div>
<!-- SECTION "Surface" [1006-9319] -->
<h2><a name="blit" id="blit">blit</a></h2>
<div class="level2">



<p>
Dibuja una imagen sobre otra.
</p>
<pre class="code python">Surface.<span class="me1">blit</span><span class="br0">&#40;</span>source, dest, area=<span class="kw2">None</span>, special_flags = 0<span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Dibuja una superficie <code>source</code> sobre otra. La impresi√≥n se puede
posicionar usando el argumento <code>dest</code>. <code>dest</code> puede ser un
par de coordenadas representando la esquina superior izquierda o bien
un rect√°ngulo, cuya esquina superior izquierda representar√° la posici√≥n
destino de impresi√≥n. El tama√±o de rect√°ngulo destino no afectar√°
la impresi√≥n.
</p>

<p>

 
Se puede pasar un rect√°ngulo opcional como argumento <code>area</code>. Este
representa una porci√≥n mas peque√±a de la superficie <code>source</code> a imprimir.
</p>



<p>
La opci√≥n <code>special_flags</code> puede tomar los siguientes valores:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MAX</div>
</li>
</ul>



<p>
Note, tal vez se agreguen mas opciones de impresi√≥n en el futuro.
</p>



<p>
El rect√°ngulo retornado representa el √°rea de los pixels afectados, excluyendo
cualquier pixel fuera de la superficie destino o el √°rea de recorte.
</p>



<p>
Se ignorar√°n los pixels alpha cuand se imprima sobre una superficie de 8 bits.
</p>



<p>
La opci√≥n <code>special_flags</code> es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "blit" [9320-11870] -->
<h2><a name="convert" id="convert">convert</a></h2>
<div class="level2">



<p>
Cambia el formato de pixel de una imagen.
</p>
<pre class="code python">Surface.<span class="me1">convert</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span>depth, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span>masks, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Genera una nueva copia de la superficie con un formato de pixel
modificado. El nuevo formato de pixel se puede determinar a partir de otra
superficie existente. Otra posibilidad es especificar los argumentos <code>depth</code>, 
<code>flags</code> y <code>mask</code>, de manera similar a <code>pygame.Surface()</code>
</p>



<p>
La superficie nueva tendr√° el mismo formato de pixel de la pantalla si
no env√≠a ning√∫n argumento. Este formato ser√° el mas r√°pido de imprimir. Es
una buena idea convertir todas las superficies antes de imprimirlas
varias veces.
</p>



<p>

La superficie convertida podr√≠a no tener pixels alpha, dado que ser√°n
eliminados si la superficie original los ten√≠a. Vea la funci√≥n
<code>Surface.convert_alpha()</code> para crear o preservar superficies con
canal alpha.
</p>

</div>
<!-- SECTION "convert" [11871-13556] -->
<h2><a name="convert_alpha" id="convert_alpha">convert_alpha</a></h2>
<div class="level2">


<pre class="code python">Surface.<span class="me1">convert_alpha</span><span class="br0">&#40;</span>Surface<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface
Surface.<span class="me1">convert_alpha</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Genera una nueva copia de la superficie con el formato de pixel deseado. La
superficie nueva tendr√° un formato adecuado para imprimirse mas r√°pidamente
el formato indicado con canal alpha. Si no se especifica el argumento
<code>surface</code>, la nueva superficie se optimizar√° para el formato de pantalla
actual.
</p>



<p>
A diferencia del m√©todo <code>Surface.convert()</code>, el formato de pixel para la
imagen nueva podr√≠a no ser exactamente el mismo que se pide, aunque se
optimizar√° para imprimirse sobre la superficie destino.
</p>

</div>
<!-- SECTION "convert_alpha" [13557-14753] -->
<h2><a name="copy" id="copy">copy</a></h2>
<div class="level2">



<p>
Genera una nueva copia de la superficie.
</p>
<pre class="code python">Surface.<span class="kw3">copy</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Hace una copia duplicada de un superficie. La superficie nueva tendr√°
el mismo formato de pixel, paletas de colores y configuraci√≥n
de transparencia que la original.
</p>

</div>
<!-- SECTION "copy" [14754-15229] -->
<h2><a name="fill" id="fill">fill</a></h2>
<div class="level2">



<p>
Pinta una superficie con un color solido.
</p>
<pre class="code python">Surface.<span class="me1">fill</span><span class="br0">&#40;</span>color, rect=<span class="kw2">None</span>, special_flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Pinta la superficie con un color solido. Se pintar√° la superficie entera
si no se especifica el argumento <code>rect</code>. El argumento <code>rect</code> limitar√°
la modificaci√≥n al √°rea especificada. La operaci√≥n de pintado tambi√©n
se limitar√° por el √°rea de recorte de la superficie.
</p>



<p>
El argumento <code>color</code> puede ser una secuencia <code>RGB</code>, <code>RGBA</code> o un
√≠ndice de una paleta de colores. Si usa el formato <code>RGB</code> se ignorar√°
el componente alpha (una parte de <code>RGBA</code>) a menos que la superficie
use transparencia por pixel (atributo <code>SRCALPHA</code>).
</p>



<p>
A partir de pygame 1.8.0 puede usar las siguientes opciones adicionales:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_MAX</div>
</li>
</ul>



<p>
Y a partir de pygame 1.8.1 se suman:
</p>


<ul>
<li class="level1"><div class="li"> BLEND_RGBA_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGBA_MAX</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_ADD</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_SUB</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MULT</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MIN</div>
</li>
<li class="level1"><div class="li"> BLEND_RGB_MAX</div>
</li>
</ul>





<p>
Esta funci√≥n retornar√° el √°rea afectada de la superficie.
</p>

</div>
<!-- SECTION "fill" [15230-17327] -->
<h2><a name="set_colorkey" id="set_colorkey">set_colorkey</a></h2>
<div class="level2">



<p>
Define el color clave de transparencia.
</p>
<pre class="code python">Surface.<span class="me1">set_colorkey</span><span class="br0">&#40;</span>Color, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_colorkey</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el color clave para la superficie. Cuando imprima esta superficie
sobre otra, cualquier pixel que tenga el mismo color que el color
clave no se imprimir√°. El argumento <code>color</code> puede ser un color <code>RGB</code> o
un indice de una paleta de colores. Si se env√≠a <code>None</code> como argumento
entonces se deshabilitar√° el color clave.
</p>



<p>
Se ignorar√° el color clave si la superficie tiene un formato para
usar valores alpha por pixel. La transparencia por color clave se
puede mezclar con la transparencia a nivel de superficie.
</p>



<p>
Se puede definir el argumento opcional <code>flags</code> a <code>pygame.RLEACCEL</code>
para obtener mejor rendimiento en pantallas que no tengan aceleraci√≥n
de video. Una superficie <code>RLEACCEL</code> puede ser mas lenta de modificar, pero
se imprimir√° mas r√°pido.
</p>

</div>
<!-- SECTION "set_colorkey" [17328-18950] -->
<h2><a name="get_colorkey" id="get_colorkey">get_colorkey</a></h2>
<div class="level2">



<p>
Obtiene el color clave de transparencia actual.
</p>
<pre class="code">
Surface.get_colorkey(): return RGB or None
</pre>



<p>
Retorna el color clave actual de la superficie. Si la superficie no tiene
color clave la funci√≥n retornar√° <code>None</code>.
</p>

</div>
<!-- SECTION "get_colorkey" [18951-19358] -->
<h2><a name="set_alpha" id="set_alpha">set_alpha</a></h2>
<div class="level2">



<p>
Define el valor de transparencia para toda la superficie.
</p>
<pre class="code python">Surface.<span class="me1">set_alpha</span><span class="br0">&#40;</span>value, flags=0<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_alpha</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de transparencia para la superficie. Cuando se imprima
esta superficie sobre otra los pixels se dibujar√°n ligeramente transparentes. El
valor de transparencia es un n√∫mero entero de 0 a 255, 0 representa completamente
transparente y 255 completamente opaco. Se deshabilitar√° la transparencia
de la superficie si se pasa <code>None</code> como valor de transparencia.
</p>



<p>
Esta transparencia es diferente a la transparencia por pixel. Se ignorar√°
este valor de transparencia si la superficie contiene pixels con transparencia. Si
la superficie contiene transparencia por pixel, cuando llame a esta funci√≥n
con el argumento <code>None</code> se deshabilitar√° esa transparencia por pixel.
</p>



<p>
El argumento adicional <code>flags</code> se puede definir como <code>pygame.RLEACCEL</code> para
obtener mayor rendimiento en pantallas que no tengan aceleraci√≥n de video. Una
superficie <code>RLEACCEL</code> ser√° mas lenta de modificar, aunque ser√° mas r√°pido
imprimirla sobre otra.
</p>

</div>
<!-- SECTION "set_alpha" [19359-21344] -->
<h2><a name="get_alpha" id="get_alpha">get_alpha</a></h2>
<div class="level2">



<p>
Obtiene el valor de transparencia de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_alpha</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> int_value <span class="kw1">or</span> <span class="kw2">None</span></pre>


<p>
Retorna el valor de transparencia actual para la superficie. Se retornar√°
<code>None</code> si el valor de transparencia no est√° definido.
</p>

</div>
<!-- SECTION "get_alpha" [21345-21785] -->
<h2><a name="lock" id="lock">lock</a></h2>
<div class="level2">



<p>
Bloquea la memoria de la superficie para acceder a sus pixels.
</p>
<pre class="code python">Surface.<span class="me1">lock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Bloquea los datos de pixel de una superficie para acceder a ellos. En la
superficies aceleradas, los datos de pixels podr√≠an estar almacenados
en memoria de video vol√°til o en formas no lineales bajo compresi√≥n. Cuando
se bloquea una superficie la informaci√≥n de pixels se convierte en un
formato accesible. El c√≥digo que lee o escribe valores de pixels necesitar√°
que la superficie se bloquee para realizar esas tareas.
</p>



<p>
Las superficies no deber√≠an permanecer bloqueadas mas de lo necesario. Una
superficie bloqueada podr√≠a no mostrarse o ser manipulada por pygame.
</p>



<p>
No todas las superficies necesitan bloquease. El m√©todo <code>Surface.mustlock()</code>
puede determinar si la superficie requiere bloquease. De todas formas, no
hay desventaja al bloquear o desbloquear una superficie que no lo necesita.
</p>



<p>
Todas las funciones de pygame bloquear√°n o desbloquear√°n autom√°ticamente
los datos de la superficie si es necesario. Si una secci√≥n de c√≥digo hace
varias llamas para modificar la superficie, entonces se bloquear√° y
desbloquear√° muchas veces la superficie. Por este motivo, es mucho
mas √∫til bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>



<p>
Es seguro anidar llamas para bloquear y desbloquear. La superficie solo se
desbloquear√° despu√©s de soltar el √∫ltimo bloqueo.
</p>

</div>
<!-- SECTION "lock" [21786-24358] -->
<h2><a name="unlock" id="unlock">unlock</a></h2>
<div class="level2">



<p>
Desbloquea la memoria de la superficie del acceso a pixels.
</p>
<pre class="code python">Surface.<span class="me1">unlock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Desbloquea los datos de pixels de la superficie  luego de que ha
sido bloqueada. La superficie desbloqueada podr√° imprimirse nuevamente
por pygame. Vea la documentaci√≥n de <code>Surface.lock()</code> para mas detalles.
</p>



<p>
Todas las funciones de pygame bloquear√°n o desbloquear√°n autom√°ticamente
los datos de la superficie si es necesario. Si una secci√≥n de c√≥digo hace
varias llamas para modificar la superficie, entonces se bloquear√° y
desbloquear√° muchas veces la superficie. Por este motivo, es mucho
mas √∫til bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>



<p>
Es seguro anidar llamas para bloquear y desbloquear. La superficie solo se
desbloquear√° despu√©s de soltar el √∫ltimo bloqueo.
</p>

</div>
<!-- SECTION "unlock" [24359-25862] -->
<h2><a name="mustlock" id="mustlock">mustlock</a></h2>
<div class="level2">



<p>
Verifica si la superficie necesita bloquearse.
</p>
<pre class="code python">Surface.<span class="me1">mustlock</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">bool</span></pre>


<p>
Retorna <code>True</code> si la superficie se debe bloquear para acceder a sus
datos de pixel. Usualmente las superficies de software pura no necesitan
bloquease. Este m√©todo no se usa con frecuencia, dado que es seguro
y mas r√°pido directamente bloquear todas las superficies como sea
necesario.
</p>



<p>
Todas las funciones de pygame bloquear√°n o desbloquear√°n autom√°ticamente
los datos de la superficie si es necesario. Si una secci√≥n de c√≥digo hace
varias llamas para modificar la superficie, entonces se bloquear√° y
desbloquear√° muchas veces la superficie. Por este motivo, es mucho
mas √∫til bloquear la superficie manualmente, luego modificarla muchas
veces y luego desbloquearla manualmente.
</p>

</div>
<!-- SECTION "mustlock" [25863-27222] -->
<h2><a name="get_locked" id="get_locked">get_locked</a></h2>
<div class="level2">



<p>
Consulta si la superficie est√° bloqueada.
</p>
<pre class="code python">Surface.<span class="me1">get_locked</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">bool</span></pre>


<p>
Retorna <code>True</code> cuando la superficie est√° bloqueada. Esta funci√≥n
no se fija o preocupa sobre cuantas veces se ha bloqueado la superficie.
</p>

</div>
<!-- SECTION "get_locked" [27223-27640] -->
<h2><a name="get_locks" id="get_locks">get_locks</a></h2>
<div class="level2">



<p>
Obtiene los bloqueos de la superficie.
</p>
<pre class="code">
Surface.get_locks(): return tuple
</pre>



<p>
Retorna los bloqueos existentes para la superficie.
</p>

</div>
<!-- SECTION "get_locks" [27641-27909] -->
<h2><a name="get_at" id="get_at">get_at</a></h2>
<div class="level2">



<p>
Obtiene el valor de color de un pixel
</p>
<pre class="code python">Surface.<span class="me1">get_at</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span> <span class="br0">&#41;</span>: <span class="kw1">return</span> Color</pre>


<p>
Retorna el valor de color RGBA en la posici√≥n indicada. Si la superficie
no tiene transparencia por pixel, entonces el valor alpha del color
ser√° siempre 255 (completamente opaco). Se lanzar√° una excepci√≥n <code>IndexError</code>
si la posici√≥n del pixel est√° fuera del √°rea de la superficie.
</p>



<p>
Obtener y definir los pixels de a uno a la vez es una tarea generalmente lenta
para ser utilizada en un juego o una situaci√≥n de tiempo real.
</p>



<p>
Esta funci√≥n bloquear√° y desbloquear√° la superficie temporalmente como sea
necesario.
</p>

</div>
<!-- SECTION "get_at" [27910-29036] -->
<h2><a name="set_at" id="set_at">set_at</a></h2>
<div class="level2">



<p>
Define el valor de color para un pixel.
</p>
<pre class="code python">Surface.<span class="me1">set_at</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span>, Color<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de color RGBA o entero (si utiliza paleta) de un
pixel. Si la superficie no tiene transparencia por pixel, entonces
el valor alpha se ignorar√°. No tendr√° ning√∫n efecto definir pixels
fuera del √°rea total o el √°rea de recorte de la superficie.
</p>



<p>

Obtener y definir los pixels de a uno a la vez es una tarea generalmente lenta
para ser utilizada en un juego o una situaci√≥n de tiempo real.
</p>



<p>
Esta funci√≥n bloquear√° y desbloquear√° la superficie temporalmente como sea
necesario.
</p>

</div>
<!-- SECTION "set_at" [29037-30142] -->
<h2><a name="get_palette" id="get_palette">get_palette</a></h2>
<div class="level2">



<p>
Obtiene la paleta de colores para una superficie de 8 bits.
</p>
<pre class="code python">Surface.<span class="me1">get_palette</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#91;</span>RGB, RGB, RGB, ...<span class="br0">&#93;</span></pre>


<p>
Retorna una lista de a lo m√°ximo 256 elementos de color que representan
los colores utilizados en una superficie de 8bits. La lista que se retorna
es una copia de la paleta, y los cambios que se realicen en esta copia
no tendr√°n efecto sobre la superficie.
</p>

</div>
<!-- SECTION "get_palette" [30143-30820] -->
<h2><a name="get_palette_at" id="get_palette_at">get_palette_at</a></h2>
<div class="level2">



<p>
Obtiene el color de una entrada de la paleta de colores.
</p>
<pre class="code python">Surface.<span class="me1">get_palette_at</span><span class="br0">&#40;</span>index<span class="br0">&#41;</span>: <span class="kw1">return</span> RGB</pre>


<p>
Retorna los valores rojo, verde y azul de un elemento de la paleta de colores
de la superficie. El argumento <code>index</code> deber√≠a ser un valor entre 0 y 255.
</p>

</div>
<!-- SECTION "get_palette_at" [30821-31321] -->
<h2><a name="set_palette" id="set_palette">set_palette</a></h2>
<div class="level2">



<p>
Define la paleta de colores para una superficie de 8 bits.
</p>
<pre class="code python">Surface.<span class="me1">set_palette</span><span class="br0">&#40;</span><span class="br0">&#91;</span>RGB, RGB, RGB, ...<span class="br0">&#93;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define la paleta completa para una superficie de 8 bits. Esta funci√≥n
reemplazar√° los colores de la paleta existente. Se puede enviar una
paleta parcial, de modo que solo se reemplazar√°n los primeros elementos
de la misma.
</p>



<p>
Esta funci√≥n no hace nada sobre una superficie con mas de 8 bits por
pixel.
</p>

</div>
<!-- SECTION "set_palette" [31322-32125] -->
<h2><a name="set_palette_at" id="set_palette_at">set_palette_at</a></h2>
<div class="level2">



<p>
Define el color para un solo elemento en una paleta de colores.
</p>
<pre class="code python">Surface.<span class="me1">set_at</span><span class="br0">&#40;</span>index, RGB<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Define el valor de un color en la paleta de una superficie. El valor del
argumento <code>index</code> deber√≠a estar ente 0 y 255.
</p>



<p>
Esta funci√≥n no hace nada sobre una superficie con mas de 8 bits por
pixel.
</p>

</div>
<!-- SECTION "set_palette_at" [32126-32744] -->
<h2><a name="map_rgb" id="map_rgb">map_rgb</a></h2>
<div class="level2">



<p>
Convierte un color en un formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">map_rgb</span><span class="br0">&#40;</span>Color<span class="br0">&#41;</span>: <span class="kw1">return</span> mapped_int</pre>


<p>
Convierte un color RGBA en un n√∫mero entero empaquetado para esta superficie. El
n√∫mero entero retornado no contendr√° mas bits que la profundidad de color
de la superficie. Estos valores empaquetados no se usan con frecuencia dentro
de pygame, aunque se pueden pasar como argumento a varias funciones que
soliciten una superficie y un color.
</p>



<p>
Vea la documentaci√≥n del objeto <code>Surface</code> para obtener mas informaci√≥n
acerca de los colores y los formatos de pixel.
</p>

</div>
<!-- SECTION "map_rgb" [32745-33782] -->
<h2><a name="unmap_rgb" id="unmap_rgb">unmap_rgb</a></h2>
<div class="level2">



<p>
Convierte el valor de un entero empaquetado en un color.
</p>
<pre class="code python">Surface.<span class="me1">map_rgb</span><span class="br0">&#40;</span>mapped_int<span class="br0">&#41;</span>: <span class="kw1">return</span> Color</pre>


<p>
Convierte un color de formato empaquetado en un conjunto de componentes de
color RGB para esta superficie. Estos valores empaquetados no se usan con
frecuencia dentro de pygame, aunque se pueden pasar como argumento a varias
funciones que soliciten una superficie y un color.
</p>



<p>

Vea la documentaci√≥n del objeto <code>Surface</code> para obtener mas informaci√≥n
acerca de los colores y los formatos de pixel.
</p>

</div>
<!-- SECTION "unmap_rgb" [33783-34699] -->
<h2><a name="set_clip" id="set_clip">set_clip</a></h2>
<div class="level2">



<p>
Define el √°rea de recorte para la superficie.
</p>
<pre class="code python">Surface.<span class="me1">set_clip</span><span class="br0">&#40;</span>rect<span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span>
Surface.<span class="me1">set_clip</span><span class="br0">&#40;</span><span class="kw2">None</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Cada superficie tiene una √°rea de recorte activa. Este recorte es un
rect√°ngulo que representa a los pixels que se pueden modificar en una
superficie. Toda la superficie se podr√° modificar si se pasa <code>None</code> como
√°rea de recorte.
</p>



<p>

El √°rea de recorte est√° siempre limitada al √°rea de la superficie en s√≠ misma. Si
el rect√°ngulo de recorte es mas grande, entonces se encoger√° para caber dentro
de la superficie.
</p>

</div>
<!-- SECTION "set_clip" [34700-35723] -->
<h2><a name="get_clip" id="get_clip">get_clip</a></h2>
<div class="level2">



<p>
Obtiene el √°rea de recorte actual de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_clip</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Retorna una rect√°ngulo que representa el √°rea de recorte. La superficie
siempre retornar√° un rect√°ngulo v√°lido que nunca estar√° por afuera de
los bordes de la superficie. La superficie retornar√° el √°rea completa de
la misma si no se ha definido un √°rea de recorte.
</p>

</div>
<!-- SECTION "get_clip" [35724-36467] -->
<h2><a name="subsurface" id="subsurface">subsurface</a></h2>
<div class="level2">



<p>
Genera una nueva superficie que hace referencia a su pariente.
</p>
<pre class="code python">Surface.<span class="me1">subsurface</span><span class="br0">&#40;</span>Rect<span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna una nueva superficie que comparte sus pixels con su superficie
pariente. La nueva superficie se considera hija de la original. Las modificaciones
a los pixels de cualquier de las dos superficies afectar√° a la otra. La
informaci√≥n de la superficie como el √°rea de recorte o los colores clave son
√∫nicos para cada superficie.
</p>



<p>
La nueva superficie heredar√° la paleta, colores clave y configuraci√≥n
de transparencia de su padre.
</p>



<p>
Es posible tener cualquier n√∫mero de <em>sub-superficies</em> y <em>sub-sub-superficies</em>
de una superficie. Tambi√©n es posible tener una <em>sub-superficie</em> de la
pantalla principal si el modo de video no est√° acelerado por software.
</p>



<p>
Vea las funciones <em>Surface.get_offset()</em> y <em>Subsurfaces.get_parent()</em>
para aprender mas acerca del estado de una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "subsurface" [36468-38154] -->
<h2><a name="get_parent" id="get_parent">get_parent</a></h2>
<div class="level2">



<p>
Encuentra el padre de una <em>sub-superficie</em>.
</p>
<pre class="code python">Surface.<span class="me1">get_parent</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna el padre de una <em>sub-superficie</em>. Si el receptor no es una
<em>sub-superficie</em> entonces se retornar√° None.
</p>

</div>
<!-- SECTION "get_parent" [38155-38551] -->
<h2><a name="get_abs_parent" id="get_abs_parent">get_abs_parent</a></h2>
<div class="level2">



<p>
Obtiene el padre de mayor nivel de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_abs_parent</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Surface</pre>


<p>
Retorna el padre de una <em>sub-superficie</em>. Se retornar√° <code>None</code> si
el receptor no es una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_abs_parent" [38552-38974] -->
<h2><a name="get_offset" id="get_offset">get_offset</a></h2>
<div class="level2">



<p>
Encuentra la posici√≥n la superficie hija dentro del la superficie padre.
</p>
<pre class="code python">Surface.<span class="me1">get_offset</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span></pre>


<p>
Obtiene la posici√≥n de desplazamiento de una <em>sub-superficie</em> dentro
de la superficie padre. Retornar√° (0, 0) si la superficie no es una
<em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_offset" [38975-39492] -->
<h2><a name="get_abs_offset" id="get_abs_offset">get_abs_offset</a></h2>
<div class="level2">



<p>
Obtiene la posici√≥n absoluta de una superficie hija en relaci√≥n a su
padre de mayor nivel.
</p>
<pre class="code python">Surface.<span class="me1">get_abs_offset</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>x, y<span class="br0">&#41;</span></pre>


<p>
Obtiene la posici√≥n desplazamiento de una superficie hija en relaci√≥n
a superficie padre de nivel superior. Retornar√° (0, 0) si la superficie
no es una <em>sub-superficie</em>.
</p>

</div>
<!-- SECTION "get_abs_offset" [39493-40092] -->
<h2><a name="get_size" id="get_size">get_size</a></h2>
<div class="level2">



<p>
Obtiene las dimensiones de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_size</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>width, height<span class="br0">&#41;</span></pre>


<p>
Retorna el ancho y alto de una superficie medida en pixels.
</p>

</div>
<!-- SECTION "get_size" [40093-40390] -->
<h2><a name="get_width" id="get_width">get_width</a></h2>
<div class="level2">



<p>
Obtiene el ancho de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_width</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> width</pre>


<p>
Retorna el ancho de una superficie medida en pixels.
</p>

</div>
<!-- SECTION "get_width" [40391-40651] -->
<h2><a name="get_height" id="get_height">get_height</a></h2>
<div class="level2">



<p>
Obtiene la altura de una superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_height</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> height</pre>


<p>
Retorna la altura de una superficies medida en pixels.
</p>

</div>
<!-- SECTION "get_height" [40652-40920] -->
<h2><a name="get_rect" id="get_rect">get_rect</a></h2>
<div class="level2">



<p>
Obtiene el √°rea rectangular de una superficie.
</p>
<pre class="code">
Surface.get_rect(*\*kwargs): return Rect
</pre>



<p>
Retorna un nuevo rect√°ngulo que cubre la superficie entera. Este
rect√°ngulo siempre comenzar√° en la posici√≥n (0, 0) y tendr√° el
ancho y alto id√©ntico al tama√±o de la imagen.
</p>



<p>
Puede pasar valores clave como argumentos a esta funci√≥n. Estos
argumentos se aplicar√°n a los atributos del rect√°ngulo antes de
ser retornado. Un ejemplo podr√≠a ser <code>mysurf.get_rect(center=(100,100))</code>
para crear un rect√°ngulo de la superficie con centro en la posici√≥n
(100, 100).
</p>

</div>
<!-- SECTION "get_rect" [40921-41998] -->
<h2><a name="get_bitsize" id="get_bitsize">get_bitsize</a></h2>
<div class="level2">



<p>
Obtiene la profundidad de colores en bits del formato de pixel de la superficie.
</p>
<pre class="code">
Surface.get_bitsize(): return int
</pre>



<p>
Retorna el n√∫mero de bits utilizados para representar cada pixel. Este valor
podr√≠a no coincidir exactamente con el n√∫mero de bytes usados por pixel. Por
ejemplo, una superficie de 15 bits requiere 2 bytes completos.
</p>

</div>
<!-- SECTION "get_bitsize" [41999-42623] -->
<h2><a name="get_bytesize" id="get_bytesize">get_bytesize</a></h2>
<div class="level2">



<p>
Obtiene el n√∫mero de bytes utilizados por pixel de la superficie.
</p>
<pre class="code">
Surface.get_bytesize(): return int
</pre>



<p>
Retorna el n√∫mero de bytes utilizados por pixel.
</p>

</div>
<!-- SECTION "get_bytesize" [42624-42917] -->
<h2><a name="get_flags" id="get_flags">get_flags</a></h2>
<div class="level2">



<p>
Obtiene las opciones adicionales utilizadas por la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_flags</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">int</span></pre>


<p>
Retorna el conjunto de propiedades de la superficie. Cada propiedad es
un bit en la m√°scara de bits <code>flags</code>. Las propiedades habituales son
<code>HWSURFACE</code>, <code>RLEACCEL</code>, <code>SRCALPHA</code> y <code>SRCCOLORKEY</code>.
</p>



<p>
Esta es una lista mas completa de propiedades. La lista completa de estas
propiedades se puede encontrar en el archivo <a href="../../../../_media/traducciones/pygame/sdl_video.h.html" class="media mediafile mf_ wikilink2" title="traducciones:pygame:sdl_video.h">sdl_video.h</a>.
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> M√°scara de bits </th><th class="col2"> Descripci√≥n </th>
	</tr>
	<tr class="row1">
		<td class="col0"> SWSURFACE </td><td class="col1"> 0&times;00000000 </td><td class="col2"> La superficie est√° en la memoria de sistema </td>
	</tr>
	<tr class="row2">
		<td class="col0"> HWSURFACE </td><td class="col1"> 0&times;00000001 </td><td class="col2"> La superficie est√° en la memoria de video </td>
	</tr>
	<tr class="row3">
		<td class="col0"> ASYNCBLIT </td><td class="col1"> 0&times;00000004 </td><td class="col2"> Usa impresi√≥n as√≠ncrona cuando sea posible </td>
	</tr>
</table>



<p>
y algunas disponibles para la funci√≥n <code>pygame.display.set_mode()</code>:
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> M√°scara de bits </th><th class="col2"> Descripci√≥n </th>
	</tr>
	<tr class="row1">
		<td class="col0"> ANYFORMAT </td><td class="col1"> 0&times;10000000 </td><td class="col2"> Permite cualquier formato de pixel o color </td>
	</tr>
	<tr class="row2">
		<td class="col0"> HWPALETTE </td><td class="col1"> 0&times;20000000 </td><td class="col2"> La superficie tiene una paleta exclusiva </td>
	</tr>
	<tr class="row3">
		<td class="col0"> DOUBLEBUF </td><td class="col1"> 0&times;40000000 </td><td class="col2"> Define un modo de video con Double Buffer </td>
	</tr>
	<tr class="row4">
		<td class="col0"> FULLSCREEN </td><td class="col1"> 0&times;80000000 </td><td class="col2"> La superficie opera en modo pantalla completa </td>
	</tr>
	<tr class="row5">
		<td class="col0"> OPENGL </td><td class="col1"> 0&times;00000002 </td><td class="col2"> Genera un contexto de impresi√≥n para OpenGL </td>
	</tr>
	<tr class="row6">
		<td class="col0"> OPENGLBLIT </td><td class="col1"> 0x0000000A </td><td class="col2"> Genera un contexto de impresi√≥n 2D para Opengl (en desuso) </td>
	</tr>
	<tr class="row7">
		<td class="col0"> RESIZABLE </td><td class="col1"> 0&times;00000010 </td><td class="col2"> El modo de video se puede redimensionar </td>
	</tr>
	<tr class="row8">
		<td class="col0"> NOFRAME </td><td class="col1"> 0&times;00000020 </td><td class="col2"> No usar borde o t√≠tulo para esta ventana </td>
	</tr>
</table>



<p>
otras utilizadas internamente (de solo lectura)
</p>


<table class="inline">
	<tr class="row0">
		<th class="col0 leftalign"> Atributo  </th><th class="col1"> M√°scara de bits </th><th class="col2"> Descripci√≥n </th>
	</tr>
	<tr class="row1">
		<td class="col0"> HWACCEL </td><td class="col1"> 0&times;00000100 </td><td class="col2"> La operaci√≥n de impresi√≥n usa aceleraci√≥n por hardware </td>
	</tr>
	<tr class="row2">
		<td class="col0"> SRCCOLORKEY </td><td class="col1"> 0&times;00001000 </td><td class="col2"> La operaci√≥n de impresi√≥n usa un color clave para simular transparencia </td>
	</tr>
	<tr class="row3">
		<td class="col0"> RLEACCELOK </td><td class="col1"> 0&times;00002000 </td><td class="col2"> Atributo privado </td>
	</tr>
	<tr class="row4">
		<td class="col0"> RLEACCEL </td><td class="col1 leftalign"> 0&times;00004000	</td><td class="col2"> La superficie est√° empaquetada con el formato RLE </td>
	</tr>
	<tr class="row5">
		<td class="col0"> SRCALPHA </td><td class="col1 leftalign"> 0&times;00010000	</td><td class="col2"> La operaci√≥n de impresi√≥n utiliza la transparencia original </td>
	</tr>
	<tr class="row6">
		<td class="col0"> PREALLOC </td><td class="col1 leftalign"> 0&times;01000000	</td><td class="col2"> La superficie utiliza memoria pre-solicitada </td>
	</tr>
</table>

</div>
<!-- SECTION "get_flags" [42918-46493] -->
<h2><a name="get_pitch" id="get_pitch">get_pitch</a></h2>
<div class="level2">



<p>
Obtiene el n√∫mero de bytes utilizados por cada fila de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_pitch</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">int</span></pre>


<p>
Retorna el n√∫mero de bytes que separan a cada fila de pixels en una superficie. Las
superficies en memoria de video no siempre se almacenan en forma lineal. Las <em>sub-superficies</em>
tambi√©n podr√≠an tener un <code>pitch</code> mas grande que su verdadera longitud.
</p>



<p>
Este valor no es necesario para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_pitch" [46494-47264] -->
<h2><a name="get_masks" id="get_masks">get_masks</a></h2>
<div class="level2">



<p>
Obtiene la m√°scara de bits necesaria para convertir entre un color
RGB y un color empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_masks</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna la m√°scara de bits que se utiliza para empaquetar cada
color en un n√∫mero entero.
</p>



<p>
Este valor no se necesita para el uso normal de pygame.
</p>

</div>
<!-- SECTION "get_masks" [47265-47811] -->
<h2><a name="set_masks" id="set_masks">set_masks</a></h2>
<div class="level2">



<p>
Define la m√°scara de bits necesaria para convertir entre un color
RGB en un color en formato empaquetado.
</p>
<pre class="code">
Surface.set_masks( (r,g,b,a) ): return None
</pre>



<p>
Esta funci√≥n no se necesita para el uso habitual de pygame.
</p>



<p>
Es una funci√≥n nueva a partir de pygame 1.8.1.
</p>

</div>
<!-- SECTION "set_masks" [47812-48276] -->
<h2><a name="get_shifts" id="get_shifts">get_shifts</a></h2>
<div class="level2">



<p>
Obtiene los bits de intercambios necesarios para convertir un
color RGB en un color en formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_shifts</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna los bits de intercambio de pixel necesarios para convertir
el formato de cada color.
</p>



<p>
Este valor no se necesita para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_shifts" [48277-48854] -->
<h2><a name="set_shifts" id="set_shifts">set_shifts</a></h2>
<div class="level2">



<p>
Define los bits de intercambios necesarios para convertir un
color RGB en un color en formato empaquetado.
</p>
<pre class="code python">Surface.<span class="me1">get_shifts</span><span class="br0">&#40;</span> <span class="br0">&#40;</span>r,g,b,a<span class="br0">&#41;</span> <span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="kw2">None</span></pre>


<p>
Esta funci√≥n no se necesita para el uso habitual de pygame.
</p>



<p>
Esta funci√≥n es nueva a partir de pygame 1.8.1.
</p>

</div>
<!-- SECTION "set_shifts" [48855-49328] -->
<h2><a name="get_losses" id="get_losses">get_losses</a></h2>
<div class="level2">



<p>
Obtiene los bits significativos que se usan para convertir el
formato de color.
</p>
<pre class="code python">Surface.<span class="me1">get_losses</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> <span class="br0">&#40;</span>R, G, B, A<span class="br0">&#41;</span></pre>


<p>
Retorna el n√∫mero menos significativo de bits agrupados por
cada color en un n√∫mero entero empaquetado.
</p>



<p>

Este valor no se necesita para el uso habitual de pygame.
</p>

</div>
<!-- SECTION "get_losses" [49329-49904] -->
<h2><a name="get_bounding_rect" id="get_bounding_rect">get_bounding_rect</a></h2>
<div class="level2">



<p>
Obtiene el rect√°ngulo mas peque√±o que contiene informaci√≥n.
</p>
<pre class="code python">Surface.<span class="me1">get_bounding_rect</span><span class="br0">&#40;</span>min_alpha = <span class="nu0">1</span><span class="br0">&#41;</span>: <span class="kw1">return</span> Rect</pre>


<p>
Retorna la regi√≥n rectangular mas peque√±a que contiene todos los
pixels en una superficie que tienen un atributo de transparencia
mas grande o igual que le indicado por argumento.
</p>



<p>
Esta funci√≥n bloquear√° y desbloquear√° temporalmente la superficie.
</p>



<p>
Esta funci√≥n es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "get_bounding_rect" [49905-50689] -->
<h2><a name="get_buffer" id="get_buffer">get_buffer</a></h2>
<div class="level2">



<p>
Obtiene un objeto buffer para los pixels de la superficie.
</p>
<pre class="code python">Surface.<span class="me1">get_buffer</span><span class="br0">&#40;</span><span class="br0">&#41;</span>: <span class="kw1">return</span> BufferProxy</pre>


<p>
Retorna un objeto buffer para los pixels de la superficie. El buffer
se puede usar para acceder y manipular directamente los pixels.
</p>



<p>
Este m√©todo bloquea y desbloquea la superficie de forma impl√≠cita. El
bloqueo a la superficie se anular√° una vez que el objeto <code>BufferProxy</code>
sea eliminado.
</p>



<p>
Esta funci√≥n es nueva en pygame 1.8.
</p>

</div>
<!-- SECTION "get_buffer" [50690-] --></div>
</body>
</html>
