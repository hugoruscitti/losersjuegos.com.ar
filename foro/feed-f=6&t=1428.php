<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=1428" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2012-03-10T00:09:33+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=1428</id>
<entry>
<author><name><![CDATA[mcmakia696]]></name></author>
<updated>2012-03-10T00:09:33+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=1428&amp;p=6570#p6570</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=1428&amp;p=6570#p6570"/>
<title type="html"><![CDATA[COMO MOSTRAR VARIABLES TIPO INT CON SDL_TTF]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=1428&amp;p=6570#p6570"><![CDATA[
Hola, soy nuevo en este foro,espero que puedan ayudarme.Lo que pasa es que hice un juego con SDL ,en este, puedo mover al personaje y hacer Scrolling y colisiones, pero entonces quiero mostrar las varibles del personaje (x,y)para saber siempre en que posicion esta. pero no se como hacerlo ya que he probado con varias cosas pero no me funcionan.No solo quiero imprimir estas variables quisiera imprimir tambien otras.Aqui les dejo el codigo fuente del programa y una URL de donde podran descargar el programa completo con todos los recursos necesarios pesa unos 0.34 MB:<br /><br /><!-- m --><a class="postlink" href="https://rapidshare.com/files/3376479166/PROGRAMA_-ELITE942012-.rar">https://rapidshare.com/files/3376479166 ... 42012-.rar</a><!-- m --><br /><br />*NOTA:El codigo esta en gran parte en español para que se les facilite entenderlo.Utilizo Programacion Orientada a Objetos(POO).<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code><br />#include &lt;SDL.h&gt;<br />#include &lt;SDL_image.h&gt;<br />#include &lt;SDL_ttf.h&gt;<br />#include &lt;string&gt;<br />#include &lt;fstream&gt;<br /><br />//Atributos de la pantalla<br />const int PANTALLA_ANCHO = 800;<br />const int PANTALLA_ALTO = 600;<br />const int PANTALLA_BPP = 32;<br /><br />//La velocidad de cuadros por segundo (FPS)<br />const int CUADROS_POR_SEGUNDO = 20;<br /><br />//Las dimensiones del Personaje<br />const int PJ_ANCHO = 20;<br />const int PJ_ALTO = 20;<br /><br />//Las dimensiones del nivel<br />const int NIVEL_ANCHO = 1280;<br />const int NIVEL_ALTO = 960;<br /><br />//Constantes del &quot;Tile&quot;<br />const int TILE_ANCHO = 80;<br />const int TILE_ALTO = 80;<br />const int TOTAL_TILES = 192;<br />const int TILE_GRAFICOS = 2;<br /><br />//Los diferentes graficos del tile<br />const int TILE_LADRILLO = 0;<br />const int TILE_VACIO = 1;<br /><br />bool SALIR = false;<br />char TITULO&#91;&#93;=&quot;Juego de pruebas #1&quot;;<br /><br />//Las superficies<br />SDL_Surface *PJ_GRA = NULL;<br />SDL_Surface *PANTALLA = NULL;<br />SDL_Surface *GRAFICOS = NULL;<br />SDL_Surface *MENSAJE = NULL;<br /><br />//Recta donde se guardan los tiles que se &quot;recortaran&quot; desde el archivo de graficos<br />SDL_Rect clips&#91; TILE_GRAFICOS &#93;;<br /><br />//La estructura EVENTO<br />SDL_Event EVENTO;<br /><br />//El rectangulo de la camara<br />SDL_Rect CAMARA_R = { 0, 0, PANTALLA_ANCHO, PANTALLA_ALTO };<br /><br />//Definicion de los diferentes parametros que se necesitan para mostrar el texto por la pantalla<br />TTF_Font *FUENTE = NULL;<br />SDL_Color COLOR_TEXTO = { 255, 255, 255 };<br />char TEXTO&#91;&#93;=&quot;Variables del PJ (x,y)&quot;;<br /><br />//La clase TILE<br />class TILE<br />{<br />    private:<br />    //Los atributos del tile<br />    SDL_Rect RECTA2;<br /><br />    //El tipo de tile<br />    int TIPO;<br />   <br /><br />    public:<br />    //Inicializacion de las variables<br />    TILE( int x, int y, int TIPOTILE );<br /><br />    //Muestra los tiles<br />    void MOSTRAR();<br /><br />   //Obtiene el tipo de tile<br />    int OBT_TIPO();<br /><br />    //Obtiene el rectangulo de la colision<br />    SDL_Rect OBT_RECT();<br />};<br /><br />//La clase PJ<br />class PJ<br />{<br />    private:<br />    //El rectangulo de colision del personaje (PJ)<br />    SDL_Rect RECTANGULO;<br /><br />    //La velocidad del PJ<br />    int VEL_X, VEL_Y;<br /><br />   public:<br />    //Inicializa las variables<br />    PJ();<br /><br />    //Detecta las pulsaciones del teclado y ajusta la velocidad del PJ<br />   void TECLADO();<br /><br />    //Mueve al PJ<br />    void MOVER( TILE *tiles&#91;&#93; );<br /><br />    //Muestra al PJ en la pantalla<br />    void MOSTRAR();<br /><br />   //Establece la camara sobre el personaje<br />    void CAMARA();<br />};<br /><br />//Temporizador (TEMPO)<br />class TEMPORIZADOR<br />{<br />    private:<br />   //La hora del reloj cuando el TEMPO comenzo<br />    int startTicks;<br /><br />    //La hora del reloj cuando el TEMPO pauso<br />    int pausedTicks;<br /><br />    //El estado del TEMPO<br />    bool paused;<br />    bool started;<br /><br />    public:<br />    //Inicializa las variables<br />    TEMPORIZADOR();<br /><br />    //Las diferentes acciones del reloj<br />    void start();<br />    void stop();<br />    void pause();<br />    void unpause();<br /><br />    //Obtiene la hora del temporizador<br />    int get_ticks();<br /><br />    //Chekea el estado del temporizador<br />    bool is_started();<br />    bool is_paused();<br />};<br /><br />SDL_Surface *CARGAR( std::string filename )<br />{<br />    //La imagen que sera cargada<br />    SDL_Surface* CARGAR_IMAGEN = NULL;<br /><br />    //La superficie optimizada que sera usada<br />    SDL_Surface* IMAGEN_OPTIMIZADA = NULL;<br /><br />    //Cargar la imagen<br />    CARGAR_IMAGEN = IMG_Load( filename.c_str() );<br /><br />    //Si la imagen se cargo<br />    if( CARGAR_IMAGEN != NULL )<br />    {<br />        //Crea una superficie optimizada<br />        IMAGEN_OPTIMIZADA = SDL_DisplayFormat( CARGAR_IMAGEN );<br /><br />        //Descarga la superficie vieja<br />        SDL_FreeSurface( CARGAR_IMAGEN );<br /><br />        //Si la superficie fue optimizada<br />        if( IMAGEN_OPTIMIZADA != NULL )<br />        {<br />            //Color de profundidad de la superficie<br />            SDL_SetColorKey( IMAGEN_OPTIMIZADA, SDL_SRCCOLORKEY, SDL_MapRGB( IMAGEN_OPTIMIZADA-&gt;format, 255, 0, 128 ) );<br />        }<br />    }<br /><br />    //Retorna la superficie optimizada<br />    return IMAGEN_OPTIMIZADA;<br />}<br /><br />void DIBUJAR( int x, int y, SDL_Surface* ORIGEN, SDL_Surface* DESTINO, SDL_Rect* CLIP = NULL )<br />{<br />    //Rectangulo<br />    SDL_Rect RECTANGULO;<br /><br />    //Asignacion de variables al rectangulo<br />    RECTANGULO.x = x;<br />    RECTANGULO.y = y;<br /><br />    //Dibujar<br />    SDL_BlitSurface( ORIGEN, CLIP, DESTINO, &amp;RECTANGULO );<br />}<br /><br />bool COLISION( SDL_Rect A, SDL_Rect B )<br />{<br />    //Lados de los rectangulos<br />    int leftA, leftB;<br />    int rightA, rightB;<br />    int topA, topB;<br />    int bottomA, bottomB;<br /><br />    //Calcular los lados del rectangulo A<br />    leftA = A.x;<br />    rightA = A.x + A.w;<br />    topA = A.y;<br />    bottomA = A.y + A.h;<br /><br />    //calcular los lados del rectangulo B<br />    leftB = B.x;<br />    rightB = B.x + B.w;<br />    topB = B.y;<br />    bottomB = B.y + B.h;<br /><br />    //Si alguno de los lados de A esta fuera de B<br />    if( bottomA &lt;= topB ){ return false; }<br />   if( topA &gt;= bottomB ){ return false; }<br />   if( rightA &lt;= leftB ){ return false; }<br />   if( leftA &gt;= rightB ){ return false; }<br /><br />    //Si ninguno de los lados de A esta fuera de B<br />    return true;<br />}<br /><br />bool INICIAR()<br />{<br />    //Inicializa todos los sub sistemas de SDL<br />    if( SDL_Init( SDL_INIT_EVERYTHING ) == -1 ){ return false; }<br /><br />    //Configura la pantalla<br />    PANTALLA = SDL_SetVideoMode( PANTALLA_ANCHO, PANTALLA_ALTO, PANTALLA_BPP, SDL_SWSURFACE );<br /><br />    //Si hubo algun error al configurar la pantalla<br />    if( PANTALLA == NULL ){ return false; }<br />   if( TTF_Init() == -1 ){ return false; }<br /><br />   //El titulo de la ventana<br />    SDL_WM_SetCaption( TITULO, NULL );<br /><br />    //Si todo se inicializo bien<br />    return true;<br />}<br /><br />bool CARGAR_ARCHIVOS()<br />{<br />   //Abre la fuente del tipo de letra<br />    FUENTE = TTF_OpenFont( &quot;cour.ttf&quot;, 28 ); <br /><br />    //Carga la imagen<br />    PJ_GRA = CARGAR( &quot;PJ.bmp&quot; );<br /><br />    //Si hubo algun problema en cargar la imagen del PJ<br />    if( PJ_GRA == NULL ){ return false; }<br /><br />    //Carga los graficos de los tiles<br />    GRAFICOS = CARGAR( &quot;tiles.bmp&quot; );<br /><br />    //Si hubo algun problema en cargar los graficos de los tiles<br />    if( GRAFICOS == NULL ){ return false; }<br /><br />    //Si todo se cargo bien <br />    return true;<br />}<br /><br />void DESCARGAR_ARCHIVOS( TILE *tiles&#91;&#93; )<br />{<br />    //Descarga las superficies<br />    SDL_FreeSurface( PJ_GRA );<br />    SDL_FreeSurface( GRAFICOS );<br />   SDL_FreeSurface( MENSAJE );<br /><br />    //Descarga o elimina las superficies<br />    for( int t = 0; t &lt; TOTAL_TILES; t++ )<br />    {<br />        delete tiles&#91; t &#93;;<br />    }<br /><br />    TTF_CloseFont( FUENTE );<br />    TTF_Quit();<br /><br />    //Salir de SDL<br />    SDL_Quit();<br />}<br /><br />//Esta funcion recorta los tiles del archivo imagen donde se encuntran estos<br />void RECORTES()<br />{<br />    //Recorte de los graficos<br />    clips&#91; TILE_LADRILLO &#93;.x = 0;<br />    clips&#91; TILE_LADRILLO &#93;.y = 0;<br />    clips&#91; TILE_LADRILLO &#93;.w = TILE_ANCHO;<br />    clips&#91; TILE_LADRILLO &#93;.h = TILE_ALTO;<br /><br />    clips&#91; TILE_VACIO &#93;.x = 80;<br />    clips&#91; TILE_VACIO &#93;.y = 0;<br />    clips&#91; TILE_VACIO &#93;.w = TILE_ANCHO;<br />    clips&#91; TILE_VACIO &#93;.h = TILE_ALTO;<br /><br />    <br />}<br />/*Esta funcion se encarga de colocar los tiles en el orden en que estan, en el archivo &quot;map&quot;<br />que se cargo*/<br />bool COLOCAR_TILES( TILE *tiles&#91;&#93; )<br />{<br />    //Las variables de los tiles<br />    int x = 0, y = 0;<br /><br />    //Abre el archivo &quot;map&quot;<br />    std::ifstream map( &quot;mapa.map&quot; );<br /><br />    //Si el archivo map no pudo ser cargado<br />    if( map == NULL ){ return false; }<br /><br />    //Inicializa los tiles<br />    for( int t = 0; t &lt; TOTAL_TILES; t++ )<br />    {<br />        //Determina que tipo de tile sera colocado<br />        int TIPOTILE = -1;<br /><br />        //Lee el tile desde el archivo &quot;map&quot;<br />        map &gt;&gt; TIPOTILE;<br /><br />        //Si hubo algun problema en leer el archivo &quot;map&quot;<br />        if( map.fail() == true )<br />        {<br />            //Para el cargado del archivo map<br />            map.close();<br />            return false;<br />        }<br /><br />        //Si el numero es un numero de tile valido<br />        if( ( TIPOTILE &gt;= 0 ) &amp;&amp; ( TIPOTILE &lt; TILE_GRAFICOS ) )<br />        {<br />            tiles&#91; t &#93; = new TILE( x, y, TIPOTILE );<br />        }<br />        //Si no se reconoce el tipo de tile<br />        else<br />        {<br />            //Para el cargado del archivo map<br />            map.close();<br />            return false;<br />        }<br /><br />        //Mover al siguiente lugar de tile<br />        x += TILE_ANCHO;<br /><br />        //Si hemos ido demasiado lejos<br />        if( x &gt;= NIVEL_ANCHO )<br />        {<br />            //Mover atras<br />            x = 0;<br /><br />            //Mover a la siguiente fila<br />            y += TILE_ALTO;<br />        }<br />    }<br /><br />    //Cerrar el archivo map<br />    map.close();<br /><br />    //Si el archivo map se cargo bien<br />    return true;<br />}<br /><br />bool COLISION_TILE( SDL_Rect RECTA_F, TILE *tiles&#91;&#93; )<br />{<br />    //Ir atravez de los tiles<br />    for( int t = 0; t &lt; TOTAL_TILES; t++ )<br />    {<br />        //Si el tile es un ladrillo<br />        if( ( tiles&#91; t &#93;-&gt;OBT_TIPO() == TILE_LADRILLO ))<br />        {<br />            //Si el rectangulo de colision toca un tile de ladrillo<br />         if( COLISION( RECTA_F, tiles&#91; t &#93;-&gt;OBT_RECT() ) == true )<br />            {<br />                return true;<br />            }<br />         <br />        }<br /><br />      <br />    }<br /><br />    //Si los tiles de la pared no fueron tocados<br />    return false;<br />}<br /><br />TILE::TILE( int x, int y, int TIPOTILE )<br />{<br />    //Obtiene las variables del rectangulo<br />    RECTA2.x = x;<br />    RECTA2.y = y;<br /><br />    //Asignacion de acho y alto al rectangulo<br />    RECTA2.w = TILE_ANCHO;<br />    RECTA2.h = TILE_ALTO;<br /><br />    //Obtiene el tipo de tile<br />    TIPO = TIPOTILE;<br />}<br /><br />void TILE::MOSTRAR()<br />{<br />   //Si el tile esta en la pantalla<br />    if( COLISION( CAMARA_R,RECTA2 ) == true )<br />    {<br />        //Dibuja el tile<br />        DIBUJAR( RECTA2.x - CAMARA_R.x, RECTA2.y - CAMARA_R.y, GRAFICOS, PANTALLA, &amp;clips&#91; TIPO &#93; );<br />    }<br />}<br /><br />int TILE::OBT_TIPO()<br />{<br />    return TIPO;<br />}<br /><br />SDL_Rect TILE::OBT_RECT()<br />{<br />    return RECTA2;<br />}<br /><br />PJ::PJ()<br />{<br />    //Inicializa las variables del rectangulo<br />    RECTANGULO.x = 0;<br />    RECTANGULO.y = 0;<br />    RECTANGULO.w = PJ_ANCHO;<br />    RECTANGULO.h = PJ_ALTO;<br /><br />    //Inicializa la velocidad<br />    VEL_X = 0;<br />    VEL_Y = 0;<br />}<br /><br />void PJ::TECLADO()<br />{<br />    //Si una tecla fue presionada<br />    if( EVENTO.type == SDL_KEYDOWN )<br />    {<br />        //Ajusta la velocidad<br />        switch( EVENTO.key.keysym.sym )<br />        {<br />            case SDLK_UP: VEL_Y -= PJ_ALTO / 2; break;<br />            case SDLK_DOWN: VEL_Y += PJ_ALTO / 2; break;<br />            case SDLK_LEFT: VEL_X -= PJ_ANCHO / 2; break;<br />            case SDLK_RIGHT: VEL_X += PJ_ANCHO / 2; break;<br />         <br />        }<br />    }<br />    //Si una tecla fue levantada<br />    else if( EVENTO.type == SDL_KEYUP )<br />    {<br />        //Ajusta la velocidad<br />        switch( EVENTO.key.keysym.sym )<br />        {<br />            case SDLK_UP: VEL_Y += PJ_ALTO / 2; break;<br />            case SDLK_DOWN: VEL_Y -= PJ_ALTO / 2; break;<br />            case SDLK_LEFT: VEL_X += PJ_ANCHO / 2; break;<br />            case SDLK_RIGHT: VEL_X -= PJ_ANCHO / 2; break;<br />         <br />        }<br />    }<br />   //Si se presiona la tecla escape, salir.<br />   if(EVENTO.key.keysym.sym == SDLK_ESCAPE){ SALIR = true; }<br />}<br /><br /><br /><br />void PJ::MOVER( TILE *tiles&#91;&#93; )<br />{<br /><br />   <br />    //Mover al PJ a la izquierda o derecha<br />    RECTANGULO.x += VEL_X;<br />   <br /><br />    //Si el PJ se sale por la izquierda o derecha,o a tocado un ladrillo<br />    if( ( RECTANGULO.x &lt; 0 ) || ( RECTANGULO.x + PJ_ANCHO &gt; NIVEL_ANCHO ) || COLISION_TILE( RECTANGULO, tiles ) )<br />    {<br />        //Mover atras<br />        RECTANGULO.x -= VEL_X;<br />    }<br /><br />    //Mover al PJ arriba o abajo<br />    RECTANGULO.y += VEL_Y;<br />   <br />   <br />    //Si el PJ se sale por arriba o abajo,o a tocado un ladrillo<br />    if( ( RECTANGULO.y &lt; 0 ) || ( RECTANGULO.y + PJ_ALTO &gt; NIVEL_ALTO ) || COLISION_TILE( RECTANGULO, tiles ) )<br />    {<br />        //Mover atras<br />        RECTANGULO.y -= VEL_Y;<br />    }<br />}<br /><br />void PJ::MOSTRAR()<br />{<br />    //Dibuja al PJ<br />   DIBUJAR( RECTANGULO.x - CAMARA_R.x, RECTANGULO.y - CAMARA_R.y, PJ_GRA, PANTALLA );<br />   <br />}<br /><br />void PJ::CAMARA()<br />{<br />    //Centrar la camara sobre el PJ<br />    CAMARA_R.x = ( RECTANGULO.x + PJ_ANCHO / 2 ) - PANTALLA_ANCHO / 2;<br />    CAMARA_R.y = ( RECTANGULO.y + PJ_ALTO / 2 ) - PANTALLA_ALTO / 2;<br /><br />    //Mantiene la camara dentro del ecenario<br />    if( CAMARA_R.x &lt; 0 ){CAMARA_R.x = 0;}<br />    if( CAMARA_R.y &lt; 0 ){CAMARA_R.y = 0;}<br />    if( CAMARA_R.x &gt; NIVEL_ANCHO - CAMARA_R.w ){CAMARA_R.x = NIVEL_ANCHO - CAMARA_R.w;}<br />    if( CAMARA_R.y &gt; NIVEL_ALTO - CAMARA_R.h ){CAMARA_R.y = NIVEL_ALTO - CAMARA_R.h;}<br />}<br /><br />TEMPORIZADOR::TEMPORIZADOR()<br />{<br />    //Inicializa las variables<br />    startTicks = 0;<br />    pausedTicks = 0;<br />    paused = false;<br />    started = false;<br />}<br /><br />void TEMPORIZADOR::start()<br />{<br />    //Inicia el temporizador<br />    started = true;<br /><br />    //Pausa el temporizador<br />    paused = false;<br /><br />    //Obtiene la hora actual del reloj<br />    startTicks = SDL_GetTicks();<br />}<br /><br />void TEMPORIZADOR::stop()<br />{<br />    //Para el temporizador<br />    started = false;<br /><br />    //Reanuda el temporizador<br />    paused = false;<br />}<br /><br />void TEMPORIZADOR::pause()<br />{<br />    //Si el temporizador esta en marcha y no se detuvo<br />    if( ( started == true ) &amp;&amp; ( paused == false ) )<br />    {<br />        //Pausa el temporizador<br />        paused = true;<br /><br />        //Calcula el tiempo de pausa<br />        pausedTicks = SDL_GetTicks() - startTicks;<br />    }<br />}<br /><br />void TEMPORIZADOR::unpause()<br />{<br />    //Si el temporizador esta pausado<br />    if( paused == true )<br />    {<br />        //reanuda el temporizador<br />        paused = false;<br /><br />        //Reinicia el tiempo de inicio<br />        startTicks = SDL_GetTicks() - pausedTicks;<br /><br />        //Reinicia el tiempo de pausado<br />        pausedTicks = 0;<br />    }<br />}<br /><br />int TEMPORIZADOR::get_ticks()<br />{<br />    //Si el temporizador esta corriendo<br />    if( started == true )<br />    {<br />        //Si el temporizador esta pausado<br />        if( paused == true )<br />        {<br />            //Devuelve el numero de tiempo cuando el temporizador fue pausado<br />         return pausedTicks;<br />        }<br />        else<br />        {<br />            //Devuelve el tiempo actual menos la hora de inicio<br />            return SDL_GetTicks() - startTicks;<br />        }<br />    }<br /><br />    //Si el temporizador no esta funcionando<br />    return 0;<br />}<br /><br />bool TEMPORIZADOR::is_started()<br />{<br />    return started;<br />}<br /><br />bool TEMPORIZADOR::is_paused()<br />{<br />    return paused;<br />}<br /><br />int main( int argc, char* args&#91;&#93; )<br />{<br />   //El PJ<br />    PJ PELOTA;<br /><br />    //Los tiles que seran usados<br />    TILE *tiles&#91; TOTAL_TILES &#93;;<br /><br />    //El regulador de velocidad de cuadros<br />    TEMPORIZADOR FPS;<br /><br />    //Inicializar<br />    if( INICIAR() == false ){ return 1; }<br /><br />    //Cargar los archivos<br />    if( CARGAR_ARCHIVOS() == false ){ return 1; }<br /><br />   MENSAJE = TTF_RenderText_Solid( FUENTE, TEXTO, COLOR_TEXTO );<br /><br />    //Recortes de los graficos<br />    RECORTES();<br /><br />    //Coloca los tiles<br />    if( COLOCAR_TILES( tiles ) == false ){ return 1; }<br /><br />    //Mientras el usuario no se salga<br />    while( SALIR == false )<br />    {<br />        //Iniciar el temporizador de cuadros<br />        FPS.start();<br /><br />        //Mientras halla eventos por manejar<br />        while( SDL_PollEvent( &amp;EVENTO ) )<br />        {<br />            //Eventos del teclado para el PJ<br />            PELOTA.TECLADO();<br /><br />            //Evento de salida<br />            if( EVENTO.type == SDL_QUIT )<br />            {<br />                //Salir del programa<br />                SALIR = true;<br />            }<br />        }<br /><br />        //Mover al PJ<br />        PELOTA.MOVER( tiles );<br />      <br /><br />        //Activa la camara<br />        PELOTA.CAMARA();<br /><br />        //Muestra los tiles<br />        for( int t = 0; t &lt; TOTAL_TILES; t++ ){ tiles&#91; t &#93;-&gt;MOSTRAR(); }<br /><br />        //Muestra al PJ en la pantalla<br />      PELOTA.MOSTRAR();<br />      //Dibujar el mensaje<br />      DIBUJAR( 10,10 , MENSAJE, PANTALLA );<br /><br />      //Actualiza la pantalla<br />        if( SDL_Flip( PANTALLA ) == -1 ){ return 1; }<br /><br />        //Calculo de la velocidad de cuadros por segundo<br />        if( FPS.get_ticks() &lt; 1000 / CUADROS_POR_SEGUNDO )<br />        {<br />            SDL_Delay( ( 1000 / CUADROS_POR_SEGUNDO ) - FPS.get_ticks() );<br />        }<br />    }<br /><br />    //Descargar archivos<br />    DESCARGAR_ARCHIVOS( tiles );<br /><br />    return 0;<br />}<br /><br /><br /></code></dd></dl><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2589">mcmakia696</a> — Sab Mar 10, 2012 12:09 am</p><hr />
]]></content>
</entry>
</feed>