<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=19" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2006-10-05T01:10:31+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=19</id>
<entry>
<author><name><![CDATA[hugoruscitti]]></name></author>
<updated>2006-10-05T01:10:31+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=67#p67</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=67#p67"/>
<title type="html"><![CDATA[Re: SDL - Gráficos encima y debajo]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=67#p67"><![CDATA[
<blockquote><div><cite>kreezii escribió:</cite><br />No sé si me explicado bien, mi problema es que mientras escribo estoy pensando maneras de solucionarlo y se me ocurre una pero lo mismo es una burrada, una función que compruebe la coordenada y del enemigo y del personaje y en función de donde esté hacer un Blit_surface de uno y después de otro pero la cosa es que cuando haya más enemigos será un caos.<br /></div></blockquote><br /><br />Sí, ha quedado claro. Lo que me temo es que SDL no cuenta con una función que realice lo que necesitas. Dado <br />que ese requisito es muy propio del juego que buscas conseguir.<br /><br />Aún así, existen varias formas de lograr este efecto en SDL. Lo que puedes <br />hacer es almacenar todos tus personajes en una estructura de datos en memoria <br />como un vector o una lista. De cada personaje puedes almacenar su posición <br />junto con la superficie que lo representa en pantalla.<br /><br />Al momento de mostrar los personajes en pantalla puedes comenzar a imprimirlos<br />siguiendo un orden de profundidad, primero imprimes aquellos que &quot;están mas<br />alejados de la pantalla&quot; y luego aquellos que &quot;están mas cerca&quot;. Una forma de<br />lograr esto es reordenar todos los elementos de tu estructura justo antes de<br />comenzar a imprimir (puedes ordenarlos en base al valor de su coordenada &quot;y&quot;).<br />Una vez que están todos ordenados los imprimes.<br /><br />Aquí te dejo un pequeño ejemplo de ello utilizando objetos en C++, si programas<br />en otro lenguaje como C será un poco mas complicado de hacer, pero de todas <br />maneras se le parecerá, consulta nuevamente si quieres.<br /><br />Una vez que compiles el programa verás en pantalla algo así:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/descargas/ejemplo_profundidad/captura.png" alt="Imagen" /><br /><br />los cuadrados de color azul representan a los enemigos del juego (hay que tener<br />imaginación ...) mientras que el cuadrado blanco representa el personaje <br />protagonista que se puede mover en pantalla utilizando los direccionales del<br />teclado. Al mover los cuadrados todos se imprimen &quot;ordenados por profundidad&quot;, <br />como se esperaría de un juego como Final Fight.<br /><br />A continuación te dejo el código fuente de este programa, ten en cuenta que <br />las estructuras de datos se manejan mediante STL, una biblioteca que nos <br />facilita el manejo e implementación de listas, vectores etc...<br /> <br /><dl class="codebox"><dt>Code: </dt><dd><code>/*<br /> * Ordenar elementos en pantalla al imprimir<br /> *<br /> * Este programa muestra varios rectángulos en pantalla y simula<br /> * como deberían imprimirse en pantalla si estuvieran sobre un <br /> * plano con profundidad, similar al que se encuentra en videojuegos<br /> * como Final Fight.<br /> *<br /> * Puede encontrar una discusión acerca de este programa en el<br /> * foro:<br /> *    www.losersjuegos.com.ar/foro<br /> *<br /> */<br /><br />#include &quot;SDL.h&quot;<br />#include &lt;list&gt;<br /><br />/* Representa las características mas elementales<br /> * de un personaje que se debe imprimir en pantalla<br /> */<br />class Sprite<br />&#123;<br />   public:<br />      Sprite &#40;int x, int y&#41;;<br />      virtual void actualizar &#40;&#41; = 0;<br />      void imprimir &#40;SDL_Surface * screen&#41;;<br />      int get_y &#40;void&#41;;<br /><br />   protected:<br />      SDL_Rect rect;<br />      Uint32 color;<br />&#125;;<br /><br /><br />/* define la posición y tamaño inicial del sprite */<br />Sprite :: Sprite &#40;int x, int y&#41;<br />&#123;<br />   this-&gt;rect = &#40;SDL_Rect&#41; &#123;x, y, 40, 40&#125;;<br />&#125;<br /><br />/* informa la coodenada &quot;y&quot; en donde se deberían<br /> * encontrar los `pies` de un personaje<br /> */<br />int Sprite :: get_y &#40;void&#41;<br />&#123;<br />   return this-&gt;rect.y + this-&gt;rect.h;<br />&#125;<br /><br />/* muestra el objeto en pantalla */<br />void Sprite :: imprimir &#40;SDL_Surface * screen&#41;<br />&#123;<br />   SDL_Rect rect = this-&gt;rect;   /* nota: se realiza una copia<br />                  dado que SDL_FillRect puede<br />                  modificar este rectángulo si<br />                  no cabe en pantalla */<br /><br />   /* TODO: utilizar superficies en lugar de rectángulos <br />    * para que &quot;parezca&quot; un juego */<br />   SDL_FillRect &#40;screen, &amp; rect, this-&gt;color&#41;;<br />&#125;<br /><br /><br /><br />/* Representa un personaje que se maneja mediante del teclado.<br /> * hereda el comportamiento y estructura de todo Sprite.<br /> */<br />class Protagonista : public Sprite<br />&#123;<br />   public:<br />      Protagonista &#40;int x, int y&#41;;<br />      void actualizar &#40;&#41;;<br />&#125;;<br /><br /><br />/* método invocado al crear un nuevo protagonista */<br />Protagonista :: Protagonista &#40;int x, int y&#41; : Sprite &#40;x, y&#41;<br />&#123;<br />   this-&gt;color = 0xffffff;<br />&#125;<br /><br />/* actualiza la posición del personaje atendiendo la<br /> * pulsación de teclas */<br />void Protagonista :: actualizar &#40;void&#41;<br />&#123;<br />   Uint8 * teclas = SDL_GetKeyState &#40;NULL&#41;;<br />   int velocidad = 2;<br /><br />   if &#40;teclas &#91;SDLK_UP&#93;&#41;<br />      this-&gt;rect.y -= velocidad;<br />   else<br />      if &#40;teclas &#91;SDLK_DOWN&#93;&#41;<br />         this-&gt;rect.y += velocidad;<br /><br />   if &#40;teclas &#91;SDLK_LEFT&#93;&#41;<br />      this-&gt;rect.x -= velocidad;<br />   else<br />      if &#40;teclas &#91;SDLK_RIGHT&#93;&#41;<br />         this-&gt;rect.x += velocidad;<br />&#125;<br /><br /><br />/* representa un enemigo &#40;¡ un malvado cuadrado azul !&#41;<br /> * que se mueve de izquierda a derecha por la pantalla.<br /> * hereda de Sprite, al igual que el protagonista.<br /> */<br />class Enemigo : public Sprite<br />&#123;<br />   public:<br />      Enemigo &#40;int x, int y&#41;;<br />      void actualizar &#40;&#41;;<br />   public:<br />      int direccion;<br />&#125;;<br /><br /><br />/* construye al Enemigo asignándole el color azul */<br />Enemigo :: Enemigo &#40;int x, int y&#41; : Sprite &#40;x, y&#41;<br />&#123;<br />   this-&gt;color = 0x0000F5;<br />   this-&gt;direccion = 1;<br />&#125;<br /><br /><br />/* realiza el movimiento del enemigo en pantalla */<br />void Enemigo :: actualizar &#40;&#41;<br />&#123;<br />   /* el comportamiento de un enemigo es ir de un lado a otro en<br />    * la pantalla */<br />   if &#40;direccion == 1&#41;<br />   &#123;<br />      this-&gt;rect.x ++;<br /><br />      if &#40;rect.x + rect.w &gt; 320&#41;<br />         direccion = 0;<br />   &#125;<br />   else<br />   &#123;<br />      this-&gt;rect.x --;<br /><br />      if &#40;rect.x &lt; 0&#41;<br />         direccion = 1;<br />   &#125;<br /><br />&#125;<br /><br />/* informa &quot;true&quot; si el primer argumento &quot;a&quot; está mas alejado de la pantalla<br /> * que el argumento &quot;b&quot;<br /> * esta función se utiliza para re-ordenar la lista de personajes &#40;ver<br /> * función main&#41;<br /> */<br />bool es_menor &#40;Sprite * a, Sprite * b&#41;<br />&#123;<br />   return &#40;a-&gt;get_y &#40;&#41; &lt; b-&gt;get_y &#40;&#41;&#41;;<br />&#125;<br /><br /><br />/* <br /> * programa principal<br /> */<br />int main &#40;int argc, char * argv &#91;&#93;&#41;<br />&#123;<br />   std :: list &lt;Sprite *&gt; sprites;<br />   SDL_Surface * screen;<br />   SDL_Event event;<br />   bool salir = false;<br /><br />   /* TODO: verificar errores */<br />   SDL_Init &#40;0&#41;;<br />   screen = SDL_SetVideoMode &#40;320, 240, 16, 0&#41;;<br /><br />   /* Genera los personajes y los almanena en una lista */<br />   sprites.push_front &#40;new Protagonista &#40;30, 30&#41;&#41;;<br />   sprites.push_front &#40;new Enemigo &#40;130, 10&#41;&#41;;<br />   sprites.push_front &#40;new Enemigo &#40;220, 50&#41;&#41;;<br />   sprites.push_front &#40;new Enemigo &#40;170, 130&#41;&#41;;<br /><br /><br />   while &#40;! salir&#41;<br />   &#123;<br />      while &#40;SDL_PollEvent &#40;&amp;event&#41;&#41;<br />      &#123;<br />         if &#40;event.type == SDL_QUIT&#41;<br />            salir = true;<br />      &#125;<br />   <br />      SDL_FillRect &#40;screen, NULL, <br />            SDL_MapRGB &#40;screen-&gt;format, 200, 200, 200&#41;&#41;;<br /><br />      /* actualiza todos los elementos */<br />      std :: list &lt;Sprite *&gt; :: iterator iter;<br />      <br />      for &#40;iter = sprites.begin &#40;&#41;; iter != sprites.end &#40;&#41;; iter ++&#41;<br />         &#40;* iter&#41; -&gt; actualizar &#40;&#41;;<br /><br /><br />      /* IMPORTANTE: ordena los personajes antes de imprimirlos <br />       * llamando a la función &quot;es_menor&quot; para realizar <br />       * comparaciones */<br />      sprites.sort &#40;es_menor&#41;;<br /><br /><br />      /* imprime a todos los personajes en pantalla */<br />      for &#40;iter = sprites.begin &#40;&#41;; iter != sprites.end &#40;&#41;; iter ++&#41;<br />         &#40;* iter&#41; -&gt; imprimir &#40;screen&#41;;<br /><br />      SDL_Flip &#40;screen&#41;;<br />      SDL_Delay &#40;1&#41;;<br />   &#125;<br /><br />   SDL_Quit &#40;&#41;;<br />   return 0;<br />&#125;<br /></code></dd></dl><br /><br />y si archivo Makefile para compilarlo en GNU/Linux:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>CC = g++<br />CXXFLAGS = `sdl-config --cflags`<br />LDFLAGS = `sdl-config --libs`<br /><br />ejemplo: ejemplo.o<br /></code></dd></dl><br /><br />Saludos.<br /><br />PD: creo que &quot;Requeteguay&quot; estaba trabajando en una idea similar<br />a la del juego que buscas hacer, buscalo en este foro, puede que<br />también te de una mano en tu proyecto.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=3">hugoruscitti</a> — Jue Oct 05, 2006 1:10 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[kreezii]]></name></author>
<updated>2006-10-04T11:06:43+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=66#p66</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=66#p66"/>
<title type="html"><![CDATA[SDL - Gráficos encima y debajo]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=19&amp;p=66#p66"><![CDATA[
Buenas estoy empezando a programar en SDL (que por cierto es muy sencillo empezar e ir aprendiendo cosas) pero tengo una pequeña duda y es la siguiente: supongamos un juego estilo Final Fight (varios personajes que se mueven por un suelo en todas las direcciones posibles) la cosa es que si un personaje está más abajo que otro éste se tiene que dibujar encima de él ¡lógico!, para dibujar los gráficos hay que llamar a SDL_Blitsurface por orden, es decir, primero cargamos el fondo, y después los personajes, al inicio no hay problema pero cuando se empiecen a mover las posiciones cambiarán, me explico:<br />Un enemigo se dibuja por debajo del personaje principal pero el personaje principal sube, entonces el enemigo tendría que dibujarse encima ¿cómo hago eso? comprobando la posición y de cada uno de los dos eso sí pero me refiero en el código tengo algo así (pongo pseudocódigo que será más rápido):<br />Cargo las Imágenes;<br />Blit_Surface del Fondo;<br />Blit_surface del enemigo;<br />Blit_Surface del personaje principal;<br /><br />De este modo el fondo queda en el fondo ^_^, después se dibuja el enemigo y finalmente el personaje principal estará por encima de todos, pues bien mi pregunta es ¿no hay una función en SDL que pueda indicar que el enemigo se dibuje encima del personaje principal en ciertos momentos?<br />No sé si me explicado bien, mi problema es que mientras escribo estoy pensando maneras de solucionarlo y se me ocurre una pero lo mismo es una burrada, una función que compruebe la coordenada y del enemigo y del personaje y en función de donde esté hacer un Blit_surface de uno y después de otro pero la cosa es que cuando haya más enemigos será un caos.<br /><br />En fin... ¿alguien me puede ayudar?, un saludo.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=38">kreezii</a> — Mié Oct 04, 2006 11:06 am</p><hr />
]]></content>
</entry>
</feed>