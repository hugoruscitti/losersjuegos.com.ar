<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=529" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2009-03-31T17:38:20+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=529</id>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-03-31T17:38:20+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2375#p2375</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2375#p2375"/>
<title type="html"><![CDATA[A*]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2375#p2375"><![CDATA[
He editado el código del mensaje inicial porque se había publicado de forma incorrecta al estar habilitado el código HTML.<br /><br /><blockquote><div><cite>Juanxo escribió:</cite><br />Aqui os dejo un enlace con una version del A* hecha en python/pygame que encontre por ahí.<br /></div></blockquote>Gracias por la aportación. A simple vista he observado que implementa una cola de prioridad, yo he utilizado la de la STL. Ya lo miraré con más calma.<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mar Mar 31, 2009 5:38 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Juanxo]]></name></author>
<updated>2009-03-31T17:07:53+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2374#p2374</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2374#p2374"/>
<title type="html"><![CDATA[A*]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2374#p2374"><![CDATA[
Buenas a todos:<br />Aqui os dejo un enlace con una version del A* hecha en python/pygame que encontre por ahí. Yo no acabo de entenderla, pero a lo mejor vosotros si que sabeis mas.....<br /><br /><a href="http://www.megaupload.com/?d=0OZCI3GQ" class="postlink">A*</a><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2057">Juanxo</a> — Mar Mar 31, 2009 5:07 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-03-31T09:52:44+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2372#p2372</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2372#p2372"/>
<title type="html"><![CDATA[A*]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=529&amp;p=2372#p2372"><![CDATA[
El A* (a star, a estrella) es un algoritmo bastante eficiente (el más eficiente DE LOS QUE CONOZCO) a la hora de hacer pathfinding (búsqueda de la mejor ruta) en videojuegos.<br /><br />Ya que no he visto mucha información del tema en el foro, les dejo una implementación que he hecho en C++. Mi intención es que se compartamos formas de hacerlo más eficiente, encontrar errores, publicar implementaciones en otros lenguajes...<br /><br />La implementación que he hecho no tiene interfaz gráfica. La entrada consiste en 4 naturales (f, c, fi, fj) y un mapa. Donde f y c son las filas y las columnas. fi y fj son las coordenadas del final con 0 &lt;= fi &lt; f y 0 &lt;= fj &lt; c. El mapa consiste en '.' terreno libre, 'X' pared y 'I' inicio.<br />Ejemplo de entrada (en GNU/Linux se puede copiar a un archivo y hacer http://losersjuegos.com.ar/foro/ejecutable &lt;entrada.txt):<br /><dl class="codebox"><dt>Code: </dt><dd><code>8 16 0 15<br />X.X......X......<br />....X..X....XX..<br />X..X.XX.XXXX..XX<br />X.X...X......X.I<br />..X.X.X.XX.X....<br />....X...X....X..<br />.XXXXXXX...XX...<br />.........X.....X</code></dd></dl><br /><br />La salida consiste en el mapa inicial con 'O's marcando el camino. También saca por el canal de error los nodos tratados.<br />Salida:<br /><dl class="codebox"><dt>Code: </dt><dd><code>X.XOOOOOOX.OOOOO<br />..OOX..XOOO.XX..<br />XO.X.XX.XXXX..XX<br />XOX...X......X.I<br />.OX.X.X.XX.XOOO.<br />O...X...X.OOOX..<br />OXXXXXXXOO.XX...<br />OOOOOOOOOX.....X</code></dd></dl><br /><br />Implementación en C++:<br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;iostream&gt;<br />#include &lt;cmath&gt;<br />#include &lt;queue&gt;<br />#include &lt;vector&gt;<br />using namespace std;<br /><br />struct Node &#123;<br />    char c;<br />    int g, h, pi, pj;<br />    bool usado;<br />&#125;;<br /><br />struct NInfo &#123;<br />    int f, i, j;<br />&#125;;<br /><br />typedef vector&lt;Node&gt; Vn;<br />typedef vector&lt;Vn&gt; Mn;<br /><br />#define INF 100000;<br /><br />bool operator&lt;&#40;const NInfo&amp; ni1, const NInfo&amp; ni2&#41; &#123;<br />    if &#40;ni1.f != ni2.f&#41; return ni1.f &gt; ni2.f;<br />    if &#40;ni1.i != ni2.i&#41; return ni1.i &gt; ni2.i;<br />    return ni1.j &gt; ni2.j;<br />&#125;<br /><br />int H&#40;int i, int j, int fi, int fj&#41; &#123;<br />    return abs&#40;i-fi&#41;+abs&#40;j-fj&#41;;<br />&#125;<br /><br />void escriu&#40;const Mn&amp; m&#41; &#123;<br />    for &#40;int i = 0; i &lt; m.size&#40;&#41;; ++i&#41; &#123;<br />        for &#40;int j = 0; j &lt; m&#91;i&#93;.size&#40;&#41;; ++j&#41; &#123;<br />            cout &lt;&lt; m&#91;i&#93;&#91;j&#93;.c;<br />        &#125;<br />        cout &lt;&lt; endl;<br />    &#125;<br />&#125;<br /><br />void anyade_nodo&#40;Mn&amp; mn, priority_queue&lt;NInfo&gt;&amp; c, int i, int j, int di, int dj,int fi, int fj, bool diagonal = false&#41; &#123;<br />    int m = mn.size&#40;&#41;;<br />    int n = mn&#91;0&#93;.size&#40;&#41;;<br />    int incr = 10;<br />    if &#40;diagonal&#41; incr = 14;<br /><br />    if &#40;i+di &gt;= 0 and j+dj &gt;= 0 and i+di &lt; m and j+dj &lt; n and<br />        not mn&#91;i+di&#93;&#91;j+dj&#93;.usado and mn&#91;i+di&#93;&#91;j+dj&#93;.g &gt; mn&#91;i&#93;&#91;j&#93;.g+incr and<br />        mn&#91;i+di&#93;&#91;j+dj&#93;.c != 'X'&#41; &#123;<br />            if &#40;diagonal and mn&#91;i+di&#93;&#91;j&#93;.c == 'X' or mn&#91;i&#93;&#91;j+dj&#93;.c == 'X'&#41; return;<br />            mn&#91;i+di&#93;&#91;j+dj&#93;.g = mn&#91;i&#93;&#91;j&#93;.g+incr;<br />            mn&#91;i+di&#93;&#91;j+dj&#93;.h = H&#40;i+di, j+dj, fi, fj&#41;*10;<br />            mn&#91;i+di&#93;&#91;j+dj&#93;.pi = i;<br />            mn&#91;i+di&#93;&#91;j+dj&#93;.pj = j;<br />            NInfo ni2;<br />            ni2.i = i+di;<br />            ni2.j = j+dj;<br />            ni2.f = mn&#91;i+di&#93;&#91;j+dj&#93;.g+mn&#91;i+di&#93;&#91;j+dj&#93;.h;<br />            c.push&#40;ni2&#41;;<br />    &#125;<br />&#125;<br /><br /><br />int main&#40;&#41; &#123;<br />    int m, n;<br />    cin &gt;&gt; m &gt;&gt; n;<br />    int fi, fj;<br />    cin &gt;&gt; fi &gt;&gt; fj;<br />    Mn mn&#40;m, Vn&#40;n&#41;&#41;;<br />    priority_queue&lt;NInfo&gt; cabierta;<br />    for &#40;int i = 0; i &lt; m; ++i&#41; &#123;<br />        for &#40;int j = 0; j &lt; n; ++j&#41; &#123;<br />             mn&#91;i&#93;&#91;j&#93;.g = INF;<br />             mn&#91;i&#93;&#91;j&#93;.usado = false;<br />             cin &gt;&gt; mn&#91;i&#93;&#91;j&#93;.c;<br />             if &#40;mn&#91;i&#93;&#91;j&#93;.c == 'I'&#41; &#123;<br />                 mn&#91;i&#93;&#91;j&#93;.g = 0;<br />                 NInfo ni;<br />                 ni.i = i;<br />                 ni.j = j;<br />                 ni.f = H&#40;i, j, fi, fj&#41;;<br />                 cabierta.push&#40;ni&#41;;<br />             &#125;<br />        &#125;<br />    &#125;<br /><br />    bool final = false;<br />    while &#40;!final and !cabierta.empty&#40;&#41;&#41; &#123;<br />        NInfo ni = cabierta.top&#40;&#41;;<br />        cabierta.pop&#40;&#41;;<br />        int i = ni.i;<br />        int j = ni.j;<br />        if &#40;i == fi and j == fj&#41; final = true;<br />        if &#40;not mn&#91;i&#93;&#91;j&#93;.usado and not final&#41; &#123;<br />            cerr &lt;&lt; &quot;i:&quot; &lt;&lt; i &lt;&lt; &quot;j:&quot; &lt;&lt; j &lt;&lt; endl;<br />            mn&#91;i&#93;&#91;j&#93;.usado = true;<br />            anyade_nodo&#40;mn, cabierta, i, j, -1, 0, fi, fj&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, +1, 0, fi, fj&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, 0, -1, fi, fj&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, 0, +1, fi, fj&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, -1, -1, fi, fj, true&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, +1, +1, fi, fj, true&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, -1, +1, fi, fj, true&#41;;<br />            anyade_nodo&#40;mn, cabierta, i, j, +1, -1, fi, fj, true&#41;;<br />        &#125;<br />    &#125;<br /><br />    char c = mn&#91;fi&#93;&#91;fj&#93;.c;<br />    while &#40;c != 'I'&#41; &#123;<br />        mn&#91;fi&#93;&#91;fj&#93;.c = 'O';<br />        int iaux = mn&#91;fi&#93;&#91;fj&#93;.pi;<br />        int jaux = mn&#91;fi&#93;&#91;fj&#93;.pj;<br />        fi = iaux;<br />        fj = jaux;<br />        c = mn&#91;fi&#93;&#91;fj&#93;.c;<br />    &#125;<br />    escriu&#40;mn&#41;;<br />&#125;<br /></code></dd></dl><br /><br />Como documentación he utilizado:<br />-http://en.wikipedia.org/wiki/A*<br />-http://www.policyalmanac.org/games/articulo1.htm (aunque no conseguí descargarme la implementación)<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mar Mar 31, 2009 9:52 am</p><hr />
]]></content>
</entry>
</feed>