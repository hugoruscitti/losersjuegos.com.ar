<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=2&amp;t=547" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2009-06-23T14:49:38+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=2&amp;t=547</id>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-06-23T14:49:38+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2628#p2628</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2628#p2628"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2628#p2628"><![CDATA[
<span style="text-decoration: underline">Explicación de put_pixel</span><br /><dl class="codebox"><dt>Code: </dt><dd><code>void put_pixel&#40;SDL_Surface* screen, int row, int col, unsigned int color, double alp&#41; &#123;</code></dd></dl><br />Esta función se encarga de dibujar un píxel en una 'Surface' con un parámetro alpha que va de 0 a 1 siendo 0 sin transparencia.<br />Los parámetros son, respectivamente, 'Surface' destino, fila, columna, color del píxel a dibujar y valor alpha.<br /><dl class="codebox"><dt>Code: </dt><dd><code>    if &#40;alp &gt;= 1&#41; return;</code></dd></dl><br />si la transparencia es igual o superior a 100%, se sale de la función<br /><dl class="codebox"><dt>Code: </dt><dd><code>    Uint16 *pdest = &#40;Uint16*&#41;screen-&gt;pixels;<br />    pdest += screen-&gt;pitch/2*row;<br />    pdest += col;</code></dd></dl><br />Se hace que el puntero pdest apunte al píxel (de 16 bits) de la 'Surface' destino donde se quiere dibujar.<br /><dl class="codebox"><dt>Code: </dt><dd><code>    Uint16 c = *pdest;<br />    unsigned int r = &#40;c&amp;0xF800&#41;&gt;&gt;11;<br />    unsigned int g = &#40;c&amp;0x07E0&#41;&gt;&gt;5;<br />    unsigned int b = &#40;c&amp;0x001F&#41;;</code></dd></dl><br />Aquí se descompone el color del píxel elegido por partes roja, verde y azul. En este ejemplo, al ser una prueba rápida, está construida específicamente para una 'Surface' con profindidad de 16 bits por píxel (bpp). Pero utilizando la información del SDL_PixelFormat se puede generalizar.<br />En 16 bpp, el color se descompone por bits de la siguiente manera: RRRR RGGG GGGB BBBB. El rojo es de 5 bits, el verde de 6 y el azul de 5. Ya que el ojo humano es más sensible al verde. Por lo tanto, para obtener el rojo, se tiene que desplazar 11 bits a la derecha.<br />El parámetro color no hace falta descomponerlo porque es de solo 5 bits y solo sirve para generar una escala de grises haciendo que tanto la parte roja del píxel destino, la verde y la azul tomen el valor de color: C4,C3,C2,C1,  C0,C4,C3,C2,  C1,C0,1,C4,  C3,C2,C1,C0<br /><dl class="codebox"><dt>Code: </dt><dd><code>    unsigned int rgb_color = &#40;int&#40;r*alp + color*&#40;1-alp&#41;&#41;&lt;&lt;11&#41; | &#40;int&#40;g*alp + &#40;&#40;color&lt;&lt;1&#41;|1&#41;*&#40;1-alp&#41;&#41;&lt;&lt;5&#41; | &#40;int&#40;b*alp + color*&#40;1-alp&#41;&#41;&#41;;<br />    *pdest = rgb_color;<br />&#125;<br /></code></dd></dl><br />Aquí es donde se mezclan los dos colores. La mezcla se hace con los valores rojo, verde y azul de los dos colores de forma separada.<br />Para hacer la mezcla, se hace, con la media ponderada. Por ejemplo si alpha vale 0.25, sería 25%de r (o g o b) + 75% de color.<br />Una vez hecho esto con r, g y b, y desplazarlos a su respectivo lugar, solo queda sumar los bits con la or bit a bit.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mar Jun 23, 2009 2:49 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lacabra25]]></name></author>
<updated>2009-04-27T19:15:42+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2490#p2490</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2490#p2490"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2490#p2490"><![CDATA[
<blockquote><div><cite>endaramiz escribió:</cite><br />(*1)<br /></div></blockquote><br />OK, yo para el tema grafico siempre he usado SDL y como esta al copiar a pantalla las superficies comprueba automaticamente si se sale o no y se encarga de hacerlo no tuve en cuenta este detalle.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1912">lacabra25</a> — Lun Abr 27, 2009 7:15 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-04-26T15:14:01+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2480#p2480</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2480#p2480"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2480#p2480"><![CDATA[
<blockquote><div><cite>lacabra25 escribió:</cite><br />seria suficiente un for para trazar circulos que fuesen desde un radio igual al radio de la particula hasta un radio de un pixel (dibujar una particula mas pequeña que un pixel o de un pixel coma nosecuanto no tiene sentido, por lo que se usarian radios de numeros de pixeles enteros), dentro de este for solo es necesario un for para la coordenada x (solo en positivo pues dado que un circulo es simetrico se sobreentiende que la negativa tendra el mismo valor absoluto y solo cambia el signo) y dentro otro para la coordenada y), en total solo se necesitarian 3 for por particula, y no tantos bucles como se ve que hay.<br /></div></blockquote><br />Hay que tener cuidado con ese algoritmo porque dependiendo de como sea el algoritmo de dibujar el círculo puedes obtener resultados no deseados. Del mismo modo que pasa con Pygame si haces:<br /><dl class="codebox"><dt>Code: </dt><dd><code>import pygame<br />screen = pygame.display.set_mode&#40;&#40;200,200&#41;&#41;<br />pygame.draw.circle&#40;screen, &#40;255, 255, 255&#41;, &#40;100, 100&#41;, 70, 50&#41;<br />pygame.display.flip&#40;&#41;</code></dd></dl><br />No es simple coincidencia, es el algoritmo que usa pygame:<br /><dl class="codebox"><dt>Code: </dt><dd><code>&#91;En draw.c/static PyObject* circle&#40;PyObject* self, PyObject* arg&#41;&#93;<br />&#91;...&#93;<br />if&#40;!width&#41;<br />      draw_fillellipse&#40;surf, &#40;Sint16&#41;posx, &#40;Sint16&#41;posy, &#40;Sint16&#41;radius, &#40;Sint16&#41;radius, color&#41;;<br />   else<br />      for&#40;loop=0; loop&lt;width; ++loop&#41;<br />         draw_ellipse&#40;surf, posx, posy, radius-loop, radius-loop, color&#41;;<br />&#91;...&#93;</code></dd></dl><br /><br />Las razones por la que he hecho tantos bucles, a parte de la anterior, es porque dibujo la cruz aparte (los 4 bucles primeros) ya que sinó surgen problemas con la transparencia porque se dibujan 2 veces esos píxeles (0 == -0). Los otros son para comprobar los casos en los que hay que dibujar un píxel fuera del clip_rect de la pantalla. Como empiezo desde el eje horizontal hasta el borde de la circunferencia, si un píxel &quot;se sale de la pantalla&quot; (*1) puedo ahorrarme unas cuantas iteraciones del bucle porque todos los demás también &quot;estarán fuera&quot;. Aunque haga más bucles, al final me ahorro más iteraciones que si comprobase la posición a la hora de dibujar el píxel (en los casos de que hayan píxeles fuera de la pantalla). La diferencia entre una forma u otra creo que debe ser bastante peña  y depende de como traduce el compilador y esas cosas. Se podría comprobar con el profiler...<br /><br /><br /><br /><blockquote><div><cite>lacabra25 escribió:</cite><br />De resto solo puedo decirte que habria que pasarle el debuger para ver en que es en lo que falla, en que va lento y eso, para poder tratar mas dicho tema.<br /></div></blockquote>El principal problema es que se dibujan muchos píxeles. Al principio me iba a 160 ms por frame porque ocupaba casi toda la pantalla. Para cambiar esto, se tendría que rediseñar el código desde el principio con una idea distinta. Con la idea actual, manera más efectiva de ganar velocidad es que cuanto más pobre visualmente sea (menos bolas de humo, más pequeñas, que desaparecen más rápido...), más rápido irá.<br /><br /><blockquote><div><cite>lacabra25 escribió:</cite><br />Buen trabajo, la programacion orientada a objetos no es que me guste precisamente pero esta bien la idea del efecto de humo (no se si el tema de la velocidad de ejecucion tendra que ver con que uses objetos, puesto que en teoria estos se supone que son datos mas complejos que una simple estructura de datos).<br /></div></blockquote>Gracias. Sí, pero tampoco sé si afectará mucho. Igualmente, este es el estilo de programación con el que mejor me desenvuelvo. De otra manera, no sé si podría programarlo.<br /><br />*1: En realidad el concepto de que una superficie sea un matriz de píxeles es errónea. Es simplemente una fila (array). Por lo tanto, si se intenta dibujar más a la derecha de la anchura de la pantalla, salta al principio de la fila siguiente. Si se intenta dibujar &quot;por arriba o por abajo&quot; de la pantalla, se modifica memoria que no pertenece al array de píxeles con las consecuencias catastróficas que eso conlleva. Por esta razón, cuando se declara la screen, automáticamente se le asigna un clip_rect para que luego trabaje de la forma esperada SDL_BlitSurface.<br />Este efecto se puede comprobar en el código actual si una bola sale por la derecha de la pantalla ya que hay un bug en el código: la eliminación de las bolas se tiene que hacer después del update y antes del draw (si se pone el update después del draw, se soluciona).<br /><br />Ok sofoke, si tienes dudas en alguna parte, ya sabes... Y ya avisaréis si conseguís mejoras <img src="http://losersjuegos.com.ar/foro/images/smilies/icon_lol.gif" alt=":lol:" title="Laughing" /> .<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Dom Abr 26, 2009 3:14 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[sofoke]]></name></author>
<updated>2009-04-26T01:53:15+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2476#p2476</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2476#p2476"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2476#p2476"><![CDATA[
Ya he probado el efecto que acabas de crear, me parece muy interesante, como dices es algo lento; y como comenta nuestro amigo podriamos hacerle unas pequeñas modificaciones para ver si se acelera su ejecucion (lo cual seria bueno) checare mas tranquilamente tu efecto (todo el codigo) y comentare mis experiencias...<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1535">sofoke</a> — Dom Abr 26, 2009 1:53 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[lacabra25]]></name></author>
<updated>2009-04-26T00:25:11+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2474#p2474</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2474#p2474"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2474#p2474"><![CDATA[
la cuestión de que se ejecutase lento el código, viendolo un poco por encima, podria ser debido a todos los bucles for que usas para dibujar cada particula de la nube de humo, no entiendo a que se deben tantos for ya que si se supone que se va a dibujar particulas que formaran una nube de humo estas no deberian ser demasiado grandes, ninguna deberia llegar a los 10 pixelesy esto tirando al alza, por lo que aun usando circulos de un determinado radio seria suficiente un for para trazar circulos que fuesen desde un radio igual al radio de la particula hasta un radio de un pixel (dibujar una particula mas pequeña que un pixel o de un pixel coma nosecuanto no tiene sentido, por lo que se usarian radios de numeros de pixeles enteros), dentro de este for solo es necesario un for para la coordenada x (solo en positivo pues dado que un circulo es simetrico se sobreentiende que la negativa tendra el mismo valor absoluto y solo cambia el signo) y dentro otro para la coordenada y), en total solo se necesitarian 3 for por particula, y no tantos bucles como se ve que hay.<br /><br />De resto solo puedo decirte que habria que pasarle el debuger para ver en que es en lo que falla, en que va lento y eso, para poder tratar mas dicho tema.<br /><br />Buen trabajo, la programacion orientada a objetos no es que me guste precisamente pero esta bien la idea del efecto de humo (no se si el tema de la velocidad de ejecucion tendra que ver con que uses objetos, puesto que en teoria estos se supone que son datos mas complejos que una simple estructura de datos).<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1912">lacabra25</a> — Dom Abr 26, 2009 12:25 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-04-25T17:09:22+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2469#p2469</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2469#p2469"/>
<title type="html"><![CDATA[(intento de) Efecto humo [SDL]]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=547&amp;p=2469#p2469"><![CDATA[
Este programa intenta simular una fuente de humo utilizando para ello SDL. El motivo de la publicación se encuentra en  <a href="http://www.losersjuegos.com.ar/foro/viewtopic.php?t=544" class="postlink">este tema</a>.Como me temía, es bastante lento y tampoco es muy realista. Por estas razones, es muy posible que no sea una buena opción para un juego. Sin embargo, me he divertido bastante programándolo y me ha servido para aprender más cosas sobre el tratamiento de píxeles a bajo nivel. En el momento de escribir esto, estoy mal de tiempo, pero intentaré hacer una explicación cuando pueda. Si tienes alguna sugerencia (recién comienzo en este tema y me queda mucho por aprender...) o una duda concreta, no dudes en escribir. Si veo que hay interés, me daré más prisa en publicar la explicación.<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;iostream&gt;<br />#include &lt;cmath&gt;<br />#include &lt;list&gt;<br /><br />#include &lt;SDL/SDL.h&gt;<br />using namespace std;<br /><br />#define S_W 1024<br />#define S_H 768<br />#define bpp 2<br /><br />int pow&#40;int n, int e&#41; &#123;<br />    if &#40;e == 0&#41; return 1;<br />    return n*pow&#40;n, e-1&#41;;<br />&#125;<br /><br />double min&#40;double a, double b&#41; &#123;<br />    if &#40;a &lt;= b&#41; return a;<br />    return b;<br />&#125;<br /><br />void draw_circle3&#40;int x, int y, int r, double alp0, SDL_Surface* s&#41;;<br />void draw_circle3&#40;int x, int y, int r, double alp0, SDL_Surface* s&#41;;<br /><br />class Atomo &#123;<br />    public:<br />        Atomo&#40;int x, int y&#41;;<br />        void update&#40;double ax&#41;;<br />        void draw&#40;SDL_Surface* screen&#41;;<br />        bool finished&#40;&#41;;<br />        int prior;<br />    private:<br />        double x, y, dy;<br />        double dx;<br />        double r, dr;<br />        double alpha, dalpha;<br />&#125;;<br /><br />Atomo :: Atomo&#40;int x, int y&#41; &#123;<br />    prior = rand&#40;&#41;;<br />    this-&gt;x = x+rand&#40;&#41;%5-2; this-&gt;y = y+rand&#40;&#41;%5-2;<br />    dx = rand&#40;&#41;%10/10.0-0.5; dy = 4;<br />    alpha = 0.3 + rand&#40;&#41;%10/100.0; dalpha = 0.015;<br />    r = 2 + rand&#40;&#41;%3; dr = 2.5;<br />&#125;<br /><br />void Atomo :: update&#40;double ax&#41; &#123;<br />    dx += ax + rand&#40;&#41;%10/10.0-0.5;<br />    x += dx;<br />    y -= dy + rand&#40;&#41;%3-1;<br />    alpha += dalpha + rand&#40;&#41;%5/100;<br />    r += dr + rand&#40;&#41;%3-1;<br />&#125;<br /><br />void Atomo :: draw&#40;SDL_Surface* screen&#41; &#123;<br />    draw_circle3&#40;x, y, r, alpha, screen&#41;;<br />&#125;<br /><br />bool Atomo :: finished&#40;&#41; &#123;<br />    return alpha &gt;= 0.93 or x &gt;= S_W  or x &lt; 0 or y &lt; 0;<br />&#125;<br /><br /><br />void put_pixel&#40;SDL_Surface* screen, int row, int col, unsigned int color, double alp&#41; &#123;<br />    if &#40;alp &gt;= 1&#41; return;<br />    Uint16 *pdest = &#40;Uint16*&#41;screen-&gt;pixels;<br />    pdest += screen-&gt;pitch/2*row;<br />    pdest += col;<br />    Uint16 c = *pdest;<br />    unsigned int r = &#40;c&amp;0x0000F800&#41;&gt;&gt;11;<br />    unsigned int g = &#40;c&amp;0x000007E0&#41;&gt;&gt;5;<br />    unsigned int b = &#40;c&amp;0x0000001F&#41;;<br />    unsigned int rgb_color = &#40;int&#40;r*alp + color*&#40;1-alp&#41;&#41;&lt;&lt;11&#41; | &#40;int&#40;g*alp + &#40;&#40;color&lt;&lt;1&#41;|1&#41;*&#40;1-alp&#41;&#41;&lt;&lt;5&#41; | &#40;int&#40;b*alp + color*&#40;1-alp&#41;&#41;&#41;;<br />    *pdest = rgb_color;<br />&#125;<br /><br />void draw_circle3&#40;int x, int y, int r, double alp0, SDL_Surface* s&#41; &#123;<br />        int j = 0;<br />        for &#40;int ii = 1; ii &lt;= r and y+ii &lt; S_H; ++ii&#41;<br />                put_pixel&#40;s, y+ii,x,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, 0&#41;;<br />        for &#40;int ii = 1; ii &lt;= r and y+ii &gt;= 0; ++ii&#41;<br />                put_pixel&#40;s, y-ii,x,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, 0&#41;;<br />        for &#40;int ii = 1; ii &lt;= r and x-ii &gt;= 0; ++ii&#41;<br />                put_pixel&#40;s, y,x-ii,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, 0&#41;;<br />        for &#40;int ii = 1; ii &lt;= r and x+ii &lt; S_W; ++ii&#41; <br />                put_pixel&#40;s, y,x+ii,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, 0&#41;;<br />        put_pixel&#40;s, y,x,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;j,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*25, 0&#41;;<br /><br />        for &#40; j = 1; j &lt;= r; ++j&#41; &#123;<br />            int i = sqrt&#40;r*r-&#40;j*j&#41;&#41;;<br />            for &#40;int ii = 1; ii &lt;= i and y+ii &lt; S_H and x+j &lt; S_W; ++ii&#41;<br />                put_pixel&#40;s, y+ii,x+j,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, min&#40;&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*0.99 + alp0, 1&#41;&#41;;<br />            for &#40;int ii = 1; ii &lt;= i and y+ii &lt; S_H and x-j &gt;= 0; ++ii&#41;<br />                put_pixel&#40;s, y+ii,x-j,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, min&#40;&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*0.99 + alp0, 1&#41;&#41;;<br />            for &#40;int ii = 1; ii &lt;= i and y-ii &gt;= 0 and x+j &lt; S_W; ++ii&#41;<br />                put_pixel&#40;s, y-ii,x+j,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, min&#40;&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*0.99 + alp0, 1&#41;&#41;;<br />            for &#40;int ii = 1; ii &lt;= i and y-ii &gt;= 0 and x-j &gt;= 0; ++ii&#41;<br />                put_pixel&#40;s, y-ii,x-j,31-&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*20, min&#40;&#40;1-cos&#40;&#40;M_PI/2&#41;*&#40;pow&#40;ii,2&#41;+pow&#40;j,2&#41;&#41;/double&#40;pow&#40;r,2&#41;&#41;&#41;&#41;*0.99 + alp0, 1&#41;&#41;;<br />        &#125;<br />&#125;<br /><br />int main&#40;int argc, char** argv&#41; &#123;<br />    cerr &lt;&lt; SDL_Init&#40;SDL_INIT_VIDEO&#41;;<br />    SDL_Surface *screen = SDL_SetVideoMode&#40;S_W, S_H, bpp*8, SDL_HWSURFACE&#41;;<br />    SDL_ShowCursor&#40;SDL_DISABLE&#41;;<br /><br />    list&lt;Atomo*&gt; atomos;<br />    <br />    SDL_FillRect&#40;screen, &amp;screen-&gt;clip_rect, 0xF800&#41;;<br />    SDL_Event event;<br />    bool salir = false;<br />    int frame;<br />    while&#40;not salir&#41; &#123;<br />        SDL_FillRect&#40;screen, &amp;screen-&gt;clip_rect, 0xF800&#41;;<br />        int t0 = SDL_GetTicks&#40;&#41;;<br />        if &#40;!&#40;++frame%5&#41;&#41; &#123;<br />            Atomo* patomo = new Atomo&#40;S_W/2, S_H - 20&#41;;<br />            list&lt;Atomo*&gt;::iterator ita = atomos.begin&#40;&#41;;<br />            while &#40;ita != atomos.end&#40;&#41; and &#40;*ita&#41;-&gt;prior &gt; patomo-&gt;prior&#41;<br />                ++ita;<br />            atomos.insert&#40;--ita, patomo&#41;;<br />        &#125;<br /><br />        list&lt;Atomo*&gt;::iterator ita = atomos.begin&#40;&#41;;<br />        while &#40;ita != atomos.end&#40;&#41;&#41; &#123;<br />            if &#40;&#40;*ita&#41;-&gt;finished&#40;&#41;&#41; &#123;<br />                delete *ita;<br />                ita = atomos.erase&#40;ita&#41;;<br />            &#125;<br />            else &#123;<br />                &#40;*ita&#41;-&gt;update&#40;0.2&#41;;<br />                &#40;*ita&#41;-&gt;draw&#40;screen&#41;;<br />                ++ita;<br />            &#125;<br />        &#125;<br />        int t1 = SDL_GetTicks&#40;&#41;;<br />        while &#40;SDL_PollEvent&#40;&amp;event&#41;&#41; &#123;<br />            switch &#40;event.type&#41; &#123;<br />                case SDL_KEYDOWN:<br />                    switch &#40;event.key.keysym.sym&#41; &#123;<br />                        case SDLK_ESCAPE:<br />                            salir = true;<br />                        break;<br />                    &#125;<br />                break;<br />                case SDL_QUIT:<br />                    salir = true;<br />                break;<br />            &#125;<br />        &#125;<br />        cerr &lt;&lt; &quot;\rt. blit: &quot; &lt;&lt; t1-t0 &lt;&lt; &quot;  &quot;;<br />        SDL_Flip&#40;screen&#41;;<br />        SDL_Delay&#40;2&#41;;<br />    &#125;<br />    cerr &lt;&lt; endl;<br />    SDL_Quit&#40;&#41;;<br />&#125;</code></dd></dl><br /><br />Las cruces que salen no son un bug, sirven para comprobar el efecto alfa. El código no es una versión definitiva, es más bien para juguetear un poco.<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Sab Abr 25, 2009 5:09 pm</p><hr />
]]></content>
</entry>
</feed>