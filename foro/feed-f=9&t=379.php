<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=379" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2009-11-06T17:11:06+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=379</id>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-11-06T17:11:06+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=3024#p3024</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=3024#p3024"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=3024#p3024"><![CDATA[
Gracias Hugo! He vuelto a revisar el código con detenimiento y me ha dado muy buenas ideas. Pude parecer que funciona mal, pero es porque se desplaza demasiado rápido el punto.<br /><br />Lo de las rectas da mucho juego, pero respecto a lo de un punto en un triángulos, ya llevaba tiempo sin hacer una de mis publicaciones poco útiles así que allá voy:<br />Siguiendo la linea que llevaba, creo que se podría sacar, pero se complicaría demasiado. Me explicaron un método más sencillo para lograrlo:<br />Si tienes 3 puntos, A, B y P, donde A y B son 2 puntos de la recta, puedes saber si el punto P se encuentra a la &quot;derecha&quot; o a la &quot;izquierda&quot; (o justo encima) de la recta haciendo el determinante (simplificación para 2D del producto vectorial). Por ejemplo, si det((B-A), (P-A)) &gt; 0: el punto está girando en sentido antihorario (&quot;izquierda&quot; si miramos de A a B) a partir de la recta.<br />Teniendo esto como base, si tenemos un triángulo A, B, C, y un punto P, si el punto P está en el mismo lado para AB, BC y CA, entonces el punto P está dentro del triángulo.<br /><br />También hay otro método (habrán muchos...) que leí en este tutorial: <!-- m --><a class="postlink" href="http://nehe.gamedev.net/data/articles/article.asp?article=10">http://nehe.gamedev.net/data/articles/a ... article=10</a><!-- m --><br /><br /><br />También me puse a investigar un poco sobre el tema de triangulación y al final conseguí resultados. El algoritmo consiste en saber si el polígono está dibujado de forma antihoraria o al revés, entonces se van cogiendo 3 puntos y con el método que he explicado antes, se mira si el punto del medio forma un ángulo agudo en el polígono, si tampoco hay ningún otro vértice en el triángulo que forman los 3 puntos, entonces se puede añadir a la lista de triángulos y borrar el vértice del medio.<br /><br />Como mis explicaciones son bastante malas, os pongo el código:<br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;iostream&gt;<br />#include &lt;SDL/SDL.h&gt;<br />#include &lt;GL/gl.h&gt;<br />#include &lt;cmath&gt;<br />#include &lt;list&gt;<br />using namespace std;<br /><br /><br />struct V &#123;<br />    double x, y;<br />    V operator -&#40;const V&amp;&#41; const;<br />&#125;;<br /><br />struct T &#123;<br />    V p1, p2, p3;<br />&#125;;<br /><br />V V::operator-&#40;const V&amp; p2&#41; const&#123;<br />   V tmp = &#123;x-p2.x, y-p2.y&#125;;<br />   return tmp;<br />&#125;<br /><br />double hyp&#40;const V&amp; p1, const V&amp; p2&#41; &#123;<br />    return sqrt&#40;pow&#40;p1.x-p2.x,2.&#41;+pow&#40;p1.y-p2.y,2.&#41;&#41;;<br />&#125;<br /><br />int det&#40;const V&amp; p1, const V&amp; p2&#41; &#123;<br />   return p1.x*p2.y-p1.y*p2.x;<br />&#125;<br /><br />bool p_in_triangle2&#40;const V&amp; p0, const V&amp; p1, const V&amp; p2, const V&amp; p3&#41; &#123;<br />    int o1 = det&#40;p2-p1, p0-p1&#41;;<br />    int o2 = det&#40;p3-p2, p0-p2&#41;;<br />    int o3 = det&#40;p1-p3, p0-p3&#41;;<br />   return&#40;&#40;o1 &gt; 0 and o2 &gt; 0 and o3 &gt; 0&#41;<br />   or     &#40;o1 &lt; 0 and o2 &lt; 0 and o3 &lt; 0&#41;&#41;;<br />&#125;<br /><br />bool p_in_triangle1&#40;const V&amp; p0, const V&amp; p1, const V&amp; p2, const V&amp; p3&#41; &#123;<br />    double a1 = hyp&#40;p1, p2&#41;;<br />    double b1 = hyp&#40;p1, p0&#41;;<br />    double c1 = hyp&#40;p0, p2&#41;;<br />    double A1 = acos&#40;&#40;pow&#40;a1,2&#41;-&#40;pow&#40;b1,2&#41;+pow&#40;c1,2&#41;&#41;&#41;/double&#40;-2*b1*c1&#41;&#41;;<br /><br />    double a2 = hyp&#40;p3, p2&#41;;<br />    double b2 = hyp&#40;p3, p0&#41;;<br />    double c2 = hyp&#40;p0, p2&#41;;<br />    double A2 = acos&#40;&#40;pow&#40;a2,2&#41;-&#40;pow&#40;b2,2&#41;+pow&#40;c2,2&#41;&#41;&#41;/double&#40;-2*b2*c2&#41;&#41;;<br /><br />    double a3 = hyp&#40;p3, p1&#41;;<br />    double b3 = hyp&#40;p3, p0&#41;;<br />    double c3 = hyp&#40;p0, p1&#41;;<br />    double A3 = acos&#40;&#40;pow&#40;a3,2&#41;-&#40;pow&#40;b3,2&#41;+pow&#40;c3,2&#41;&#41;&#41;/double&#40;-2*b3*c3&#41;&#41;;<br /><br />    return &#40;A1+A2+A3&#41; &gt; 2*M_PI-&#40;2*M_PI/1000.&#41;;<br />&#125;<br /><br />bool a_la_izq&#40;const V&amp; v1, const V&amp; v2&#41; &#123;<br />    return det&#40;v1, v2&#41; &gt; 0;<br />&#125;<br /><br />void triangular&#40;std::list&lt;V&gt;&amp; vertices, std::list&lt;T&gt;&amp; triangles&#41; &#123;<br />   std::list&lt;V&gt;::iterator imax, ip;<br />   imax = ip = vertices.begin&#40;&#41;;<br />   while &#40;ip != vertices.end&#40;&#41;&#41; &#123;<br />      if &#40;imax-&gt;y &gt; ip-&gt;y&#41; imax = ip;<br />      ++ip;<br />   &#125;<br />   int max_x = imax-&gt;x;<br />   while &#40;imax-&gt;x == max_x&#41; &#123;<br />      ++imax;<br />      if &#40;imax == vertices.end&#40;&#41;&#41;<br />         imax = vertices.begin&#40;&#41;;<br />   &#125;<br />   bool clockwise = imax-&gt;x &lt; max_x;<br /><br />   std::list&lt;V&gt;::iterator iv1 = vertices.begin&#40;&#41;;<br />   std::list&lt;V&gt;::iterator iv2 = iv1; ++iv2;<br />   std::list&lt;V&gt;::iterator iv3 = iv2; ++iv3;<br />   while &#40;vertices.size&#40;&#41; &gt; 3&#41; &#123;<br />       bool oreja = false;<br />       while &#40;not oreja&#41; &#123;<br />           if &#40;&#40;a_la_izq&#40;*iv2 - &#40;*iv1&#41;, *iv3 - &#40;*iv1&#41;&#41; and !clockwise&#41; or <br />              &#40;!a_la_izq&#40;*iv2 - &#40;*iv1&#41;, *iv3 - &#40;*iv1&#41;&#41; and clockwise&#41;&#41; &#123;<br />               std::list&lt;V&gt;::iterator ip = vertices.begin&#40;&#41;;<br />               oreja = true;<br />               while &#40;oreja and ip != vertices.end&#40;&#41;&#41; &#123;<br />                   if &#40;p_in_triangle2&#40;*ip, *iv1, *iv2, *iv3&#41; and<br />                       ip != iv1 and ip != iv2 and ip != iv3&#41; &#123;<br />                       oreja = false;<br />                   &#125;<br />                   else ++ip;<br />               &#125;<br />           &#125;<br />           if &#40;not oreja&#41; &#123;<br />               ++iv1;<br />               if&#40;iv1 == vertices.end&#40;&#41;&#41; iv1 = vertices.begin&#40;&#41;;<br />               ++iv2;<br />               if&#40;iv2 == vertices.end&#40;&#41;&#41; iv2 = vertices.begin&#40;&#41;;<br />               ++iv3;<br />               if&#40;iv3 == vertices.end&#40;&#41;&#41; iv3 = vertices.begin&#40;&#41;;<br />           &#125;<br />       &#125;<br />       T t = &#123;*iv1, *iv2, *iv3&#125;;<br />       triangles.push_back&#40;t&#41;;<br />       iv2 = vertices.erase&#40;iv2&#41;;<br />       if&#40;iv2 == vertices.end&#40;&#41;&#41; iv2 = vertices.begin&#40;&#41;;<br />       ++iv3;<br />       if&#40;iv3 == vertices.end&#40;&#41;&#41; iv3 = vertices.begin&#40;&#41;;<br />   &#125;<br />   T t = &#123;*iv1, *iv2, *iv3&#125;;<br />   triangles.push_back&#40;t&#41;;<br />&#125;<br /><br /><br />void draw_vertices&#40;std::list&lt;V&gt;&amp; vertices&#41; &#123;<br />   glMatrixMode&#40;GL_MODELVIEW&#41;;<br />   glClear&#40;GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT&#41;; <br />   glLoadIdentity&#40;&#41;;<br />   glPolygonMode&#40;GL_FRONT_AND_BACK, GL_FILL&#41;;<br />   std::list&lt;V&gt;::iterator it = vertices.begin&#40;&#41;;<br />   std::list&lt;V&gt;::iterator its = it;<br />   ++its;<br />   while &#40;it != vertices.end&#40;&#41; and its != vertices.end&#40;&#41;&#41; &#123;<br />       glBegin&#40;GL_LINES&#41;;<br />           glVertex2f&#40;&#40;*it&#41;.x, &#40;*it&#41;.y&#41;;<br />           glVertex2f&#40;&#40;*its&#41;.x, &#40;*its&#41;.y&#41;;<br />       glEnd&#40;&#41;;<br />       ++it;<br />       ++its;<br />   &#125;<br />   glBegin&#40;GL_LINES&#41;;<br />       glVertex2f&#40;&#40;*&#40;--vertices.end&#40;&#41;&#41;&#41;.x, &#40;&#40;*&#40;--vertices.end&#40;&#41;&#41;&#41;.y&#41;&#41;;<br />       glVertex2f&#40;&#40;*vertices.begin&#40;&#41;&#41;.x, &#40;*vertices.begin&#40;&#41;&#41;.y&#41;;<br />   glEnd&#40;&#41;;<br />   SDL_GL_SwapBuffers&#40;&#41;;<br />&#125;<br /><br />void draw_triangles&#40;std::list&lt;T&gt;&amp; triangles&#41; &#123;<br />   glMatrixMode&#40;GL_MODELVIEW&#41;;<br />   glClear&#40;GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT&#41;; <br />   glLoadIdentity&#40;&#41;;<br />   std::list&lt;T&gt;::iterator it = triangles.begin&#40;&#41;;<br />   while &#40;it != triangles.end&#40;&#41;&#41; &#123;<br />       int x, y;<br />       SDL_GetMouseState&#40;&amp;x, &amp;y&#41;;<br />       V p = &#123;x, y&#125;;<br />       if &#40;p_in_triangle2&#40;p, &#40;*it&#41;.p1, &#40;*it&#41;.p2, &#40;*it&#41;.p3&#41;&#41;<br />           glPolygonMode&#40;GL_FRONT_AND_BACK, GL_FILL&#41;;<br />       else<br />           glPolygonMode&#40;GL_FRONT_AND_BACK, GL_LINE&#41;;<br />       glBegin&#40;GL_TRIANGLES&#41;;<br />       glVertex2f&#40;&#40;*it&#41;.p1.x, &#40;*it&#41;.p1.y&#41;;<br />       glVertex2f&#40;&#40;*it&#41;.p2.x, &#40;*it&#41;.p2.y&#41;;<br />       glVertex2f&#40;&#40;*it&#41;.p3.x, &#40;*it&#41;.p3.y&#41;;<br />       ++it;<br />       glEnd&#40;&#41;;<br />   &#125;<br />   SDL_GL_SwapBuffers&#40;&#41;;<br />&#125;<br /><br />void initGL&#40;&#41; &#123;<br />   glClearColor&#40; 0.0f, 0.0f, 0.0f, 0.0f &#41;;<br />   glPointSize&#40;3&#41;;<br />   glLineWidth&#40;3&#41;;<br />   glMatrixMode&#40;GL_PROJECTION&#41;;<br />   glLoadIdentity&#40;&#41;;<br />   glOrtho&#40;0.0, 640.0, 480.0, 0.0, -1.0, 1.0&#41;;<br />&#125;<br /><br />int main&#40;&#41; &#123;<br />   if &#40;SDL_Init&#40;SDL_INIT_VIDEO&#41; == -1&#41;  cout &lt;&lt; &quot;no se ha iniciado SDL&quot; &lt;&lt; endl;<br />   <br />   SDL_Surface* screen = SDL_SetVideoMode&#40;640, 480, 16,<br />      SDL_OPENGL | SDL_GL_DOUBLEBUFFER |<br />      SDL_HWPALETTE | SDL_HWSURFACE | SDL_HWACCEL&#41;;<br />   SDL_GL_SetAttribute&#40;SDL_GL_RED_SIZE, 8&#41;;<br />   SDL_GL_SetAttribute&#40;SDL_GL_GREEN_SIZE, 8&#41;;<br />   SDL_GL_SetAttribute&#40;SDL_GL_BLUE_SIZE, 8&#41;;<br />   SDL_GL_SetAttribute&#40;SDL_GL_DEPTH_SIZE, 24&#41;;<br />   SDL_GL_SetAttribute&#40;SDL_GL_DOUBLEBUFFER, 1&#41;;<br />   <br />   if &#40;screen == NULL&#41; &#123;<br />       cout &lt;&lt; &quot;No se ha iniciado la ventana OpenGL&quot; &lt;&lt; endl;<br />       return 0;<br />   &#125;<br />   initGL&#40;&#41;;<br /><br />   std::list&lt;V&gt; vertices;<br />   SDL_Event event;<br />   SDL_WaitEvent&#40;&amp;event&#41;;<br />   while &#40;event.type != SDL_KEYDOWN&#41; &#123;<br />       SDL_WaitEvent&#40;&amp;event&#41;; <br />       if &#40;event.type == SDL_MOUSEBUTTONDOWN&#41; &#123;<br />           int x, y;<br />           SDL_GetMouseState&#40;&amp;x, &amp;y&#41;;<br />           V p = &#123;x, y&#125;;<br />           vertices.push_back&#40;p&#41;;<br />       &#125;<br />       draw_vertices&#40;vertices&#41;;<br />   &#125;<br />   std::list&lt;T&gt; triangles;<br />   triangular&#40;vertices, triangles&#41;;<br />   bool exit = false;<br />   <br />   while &#40;not exit&#41; &#123;<br />      SDL_Event event;<br />      while &#40;SDL_PollEvent&#40;&amp;event&#41;&#41; &#123;<br />         switch &#40;event.type&#41; &#123;<br />            case SDL_QUIT:<br />               exit = true;<br />            break;<br />            case SDL_KEYDOWN:<br />               if &#40;event.key.keysym.sym == SDLK_ESCAPE&#41;<br />                  exit = true;<br />            break;<br />         &#125;<br />      &#125;   <br />      draw_triangles&#40;triangles&#41;;<br />   &#125;<br />   SDL_Quit&#40;&#41;;<br />&#125;<br /></code></dd></dl><br /><br />Se van poniendo vértices con el clic izquierdo y luego se pulsa una tecla.<br /><br />Puede que la forma de utilizar OpenGL no sea la correcta, que estoy comenzando.<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Vie Nov 06, 2009 5:11 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Geo]]></name></author>
<updated>2009-02-24T22:20:51+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2146#p2146</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2146#p2146"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2146#p2146"><![CDATA[
Perdón si no he entendido muy bien el tema, pero a primera vista, lo que yo haría sería usar colisión pixel a pixel de la siguiente forma:<br /><br />- Primero verifico si hay colisión por rectángulo (bounding boxes), (basándome en la imagen que colocó Bleed donde define cada línea dentro de un rectángulo).<br />- Si hay colisión por rectángulo, entonces procedo a verificar por cada pixel que define la recta.<br /><br />Hugo: no he podido ver las imágenes que colocaste.<br />Bleed: tampoco he podido acceder al RPG al que enlazas.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=6">Geo</a> — Mar Feb 24, 2009 10:20 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-02-24T17:59:51+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2145#p2145</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2145#p2145"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2145#p2145"><![CDATA[
<blockquote><div><cite>Juanxo escribió:</cite><br />Respecto a la sugerencia dada por david, no valdría el uso de triángulos en este caso, puesto que puede darse el caso de que no se cumpla.<br /></div></blockquote><br />Es verdad. No había tenido en cuenta ese caso. Intentaré buscar una solución algún día que tenga suficiente tiempo libre como para aburrirme.<br /><br />¿A alguien se le ocurre alguna otra idea?<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mar Feb 24, 2009 5:59 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Juanxo]]></name></author>
<updated>2009-02-22T03:36:45+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2127#p2127</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2127#p2127"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2127#p2127"><![CDATA[
Respecto a la sugerencia dada por david, no valdría el uso de triángulos en este caso, puesto que puede darse el caso de que no se cumpla.<br /><br />He tratado de poner un ejemplo en la imagen, pero no se si se entenderá.<br /><br /><!-- m --><a class="postlink" href="http://img135.imageshack.us/my.php?image=dibujoe.jpg">http://img135.imageshack.us/my.php?image=dibujoe.jpg</a><!-- m --><br /><br />Intentar calcular(a ojo) las distancias entre la arista opuesta a un vertice y el punto, y esta será siempre menor que la distancia entre la arista opuesta y el vertice<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2057">Juanxo</a> — Dom Feb 22, 2009 3:36 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[samu_dnet]]></name></author>
<updated>2009-02-21T12:07:04+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2124#p2124</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2124#p2124"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2124#p2124"><![CDATA[
no se en pyton como funciona, pero no seria mas facil comprobar donde esta el cuadrado antes de mandarle la funcion de que se mueva?? por ej:<br /><dl class="codebox"><dt>Code: </dt><dd><code>evento_teclapulsada&#40;derecha&#41;<br />&#123;<br />      if &#40;cuadrado_lateralderecho.x == punto_delalinea_en_X&#41;<br />         &#123;<br />                //no hacer nada<br />          &#125;<br />       else<br />       &#123;<br />            cuadrado.x += 1;<br />        &#125;<br />&#125;<br /></code></dd></dl><br /><br />lo mismo con la coordenada y.<br /><br />No se en pyton como se manejan los cuadrados pero si por ejemplo la coordenada del cuadrado es igual al punto central de este, si por ejemplo el cuadrado hace 20 x 20, diriamos que cuadrado lateral derecho seria cuadrado +10.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2066">samu_dnet</a> — Sab Feb 21, 2009 12:07 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2009-02-13T19:45:55+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2102#p2102</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2102#p2102"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=2102#p2102"><![CDATA[
Perdón por olvidarme del tema.<br /><br />En el caso de un minigolf se necesita trabajar con rectas matemáticas. Pero, en este caso, ¿no sería mejor trabajar con colisión por pixel? Igualmente, para poder dibujar el mapa podría ser necesaria una máscara de bits. <br />No puedo profundizar mucho en el tema porque me estoy iniciando en él. Aunque intentaré hacer algún ejemplo para dentro de unos cuantos días.<br /><br />Respecto a lo de la triangulación, al ser un tema importante, hay bastantes algoritmos hechos.<br />Yo miraría si un punto está dentro de un triángulo. Dividiendo un triángulo en una recta y un vértice suelto. Y que compruebe si el punto está más cerca que el otro vértice.  Esto se repetiría 2 veces más cogiendo la recta con vértices distintos.<br /><br />¿Alguna idea mejor?¿Algún caso para el que mi idea no funciona?<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Vie Feb 13, 2009 7:45 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[hugoruscitti]]></name></author>
<updated>2008-09-17T18:35:49+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1672#p1672</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1672#p1672"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1672#p1672"><![CDATA[
Es cierto, no había pensado que las lineas ofrecían tanta<br />versatilidad... el ejemplo web es muy interesante, sería bueno<br />tratar de hacer algo así, al menos como ejemplo.<br /><br />Estuve buscando si existía alguna forma de hacer algo similar, <br />y en la página de pygame encontré funciones de utilidad para<br />buscar distancia entre un punto y una linea:<br /><br />     <!-- m --><a class="postlink" href="http://www.pygame.org/project/357/">http://www.pygame.org/project/357/</a><!-- m --><br /><br />con estas funciones busqué hacer un ejemplo mas simple, que<br />en lugar de mover un rectángulo sea un punto... pero bueno, <br />tendría que mejorarlo para que funcionen mejor las colisiones y, <br />si funciona bien, extenderlo a un rectángulo:<br /><br />    <img src="http://www.losersjuegos.com.ar/incoming/descargas/20080917/figuras.png" alt="Imagen" /><br /><br />el programa muestra un punto rojo que se puede mover con el<br />teclado por toda la ventana, excepto cruzando lineas:<br /><br />   <!-- m --><a class="postlink" href="http://www.losersjuegos.com.ar/incoming/descargas/20080917/test_lineas.tar.gz">http://www.losersjuegos.com.ar/incoming ... eas.tar.gz</a><!-- m --><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=3">hugoruscitti</a> — Mié Sep 17, 2008 6:35 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bleed]]></name></author>
<updated>2008-09-17T02:55:30+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1671#p1671</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1671#p1671"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1671#p1671"><![CDATA[
Gracias por contestar, Hugo. He estado ojeando el asunto de los triángulos y aunque parece una posible opción, la encuentro algo limitada (sólo permitiría definir regiones cerradas).<br /><br />En un principio consideré el uso de líneas por la cantidad de posibilidades que estas ofrencen. Son muy flexibles ya que no sólo permiten definir polígonos. Quiero que echen un vistazo a este prototipo de RPG.<br /><br /><!-- m --><a class="postlink" href="http://past.soywiz.com/web_game/">http://past.soywiz.com/web_game/</a><!-- m --><br /><br />Como podréis ver, a base de líneas se ha implementado lo que os venía comentado. Cada línea (internamente creo que son rectángulos) se trata de forma individual y haciendo coincidir el inicio de una con el fin de otra, forman polígonos de formas extremadamente complejas. Por este mismo motivo, aunque el uso de triángulos pueda ser interesante, la potencia y quizás la sensillez de las líneas (he mirado por encima las clases que usa el RPG y no se extienden demasiado) puedan aportar un abanico de posibilidades.<br /><br /><img src="http://img382.imageshack.us/img382/4407/project3rw1.png" alt="Imagen" /><br /><br />A ver si este fin de semana puedo estudiar más a fondo el código Javascript del RPG y saco algo más en clave. Me da la sensación, que la solución está en combinar ambas técnicas y sobretodo aprovechar el tema de los triángulos para regiones cerradas.<br /><br />Por cierto, en el ejemplo de la isla, añadí un pequeño lago para que también se tuviese en cuenta que cualquier parte del cuadrado fuese sensible a las colisiones.<br /><br /><img src="http://img382.imageshack.us/img382/4296/project2ap1.gif" alt="Imagen" /><br /><span style="font-weight: bold">Gif animado</span><br /><br />PD: Mi idea es trabajar con Python y Pygame.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1977">Bleed</a> — Mié Sep 17, 2008 2:55 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[hugoruscitti]]></name></author>
<updated>2008-09-17T00:44:49+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1668#p1668</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1668#p1668"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1668#p1668"><![CDATA[
Saludos, creo que la idea de David puede funcionar muy bien. La idea<br />sería, según entiendo, verificar colisiones al momento de mover el<br />rectángulo. Las colisiones se verificarían entre las esquinas del<br />rectángulo y una serie de triángulos construidos con los polígonos<br />que nos muestras en las imágenes.<br /><br />Partamos de tu gráfico inicial:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/descargas/20080916/base.png" alt="Imagen" /><br /><br />Como analizar el área de un polígono es una tarea difícil, la recomendación<br />de David nos puede servir: pensar el polígono como si se tratara de triángulos<br />pequeños:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/descargas/20080916/triangulos.png" alt="Imagen" /><br /><br />Si bien juntos forman la figura, sería prudente almacenarlos en una estructura<br />que nos permita tratarlos por separado. Así, cuando queramos analizar la<br />superficie no importarán la cantidad de vértices, solo tendremos triángulos<br />y un cuadrado:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/descargas/20080916/triangulo.png" alt="Imagen" /><br /><br /><br />Ahora bien, imagina que comenzamos a desplazar el cuadrado por la pantalla<br />libremente; Si no detenemos su movimiento se pueden presentar dos<br />situaciones: que el cuadrado esté dentro o afuera del polígono original.<br /><br />El movimiento simplemente tiene que permitir movimientos dentro del<br />polígono y prohibir movimientos fuera de él.<br /><br />La condición que nos permite conocer, de manera sencilla, si el cuadrado<br />está dentro del triángulo son sus esquinas. Si está dentro del polígono, todas<br />sus esquinas están dentro de algún triángulo. En cambio bastará con que una de<br />sus esquinas esté fuera de un triángulo para considerar que el movimiento<br />es incorrecto:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/descargas/20080916/dentro.png" alt="Imagen" /><br /><br />Esto es similar a lo que ocurre en un juego de plataformas cuando quieres<br />controlar la caída de un personaje: solo tienes que realizar una prueba de<br />movimiento antes de desplazar el objeto, si el movimiento de prueba deja el<br />objeto dentro de la zona permitida confirmas el movimiento y en caso contrario<br />lo descartas.<br /><br /><br />Lamento no tener un ejemplo simple a mano, pero podría intentar escribir<br />uno (en python creo que sería mas ilustrativo). Tú, ¿que lenguaje estás<br />utilizando?.<br /><br />Por cierto, he visto que existen funciones para determinar colisiones entre<br />puntos y triángulos. Si te parece buena la estrategia, podrías adaptar alguno<br />de estos para tu programa:<br /><br />    <!-- m --><a class="postlink" href="http://www.angelfire.com/fl/houseofbartlett/solutions/line2tri.html">http://www.angelfire.com/fl/houseofbart ... e2tri.html</a><!-- m --><br />    <!-- m --><a class="postlink" href="http://www.stratos-ad.com/forums3/viewtopic.php?t=10076">http://www.stratos-ad.com/forums3/viewtopic.php?t=10076</a><!-- m --><br /><br />Un saludo grande.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=3">hugoruscitti</a> — Mié Sep 17, 2008 12:44 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bleed]]></name></author>
<updated>2008-09-16T21:33:33+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1667#p1667</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1667#p1667"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1667#p1667"><![CDATA[
Muchas gracias por contestar, David.<br /><br />No se me había ocurrido plantear así la solución, de todos modos, no me acaba quedado muy claro en que cosiste. Cuando tengas más tiempo, ya le echaremos un buen vistazo a tu algoritmo. Suerte con los exámenes y espero con ansia tu aportación.<br /><br />¡Un saludo!<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1977">Bleed</a> — Mar Sep 16, 2008 9:33 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2008-09-16T21:15:10+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1666#p1666</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1666#p1666"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1666#p1666"><![CDATA[
Hola no se si te servirá de mucho mi respuesta porque durante esta semana voy a ir bastante mal de tiempo por culta de los estudios. Yo estuve pensando algo así para un minigolf (pero aún no lo he implementado). Tuve la idea de dividir los polígonos en triángulos y así poder calcular si un punto (puede ser un vértice del cuadrado) está dentro de ese triángulo.<br />Lo siento pero no tengo más tiempo, esta semana es crucial para el resto del curso. Cuando la pase, con gusto te explico mi idea (que en teoría funciona, no la he probado) y escucho las de los demás a ver si entre todos encontramos la mejor manera.<br /><br />Saludos.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mar Sep 16, 2008 9:15 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Bleed]]></name></author>
<updated>2008-09-15T22:48:15+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1664#p1664</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1664#p1664"/>
<title type="html"><![CDATA[Pygame: Colisiones y áreas de desplazamiento..]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=379&amp;p=1664#p1664"><![CDATA[
Hola chicos.<br /><br />Este es mi primer mensaje en el foro y me parece que va a traer algo de guerra. No tengo mucho tiempo para dedicarme a esto, así que sólo puedo aprovechar los domingos y cuando las ganas me lo permiten. El problema que tengo está enfocado en otro contexto, pero he preparado un pequeño boceto para explicarlo mejor.<br /><br />Ejemplo gráfico:<br /><img src="http://img377.imageshack.us/img377/1091/project2pm1.png" alt="Imagen" /><br /><br />Lo que quiero hacer, es que un Sprite (el cuadrado rojo) se pueda mover por la pantalla y que cuando colisione con una línea se detenga. Conectando varias líneas limitaríamos el espacio por el cual puede desplazarse y por lo tanto, estaríamos definiendo las limitaciones de un mapa. Para entenderlo mejor, podéis ver la metáfora del Sprite dentro de una Isla.<br /><br />El problema es que no se muy bien por donde empezar... ¿Guardo en una lista que píxeles limitan el mapa (1 a 1) y antes de mover el Sprite compruebo si el pixel de destino es un limitador? ¿Cómo resolveríais vosotros este problema?.Os pido ayuda y orientación. Gracias.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1977">Bleed</a> — Lun Sep 15, 2008 10:48 pm</p><hr />
]]></content>
</entry>
</feed>