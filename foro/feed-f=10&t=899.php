<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=10&amp;t=899" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2010-11-08T15:38:49+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=10&amp;t=899</id>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2010-11-08T15:38:49+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4388#p4388</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4388#p4388"/>
<title type="html"><![CDATA[Re: gustavo el programador]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4388#p4388"><![CDATA[
<blockquote><div><cite>Juanxo escribió:</cite><br />vivan esas clases de algoritmica!! estaba claro que era bactracking... lo unico una duda: para que usas el 0? simplemente no hace falta tenerlo en cuenta a la hora de hacer los calculos, ya que no conoce el 0 ni ninguno más allá del 5<br /><br />EDITO: Voy a probar otro punto de vista. Mezcla de voraces y bactracking. Simplemente es ir cogiendo los numeros en orden (1,2,3,4,5) e ir añadiendo el numero actual a la suma, hasta que llegue al numero o me pase, momento en el que doy un paso atras en recursividad y cojo el siguiente:<br />por ejemplo para 3 sería<br />1<br />11<br />111 /* Es 3 luego paro y vuelvo atras */<br />112 /* Me he pasado, lo descarto y vuelvo atras */<br />12 /* Es 3 me vale, vuelvo atras */<br />121 /* Me he pasado, para atrás */<br />2<br />21 /* Me vale */<br /><br />ad infinitum xD<br /><br />EDITO LO EDITADO: He terminado mi algoritmo. Aquí pongo todo el código. He añadido lo de david para comparar llamadas recursivas y tiempo de ejecución.<br />En cuanto a diferencias, el tuyo está mejor porque no dependes de variables externas, a diferencia del mío.<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;vector&gt;<br />#include &lt;iostream&gt;<br />#include &lt;time.h&gt;<br /><br />typedef std::vector&lt;int&gt; Vi;<br /><br />int valores&#91;4&#93; = {1,1,2,3};<br />int numeros_conocidos&#91;4&#93; = {1,4,2,3};<br /><br />void numeros_gustavo(int&amp; iteraciones,int&amp; numeros, int numero_a_calcular, Vi&amp; numeros_usados, int&amp; suma)<br />{<br />  int pos_actual = 0;<br />  while(pos_actual &lt; 4 &amp;&amp; suma + valores&#91;pos_actual&#93; &lt;= numero_a_calcular)<br />  {<br />    <br />    // Anotar<br />    numeros_usados.push_back(numeros_conocidos&#91;pos_actual&#93;);<br />    suma += valores&#91;pos_actual&#93;;<br /><br />    numeros_gustavo(++iteraciones,numeros,numero_a_calcular, numeros_usados, suma);<br />      <br />    //Desanotar<br />    suma -= valores&#91;pos_actual&#93;;<br />    numeros_usados.pop_back();<br />    pos_actual++;<br />  }<br />  if (suma == numero_a_calcular)<br />  {<br />    numeros++;<br />    pos_actual = 4;<br />  }<br />}<br /><br />const int DigsGus&#91;&#93;= {0,1,1,2,3};<br />const int NDigGus = 5;<br /><br />bool suma_n(const Vi&amp; v, int n) {<br />  int suma = 0;<br />  for (int i = 0; i &lt; v.size(); i++) {<br />    suma += v&#91;i&#93;;<br />  }<br />  return suma == n;<br />}<br /><br />int numerosGus(int&amp; iteraciones, Vi&amp; v, int i, int n) {<br />  if (i == n) {<br />    return suma_n(v, n);<br />  }<br />  int nums = 0;<br />  int j = 0;<br />  if (v&#91;std::max(i-1,0)&#93; != 0) ++j;<br />  while (j &lt; NDigGus) {<br />    v&#91;i&#93; = DigsGus&#91;j&#93;;<br />    nums += numerosGus(++iteraciones,v, i+1, n);<br />    ++j;<br />  }<br />  return nums;<br />}<br /><br /><br />int main(int argc, char* argv&#91;&#93;)<br />{<br />  int numero_a_calcular;<br />  time_t tiempo, differ;<br />  while( std::cin &gt;&gt; numero_a_calcular)<br />  {<br />    int numeros = 0, numeros2 = 0;<br />    <br />    int suma_acumulada = 0;<br />    int iteraciones = 0, iteraciones2 = 0;<br /><br />    Vi numeros_usados, numeros_usados2(numero_a_calcular, 0);<br />    numeros_usados.reserve(numero_a_calcular + 10);<br /><br />    <br />    tiempo = time(NULL);<br />    numeros_gustavo(iteraciones,numeros, numero_a_calcular, numeros_usados, suma_acumulada );<br />    differ = time(NULL) - tiempo;<br />    std::cout &lt;&lt; &quot;ITERACIONES Juan: &quot; &lt;&lt; iteraciones &lt;&lt; &quot; NUMEROS: &quot; &lt;&lt; numeros &lt;&lt;<br />      &quot; TIEMPO: &quot; &lt;&lt; differ &lt;&lt; std::endl;<br /><br />    tiempo = time(NULL);<br />    numeros2 = numerosGus(iteraciones2, numeros_usados2, 0, numero_a_calcular);<br />    differ = time(NULL) - tiempo;<br />    std::cout &lt;&lt; &quot;ITERACIONES David: &quot;&lt;&lt; iteraciones2 &lt;&lt;  &quot; NUMEROS: &quot; &lt;&lt; numeros2 &lt;&lt;<br />      &quot; TIEMPO: &quot; &lt;&lt; differ &lt;&lt; std::endl;<br />  }<br />}<br /></code></dd></dl><br /></div></blockquote><br />Bueno, a simple vista parece que el tuyo hará menos ciclos, tampoco importa mucho si en un programa de estos hay variables globales. Aunque la idea de mi código era hacer una base para que luego lo mejorase xD<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Lun Nov 08, 2010 3:38 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[carlostex]]></name></author>
<updated>2010-10-16T05:32:59+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4271#p4271</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4271#p4271"/>
<title type="html"><![CDATA[Re: gustavo el programador]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4271#p4271"><![CDATA[
Gracias por responder, ya tenia pensado una solucion, muy parecida a las dos, por fuerza bruta, pero no habia podido implementarla ni en matlab por falta de tiempo.<br />Es este caso la mejor solución es la que se pueda pensar e implementar mas rapido, pues para resolver ese problema teniamos como media hora.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2124">carlostex</a> — Sab Oct 16, 2010 5:32 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[Juanxo]]></name></author>
<updated>2010-10-13T23:43:43+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4264#p4264</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4264#p4264"/>
<title type="html"><![CDATA[Re: gustavo el programador]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4264#p4264"><![CDATA[
vivan esas clases de algoritmica!! estaba claro que era bactracking... lo unico una duda: para que usas el 0? simplemente no hace falta tenerlo en cuenta a la hora de hacer los calculos, ya que no conoce el 0 ni ninguno más allá del 5<br /><br />EDITO: Voy a probar otro punto de vista. Mezcla de voraces y bactracking. Simplemente es ir cogiendo los numeros en orden (1,2,3,4,5) e ir añadiendo el numero actual a la suma, hasta que llegue al numero o me pase, momento en el que doy un paso atras en recursividad y cojo el siguiente:<br />por ejemplo para 3 sería<br />1<br />11<br />111 /* Es 3 luego paro y vuelvo atras */<br />112 /* Me he pasado, lo descarto y vuelvo atras */<br />12 /* Es 3 me vale, vuelvo atras */<br />121 /* Me he pasado, para atrás */<br />2<br />21 /* Me vale */<br /><br />ad infinitum xD<br /><br />EDITO LO EDITADO: He terminado mi algoritmo. Aquí pongo todo el código. He añadido lo de david para comparar llamadas recursivas y tiempo de ejecución.<br />En cuanto a diferencias, el tuyo está mejor porque no dependes de variables externas, a diferencia del mío.<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;vector&gt;<br />#include &lt;iostream&gt;<br />#include &lt;time.h&gt;<br /><br />typedef std::vector&lt;int&gt; Vi;<br /><br />int valores&#91;4&#93; = {1,1,2,3};<br />int numeros_conocidos&#91;4&#93; = {1,4,2,3};<br /><br />void numeros_gustavo(int&amp; iteraciones,int&amp; numeros, int numero_a_calcular, Vi&amp; numeros_usados, int&amp; suma)<br />{<br />  int pos_actual = 0;<br />  while(pos_actual &lt; 4 &amp;&amp; suma + valores&#91;pos_actual&#93; &lt;= numero_a_calcular)<br />  {<br />    <br />    // Anotar<br />    numeros_usados.push_back(numeros_conocidos&#91;pos_actual&#93;);<br />    suma += valores&#91;pos_actual&#93;;<br /><br />    numeros_gustavo(++iteraciones,numeros,numero_a_calcular, numeros_usados, suma);<br />      <br />    //Desanotar<br />    suma -= valores&#91;pos_actual&#93;;<br />    numeros_usados.pop_back();<br />    pos_actual++;<br />  }<br />  if (suma == numero_a_calcular)<br />  {<br />    numeros++;<br />    pos_actual = 4;<br />  }<br />}<br /><br />const int DigsGus&#91;&#93;= {0,1,1,2,3};<br />const int NDigGus = 5;<br /><br />bool suma_n(const Vi&amp; v, int n) {<br />  int suma = 0;<br />  for (int i = 0; i &lt; v.size(); i++) {<br />    suma += v&#91;i&#93;;<br />  }<br />  return suma == n;<br />}<br /><br />int numerosGus(int&amp; iteraciones, Vi&amp; v, int i, int n) {<br />  if (i == n) {<br />    return suma_n(v, n);<br />  }<br />  int nums = 0;<br />  int j = 0;<br />  if (v&#91;std::max(i-1,0)&#93; != 0) ++j;<br />  while (j &lt; NDigGus) {<br />    v&#91;i&#93; = DigsGus&#91;j&#93;;<br />    nums += numerosGus(++iteraciones,v, i+1, n);<br />    ++j;<br />  }<br />  return nums;<br />}<br /><br /><br />int main(int argc, char* argv&#91;&#93;)<br />{<br />  int numero_a_calcular;<br />  time_t tiempo, differ;<br />  while( std::cin &gt;&gt; numero_a_calcular)<br />  {<br />    int numeros = 0, numeros2 = 0;<br />    <br />    int suma_acumulada = 0;<br />    int iteraciones = 0, iteraciones2 = 0;<br /><br />    Vi numeros_usados, numeros_usados2(numero_a_calcular, 0);<br />    numeros_usados.reserve(numero_a_calcular + 10);<br /><br />    <br />    tiempo = time(NULL);<br />    numeros_gustavo(iteraciones,numeros, numero_a_calcular, numeros_usados, suma_acumulada );<br />    differ = time(NULL) - tiempo;<br />    std::cout &lt;&lt; &quot;ITERACIONES Juan: &quot; &lt;&lt; iteraciones &lt;&lt; &quot; NUMEROS: &quot; &lt;&lt; numeros &lt;&lt;<br />      &quot; TIEMPO: &quot; &lt;&lt; differ &lt;&lt; std::endl;<br /><br />    tiempo = time(NULL);<br />    numeros2 = numerosGus(iteraciones2, numeros_usados2, 0, numero_a_calcular);<br />    differ = time(NULL) - tiempo;<br />    std::cout &lt;&lt; &quot;ITERACIONES David: &quot;&lt;&lt; iteraciones2 &lt;&lt;  &quot; NUMEROS: &quot; &lt;&lt; numeros2 &lt;&lt;<br />      &quot; TIEMPO: &quot; &lt;&lt; differ &lt;&lt; std::endl;<br />  }<br />}<br /></code></dd></dl><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2057">Juanxo</a> — Mié Oct 13, 2010 11:43 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[endaramiz]]></name></author>
<updated>2010-10-13T12:40:09+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4262#p4262</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4262#p4262"/>
<title type="html"><![CDATA[Re: gustavo el programador]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4262#p4262"><![CDATA[
Hola. Lo he resuelto con una técnica no muy eficiente: <a href="http://es.wikipedia.org/wiki/Vuelta_Atr%C3%A1s" class="postlink">backtraking</a>. Esto se encarga de probar todos los casos. Pero la gracia consiste en que cuando una rama del árbol no te interesa (intuyes que no va a dar un buen resultado) puede volver hacia atrás y dejar de comprobar todos esos casos. Por ejemplo yo &quot;podo&quot; (creo que es el término) los números que tienen un 0 después de un dígito que no es 0 ( Gus no conoce el 0). En este caso, también puedes hacer poda cuando ves que el número ya supera lo que tiene que sumar, ya que la suma final será igual o superior a la actual. Aunque los cálculos para saber cuando hay que hacer poda tienen que ser eficientes, sino es contraproducente. Te lo dejo como ejercicio. Ya dirás que tal te sale.<br /><br />Si te gusta el tema, puedes apuntarte a webs como <a href="http://www.olimpiada-informatica.org/" class="postlink">OIE</a> que tienen enunciados y un corrector automático (el odiado por muchos Jutge xD). Aunque quizás ya conozcas alguna (los enunciados suelen ser como la imagen que has subido).<br /><br />Siento el retraso.<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;iostream&gt;<br />#include &lt;vector&gt;<br />using namespace std;<br /><br />typedef vector&lt;int&gt; Vi;<br /><br />const int DigsGus&#91;&#93;= {0,1,1,2,3};<br />const int NDigGus = 5;<br /><br />bool suma_n(const Vi&amp; v, int n) {<br />    int suma = 0;<br />    for (int i = 0; i &lt; v.size(); i++) {<br />        suma += v&#91;i&#93;;<br />    }<br />    return suma == n;<br />}<br /><br />int numerosGus(Vi&amp; v, int i, int n) {<br />    if (i == n) {<br />        return suma_n(v, n);<br />    }<br />    int nums = 0;<br />    int j = 0;<br />    if (v&#91;max(i-1,0)&#93; != 0) ++j;<br />    while (j &lt; NDigGus) {<br />        v&#91;i&#93; = DigsGus&#91;j&#93;;<br />        nums += numerosGus(v, i+1, n);<br />        ++j;<br />    }<br />    return nums;<br />}<br /><br />int main() {<br />    int n;<br />    while (cin &gt;&gt; n) {<br />        Vi v(n,0);<br />        cout &lt;&lt; numerosGus(v, 0, n) &lt;&lt; endl;<br />    }<br />}</code></dd></dl><br /><br />PD: si no entiendes algo del código, no dudes en preguntar y haré una explicación más profunda (no la he hecho ahora porque no sé tu nivel).<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=1809">endaramiz</a> — Mié Oct 13, 2010 12:40 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[carlostex]]></name></author>
<updated>2010-10-03T07:37:37+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4219#p4219</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4219#p4219"/>
<title type="html"><![CDATA[gustavo el programador]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=899&amp;p=4219#p4219"><![CDATA[
hola, esto no tiene que ver con videojuegos pero si con programación y algoritmia. Tengo el siguiente problema.<br />(ver imagen adjunta)<br />He intentado resolverlo en los ratos que tuve librey tambien con unos amigos, pero no lo consegui, aver si alguien se le ocurre algo.<br />Es todo un reto.<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2124">carlostex</a> — Dom Oct 03, 2010 7:37 am</p><hr />
]]></content>
</entry>
</feed>