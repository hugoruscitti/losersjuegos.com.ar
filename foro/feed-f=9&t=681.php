<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=681" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2010-01-21T21:30:44+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=9&amp;t=681</id>
<entry>
<author><name><![CDATA[carlostex]]></name></author>
<updated>2010-01-21T21:30:44+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3198#p3198</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3198#p3198"/>
<title type="html"><![CDATA[Problema solucionado]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3198#p3198"><![CDATA[
Les comento que ya soluciones el problema, mi error estaba en el enfoque que seguí, pues lo que hacia en el código anterior era localizar a que distancia se encuentra el punto de referencia de la imagen rotada. y por la forma en la que la función que rota pone la imagen en la superficie el problema carece de simetría.<br />Pero vi en otro hilo que alguien quería hacer lo mismo, y mencionaba que el único punto mas fácil de obtener es el centro, luego mover el centro al lugar que se desee, pues seguí esa idea base, y en cuestión de minutos ya tenia la función lista, como verán es mas elegante y simple.<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>/*<br /> * Archivo: rotacion_x_ref.cpp<br /> * Carlos Villanueva<br /> */<br /><br />#include&lt;SDL/SDL.h&gt;<br /><br /><br />#include&lt;math.h&gt;<br />#include&lt;SDL/SDL_rotozoom.h&gt;<br />#include&lt;iostream&gt;<br />#define PI 3.14159265<br />using namespace std;<br /><br />float angulo &#40;int x1, int y1, int x2, int y2&#41;<br />&#123;<br />    float ppunto, longv1, longv2;<br />    ppunto = x1 * x2 + y1 * y2;<br />    longv1 = sqrt &#40;&#40;x1 * x1&#41; + &#40;y1 * y1&#41;&#41;;<br />    longv2 = sqrt &#40;&#40;x2 * x2&#41; + &#40;y2 * y2&#41;&#41;;<br />    if &#40;x1 == 0 &amp;&amp; y1 == 0&#41;<br />         return 0;<br />    else<br />         return acos &#40;ppunto / &#40;longv1 * longv2&#41;&#41;;<br /><br />&#125;<br /><br />float to_rad&#40;int ang&#41;<br />&#123;<br />   return ang*PI/180;<br />&#125;<br /><br />float to_ang&#40;float rad&#41;<br />&#123;<br />   return rad*180/PI;<br />&#125;<br /><br />Uint32 time_inicio, time_actual;<br />void reset_time &#40;&#41;<br />&#123;<br /><br />    time_inicio = SDL_GetTicks &#40;&#41;;<br />&#125;<br /><br />Uint32 current_time &#40;&#41;<br />&#123;<br />    time_actual = SDL_GetTicks &#40;&#41;;<br />    return time_actual - time_inicio;<br /><br />&#125;<br /><br />void rotar_ref&#40;SDL_Surface *src, SDL_Surface *dest, float ang, int pos_x, int pos_y, int x_ref, int y_ref&#41;<br />&#123;<br />   <br />   SDL_Rect punto;<br />   SDL_Surface *src_rot;<br />   src_rot=rotozoomSurface &#40;src, ang, 1, 1&#41;;<br />   float ancho=src-&gt;w;<br />   <br />   float largo_bar=ancho/2-x_ref;<br />    <br />   punto.x=pos_x;//coordenada donde se situa el punto de referencia<br />   punto.y=pos_y;<br />     <br />   punto.x=punto.x-src_rot-&gt;w/2+largo_bar*cos&#40;to_rad&#40;ang&#41;&#41;;<br />   punto.y=punto.y-src_rot-&gt;h/2-largo_bar*sin&#40;to_rad&#40;ang&#41;&#41;;<br />      <br />   SDL_BlitSurface&#40;src_rot, NULL, dest, &amp;punto&#41;;  <br />   <br />&#125;<br /><br /><br /><br />int main &#40;&#41;<br />&#123;<br /><br />    SDL_Surface *image, *screen;<br /><br />            <br /><br />    SDL_Event event;<br />    int done = 0;<br />   SDL_Rect pos, dest, eje;<br />   dest.y=dest.x=0;<br />   dest.w = 640;<br />    dest.h = 480;<br />    atexit &#40;SDL_Quit&#41;;<br /><br />    // Iniciar SDL<br />    if &#40;SDL_Init &#40;SDL_INIT_VIDEO&#41; &lt; 0&#41;<br />    &#123;<br />         printf &#40;&quot;No se pudo iniciar SDL: %s\n&quot;, SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br /><br />    // Activamos modo de video<br />    screen = SDL_SetVideoMode &#40;640, 480, 32, SDL_HWSURFACE&#41;;<br />    if &#40;screen == NULL&#41;<br />    &#123;<br />         printf &#40;&quot;No se puede inicializar el modo gráfico: %s\n&quot;,<br />                     SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br /><br /><br />    // Cargamos gráfico<br />    image = SDL_LoadBMP &#40;&quot;canyon.bmp&quot;&#41;;<br />    if &#40;image == NULL&#41;<br />    &#123;<br />         printf &#40;&quot;No pude cargar gráfico: %s\n&quot;, SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br />    <br />    <br />    <br />    eje.x=4;//Puntos de referencia en la imagen<br />    eje.y=8;<br />   for &#40;float i=0;i&lt;=360.0;i+=1.0&#41;&#123;<br />    reset_time&#40;&#41;;<br />    pos.x=100;//posicion donde se imprimira la imagen de prueba sin rotacion<br />    pos.y=100;<br />    pos.x-=eje.x;<br />    pos.y-=eje.y;     <br />    SDL_FillRect &#40;screen, &amp;dest, SDL_MapRGB &#40;screen-&gt;format, 0, 0, 0&#41;&#41;;   <br />    SDL_BlitSurface&#40;image, NULL, screen, &amp;pos&#41;;  <br />    rotar_ref&#40;image, screen,i,100,100,eje.x,eje.y&#41;;//repetir aca las coordenadas donde se imprimira<br />    <br />    SDL_Flip&#40;screen&#41;;<br />    while&#40;current_time&#40;&#41;&lt;40&#41;;<br />   &#125;<br /><br /><br /><br />    while &#40;done == 0&#41;<br />    &#123;<br />       <br />       <br />         while &#40;SDL_PollEvent &#40;&amp;event&#41;&#41;<br />         &#123;<br />             if &#40;event.type == SDL_KEYDOWN&#41;<br />                  done = 1;<br />         &#125;<br />         <br />   <br />    &#125;<br />&#125;<br /></code></dd></dl><br /><br /><br />Pueden usar cualquier imagen, espero le sirva a alguien, haora con esto voy hacer una implementacion en C++ y SDL parecida a artillery<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2124">carlostex</a> — Jue Ene 21, 2010 9:30 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[carlostex]]></name></author>
<updated>2010-01-20T23:29:28+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3197#p3197</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3197#p3197"/>
<title type="html"><![CDATA[Rotacion de imagenes con respecto a un punto en SDL]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=681&amp;p=3197#p3197"><![CDATA[
Que tal, pues he desarrollado una función para rotar una imagen con respecto a un punto fijo de la misma, use rotozoom de SDL_gfx para hacer la rotación y luego calculo la posición en la que se debe situar para que quede como debe.<br /><br />el código es el sig:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>/*<br /> * Archivo: rotacion_x_ref.cpp<br /> * Carlos Villanueva<br /> */<br /><br />#include&lt;SDL&gt;<br />#include&lt;math&gt;<br />#include&lt;SDL&gt;<br />#include&lt;iostream&gt;<br />#define PI 3.14159265<br />using namespace std;<br /><br />float angulo &#40;int x1, int y1, int x2, int y2&#41;<br />&#123;<br />    float ppunto, longv1, longv2;<br />    ppunto = x1 * x2 + y1 * y2;<br />    longv1 = sqrt &#40;&#40;x1 * x1&#41; + &#40;y1 * y1&#41;&#41;;<br />    longv2 = sqrt &#40;&#40;x2 * x2&#41; + &#40;y2 * y2&#41;&#41;;<br />    if &#40;x1 == 0 &amp;&amp; y1 == 0&#41;<br />         return 0;<br />    else<br />         return acos &#40;ppunto / &#40;longv1 * longv2&#41;&#41;;<br /><br />&#125;<br /><br />float to_rad&#40;int ang&#41;<br />&#123;<br />   return ang*PI/180;<br />&#125;<br /><br />float to_ang&#40;float rad&#41;<br />&#123;<br />   return rad*180/PI;<br />&#125;<br /><br />int mod2 &#40;int x, int y&#41;<br />&#123;<br />    return sqrt &#40;x * x + y * y&#41;;<br /><br />&#125;<br /><br />int dist&#40;int x1, int y1, int x2, int y2&#41;<br />&#123;<br />   return mod2&#40;x2-x1,y2-y1&#41;;<br />   <br />&#125;<br /><br />Uint32 time_inicio, time_actual;<br />void reset_time &#40;&#41;<br />&#123;<br /><br />    time_inicio = SDL_GetTicks &#40;&#41;;<br />&#125;<br /><br />Uint32 current_time &#40;&#41;<br />&#123;<br />    time_actual = SDL_GetTicks &#40;&#41;;<br />    return time_actual - time_inicio;<br /><br />&#125;<br /><br />void rotar_ref&#40;SDL_Surface *src, SDL_Surface *dest, float ang, int pos_x, int pos_y, int x_ref, int y_ref&#41;<br />&#123;<br />   <br />   SDL_Rect punto, dest1, ref;<br />   SDL_Surface *src_rot;<br />   src_rot=rotozoomSurface &#40;src, ang, 1, 1&#41;;<br />    float ancho=src-&gt;w;<br />    float alto=src-&gt;h;<br />   <br />    dest1.y=dest1.x=0;<br />    punto.x=pos_x;//coordenada donde se sitia el grafico a girar<br />    punto.y=pos_y;<br />     <br />    ref.x=x_ref;//coordenada del punto de referencia con respecto a la imagen<br />    ref.y=y_ref;<br />    float largo=mod2&#40;ref.x, ref.y&#41;;<br />    int cuadrante=ang/90;<br />   <br />    float phi1, phi2, phi3, rho;<br />   <br />   switch&#40;cuadrante&#41;<br />   &#123;<br />      case 0:<br />      //Giro para angulos de 0 a 89<br />      phi1=to_ang&#40;acos&#40;ref.y/largo&#41;&#41;+ang;<br />      <br />    punto.y-=ancho*sin&#40;to_rad&#40;ang&#41;&#41;-ref.y+largo*cos&#40;to_rad&#40;phi1&#41;&#41;;<br />    punto.x-=largo*sin&#40;to_rad&#40;phi1&#41;&#41;-ref.x;<br />      break;<br />      case 1:<br />       //giro para angulos de 90 a 180<br />     phi3=to_ang&#40;acos&#40;ref.x/largo&#41;&#41;+180.0-ang;<br />     rho=to_ang&#40;acos&#40;ref.x/largo&#41;&#41;;<br />     punto.x-=ancho*cos&#40;to_rad&#40;180.0-ang&#41;&#41;-ref.x-largo*cos&#40;to_rad&#40;phi3&#41;&#41;;<br />     punto.y-=ancho*sin&#40;to_rad&#40;180.0-ang&#41;&#41;+largo*sin&#40;to_rad&#40;ang-90&#41;&#41;-ref.y;<br />     //punto.y-=&#40;ancho*sin&#40;to_rad&#40;180-ang&#41;&#41;-largo*cos&#40;to_rad&#40;rho&#41;&#41;-largo*sin&#40;to_rad&#40;180-ang&#41;&#41;&#41;*sin&#40;to_rad&#40;180-ang&#41;&#41;-ref.y;<br />     ;<br />      break;<br />      <br />      case 2:<br />      <br />       //giro para angulos de 181 a 270<br />     phi2=to_ang&#40;acos&#40;ref.x/largo&#41;&#41;-180.0+ang;<br />   <br />     punto.x-=ancho*cos&#40;to_rad&#40;180.0+ang&#41;&#41;-ref.x-largo*cos&#40;to_rad&#40;phi2&#41;&#41;;<br />     punto.y+=ref.y-largo*sin&#40;to_rad&#40;phi2&#41;&#41;;<br />     break;<br />      case 3:<br />      //giro para angulos de 271 a 359<br />      <br />     phi1=to_ang&#40;atan&#40;ref.x/ref.y&#41;&#41;+ang-270.0;<br />     <br />     punto.x-=alto*cos&#40;to_rad&#40;ang-270.0&#41;&#41;-largo*cos&#40;to_rad&#40;phi1&#41;&#41;-ref.x;<br />     punto.y+=ref.y-largo*sin&#40;to_rad&#40;phi1&#41;&#41;;<br />      <br />   &#125;    <br />     SDL_BlitSurface&#40;src_rot, NULL, dest, &amp;punto&#41;;  <br />   <br />&#125;<br /><br /><br /><br />int main &#40;&#41;<br />&#123;<br /><br />    SDL_Surface *image, *screen;<br /><br />            <br /><br />    SDL_Event event;<br />    int done = 0;<br />   SDL_Rect pos, dest;<br />   dest.y=dest.x=0;<br />   dest.w = 640;<br />    dest.h = 480;<br />    atexit &#40;SDL_Quit&#41;;<br /><br />    // Iniciar SDL<br />    if &#40;SDL_Init &#40;SDL_INIT_VIDEO&#41; &lt; 0&#41;<br />    &#123;<br />         printf &#40;&quot;No se pudo iniciar SDL: %s\n&quot;, SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br /><br />    // Activamos modo de video<br />    screen = SDL_SetVideoMode &#40;640, 480, 32, SDL_HWSURFACE&#41;;<br />    if &#40;screen == NULL&#41;<br />    &#123;<br />         printf &#40;&quot;No se puede inicializar el modo gráfico: %s\n&quot;,<br />                     SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br /><br /><br />    // Cargamos gráfico<br />    image = SDL_LoadBMP &#40;&quot;rect.bmp&quot;&#41;;//Nombre del archivo de la imagen BMP<br />    if &#40;image == NULL&#41;<br />    &#123;<br />         printf &#40;&quot;No pude cargar gráfico: %s\n&quot;, SDL_GetError &#40;&#41;&#41;;<br />         exit &#40;1&#41;;<br />    &#125;<br />    <br />    //pos.x=pos.y=50;   <br />    for&#40;float i=0;i&lt;360&gt;format, 0, 0, 0&#41;&#41;;   <br />   //SDL_BlitSurface&#40;image, NULL, screen, &amp;pos&#41;;  <br />    rotar_ref&#40;image, screen,i,50,50,0,image-&gt;h/2&#41;;//imagen a rotar, destino, angulo,posicion en x donde se pondrá, posición en y donde se pondra, coordenadas de referencia a rotar<br />    <br />    SDL_Flip&#40;screen&#41;;<br />    while&#40;current_time&#40;&#41;&lt;10&#41;;<br />   &#125;<br /><br /><br /><br />    while &#40;done == 0&#41;<br />    &#123;<br />       <br />       <br />         while &#40;SDL_PollEvent &#40;&amp;event&#41;&#41;<br />         &#123;<br />             if &#40;event.type == SDL_KEYDOWN&#41;<br />                  done = 1;<br />         &#125;<br />         <br />   <br />    &#125;<br />&#125;<br /></code></dd></dl><br /><br /><br />rotozoom lo que hace es girar la imagen pero la citua de diferentes formas segun el angulo, siempre la pega a la esquina superior izquierda.<br />Pero creo que tiene algun error las operaciones matematicas, todo va bien, si el punto 'y' de referencia esta a la mitad del alto de la imagen, y 'x' es cero, si lo cambio empieza a haber un cierto movimiento aveces es brusco.<br />pero solo sucede para angulos de 90 a 179 y de 270 a 360<br /><br /><br />Espero que me puedan ayudar a corregir el problema o tambien otra solucion que conozcan.<br /><br /><br />Usé una imagen de un rectangulo para probar, se aprecia mejor<br /><br />agregar -lSDL -lSDL_gfx en las opciones del compilador<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=2124">carlostex</a> — Mié Ene 20, 2010 11:29 pm</p><hr />
]]></content>
</entry>
</feed>