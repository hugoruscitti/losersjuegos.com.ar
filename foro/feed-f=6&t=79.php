<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="es">
<link rel="self" type="application/atom+xml" href="http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=79" />

<title>LosersJuegos</title>
<subtitle>Desarrollando videojuegos libres</subtitle>
<link href="http://losersjuegos.com.ar/foro/index.php" />
<updated>2007-04-22T18:26:32+00:00</updated>

<author><name><![CDATA[LosersJuegos]]></name></author>
<id>http://losersjuegos.com.ar/foro/feed.php?f=6&amp;t=79</id>
<entry>
<author><name><![CDATA[rcaf]]></name></author>
<updated>2007-04-22T18:26:32+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=280#p280</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=280#p280"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=280#p280"><![CDATA[
<blockquote><div><cite>astut escribió:</cite><br />Muchas gracias, ¿y como hacer que la imagen valla hacia las coordenadas del raton?<br /></div></blockquote><br /><br />¿Cómo un proyectil dirigido? y ¿Qué se mueva de forma automática?<br /><br />Si es así, solo debes mover la imagen en cada ciclo hacia el objetivo que serán las coordenadas del mouse. <br /><br />Ya tenemos calculado el ángulo entre los dos vectores (la imagen y el puntero del mouse), por lo tanto en el ciclo del juego deberías realizar algo como esto:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code><br />// Guardará la posición del mouse<br />int mouse_x, mouse_y;<br /><br />// Obtenemos posición actual del mouse<br />SDL_GetMouseState&#40;&amp;mouse_x, &amp;mouse_y&#41;;<br /><br />// &#40;cx, cy&#41; coordenadas del centro de la imagen<br />int distancia_x = mouse_x - cx;<br />int distancia_y = mouse_y - cy;<br /><br />// Si el puntero del mouse está fuera del área de la imagen<br />// obtenemos el ángulo entre los dos vectores<br />// ancho_imagen, alto_imagen dimensiones de la imagen<br />if&#40;abs&#40;distancia_x&#41; &gt; ancho_imagen || abs&#40;distancia_y&#41; &gt; alto_imagen&#41;<br />&#123;<br />    angulo = &#40;atan2&#40;distancia_y, distancia_x&#41; * 180&#41; / PI;<br />    mover_imagen=1; // la imagen se debe mover<br />&#125; <br />else mover_imagen=0; // la imagen se detiene<br /><br />// La imagen solo se mueve cuando el puntero del mouse está fuera<br />// del área de la imagen<br />if&#40;mover_imagen&#41;<br />&#123;<br />   if &#40;speed &lt;= 10&#41; speed += 0.3;<br />&#125;<br />// El movimiento de la imagen se detiene cuando llega a su objetivo <br />// es decir, el puntero del mouse se encuentra dentro del área de<br />// la imagen<br />else <br />&#123;<br />   speed=0;    <br />&#125;<br /><br />// Calcula la coordenada x e y del vector velocidad<br />vel.x = speed * cos&#40;angulo*PI/180&#41;;<br />vel.y = speed * sin&#40;angulo*PI/180&#41;;<br /><br />// Movemos la imagen<br />pos.x += vel.x;<br />pos.y += vel.y;<br /></code></dd></dl><br /><br />En el código anterior suponemos que tenemos una variable <span style="font-weight: bold">speed</span> que contiene la longitud del vector velocidad, una estructura llamada <span style="font-weight: bold">vel</span> con dos componentes x e y para almacenar el vector velocidad de la imagen, y por último otra estructura <span style="font-weight: bold">pos</span> con las componentes x e y para almacenar el vector posición de la imagen.<br /><br />Saludos!<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=8">rcaf</a> — Dom Abr 22, 2007 6:26 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[astut]]></name></author>
<updated>2007-04-22T10:36:12+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=279#p279</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=279#p279"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=279#p279"><![CDATA[
Muchas gracias, ¿y como hacer que la imagen valla hacia las coordenadas del raton?<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=893">astut</a> — Dom Abr 22, 2007 10:36 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[rcaf]]></name></author>
<updated>2007-04-22T05:44:10+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=278#p278</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=278#p278"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=278#p278"><![CDATA[
El código que publicó Hugo está bien, excepto algunos detalles que noté:<br /><br />Primero, la llamada a la función <span style="font-weight: bold">GetMouseState</span> se encuentra con las variables incorrectas, debe ser:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>SDL_GetMouseState&#40;&amp;mouse_x, &amp;mouse_y&#41;; <br /></code></dd></dl><br /><br />Segundo, el cálculo del ángulo entre los dos vectores se debe realizar sin el valor absoluto, ya que al usar <span style="font-weight: bold">abs()</span> estamos limitando el movimiento de la imagen solo a un cuadrante, por lo tanto el cálculo debería ser de la siguiente forma:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>distancia_x = mouse_x - cx;<br />distancia_y = mouse_y - cy;<br /><br />angulo = &#40;atan2&#40;distancia_y, distancia_x&#41; * 180&#41; / PI; <br /></code></dd></dl><br /><br />Por último una acotación, podrías agregar una condición para que cambie el ángulo solo cuando el puntero del mouse se encuentre fuera del área de la imagen, es decir:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>distancia_x = mouse_x - cx;<br />distancia_y = mouse_y - cy;<br /><br />// En este caso si utilizamos valor absoluto<br />if&#40;abs&#40;distancia_x&#41; &gt; ancho_imagen || abs&#40;distancia_y&#41; &gt; alto_imagen&#41;<br />&#123;<br />  angulo = &#40;atan2&#40;distancia_y, distancia_x&#41; * 180&#41; / PI; <br />&#125;<br /></code></dd></dl><br /><br />Resumiendo, el código general en el ciclo de eventos debería quedar así:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>if &#40;evento.type == SDL_MOUSEMOTION&#41;<br />&#123;<br />  // Obtenemos posición actual del mouse<br />  int mouse_x=evento.motion.x;<br />  int mouse_y=evento.motion.y;<br /><br />  // &#40;cx, cy&#41; coordenadas del centro de la imagen<br />  int distancia_x = mouse_x - cx;<br />  int distancia_y = mouse_y - cy;<br /><br />  // Si el puntero del mouse está fuera del área de la imagen<br />  // obtenemos el ángulo entre los dos vectores<br />  // ancho_imagen, alto_imagen dimensiones de la imagen<br />  if&#40;abs&#40;distancia_x&#41; &gt; ancho_imagen || abs&#40;distancia_y&#41; &gt; alto_imagen&#41;<br />  &#123;<br />      angulo = &#40;atan2&#40;distancia_y, distancia_x&#41; * 180&#41; / PI; <br />  &#125;<br />&#125;<br /></code></dd></dl><br /><br />o utilizando mouse polling:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>// Guardará la posición del mouse<br />int mouse_x, mouse_y;<br /><br />// Obtenemos posición actual del mouse<br />SDL_GetMouseState&#40;&amp;mouse_x, &amp;mouse_y&#41;;<br /><br />// &#40;cx, cy&#41; coordenadas del centro de la imagen<br />int distancia_x = mouse_x - cx;<br />int distancia_y = mouse_y - cy;<br /><br />// Si el puntero del mouse está fuera del área de la imagen<br />// obtenemos el ángulo entre los dos vectores<br />// ancho_imagen, alto_imagen dimensiones de la imagen<br />if&#40;abs&#40;distancia_x&#41; &gt; ancho_imagen || abs&#40;distancia_y&#41; &gt; alto_imagen&#41;<br />&#123;<br />    angulo = &#40;atan2&#40;distancia_y, distancia_x&#41; * 180&#41; / PI; <br />&#125;<br /></code></dd></dl><br /><br />Saludos!<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=8">rcaf</a> — Dom Abr 22, 2007 5:44 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[hugoruscitti]]></name></author>
<updated>2007-04-22T03:37:53+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=277#p277</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=277#p277"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=277#p277"><![CDATA[
Saludos,<br /><br />Pienso que el problema de la 'deformación' que sufren los gráficos al ser<br />modificados es a causa de como están compuestas las imágenes. Como indica uno de<br />los tutoriales de RCAF[1], cada imagen está compuesta de diferentes pixeles y<br />una transformación como la rotación 'reordena' dichos pixeles en nuevas<br />posiciones y esto generalmente no es reversible.<br /><br />En tu función 'CfgAngulo' la transformación de rotación se realiza todo el<br />tiempo sobre la misma imagen, por lo tanto cada transformación deteriora aún<br />mas la imagen original, mira este ejemplo:<br /><br /><img src="http://www.losersjuegos.com.ar/incoming/temporales/rotacion.png" alt="Imagen" /><br /><br />en el primer caso se muestra el deterioro que sufre una superficie cuando se<br />'transforma' muchas veces sobre sí misma, como lo hace tu método. En cambio, el <br />segundo caso muestra como quedan las rotaciones cuando <br />se calculan a partir de la imagen original, como lo realiza la función de RCAF<br />(DrawSurface). <br /><br />Como sugerencia te recomiendo que utilices la función que desarrolló RCAF o <br />tengas en cuenta este detalle para modificar el funcionamiento del método <br />'CfgAngulo', la idea del cambio sería 'calcular la rotación desde el cuadro<br />original sin alterarlo'.<br /><br /><br /><blockquote class="uncited"><div><br />bueno, ahora pretendo que el angulo de la imagen apunte hacia la posicion del<br />raton<br /></div></blockquote><br /><br />En este caso, tendrías que calcular el ángulo que determinan el centro de la<br />imagen (x, y) y la posición del punto (mouse_x, mouse_y). Para ello podrías<br />utilizan la función trigonométrica 'arco-tangente'. Sería algo así:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>#include &lt;math.h&gt;<br />#define PI 3.1415927<br /><br />void dibujar_superficie_mirando_el_puntero&#40;SDL_Surface * src, SDL_Surface * screen&#41;<br />&#123;<br />    int x = 200;        /* centro de la imagen a imprimir */<br />    int y = 200;        /* centro de la imagen a imprimir */<br />    int mouse_x, mouse_y;<br />    int distancia_x, distancia_y;<br />    float angulo;<br /><br />    SDL_GetMouseState&#40;&amp;x, &amp;y&#41;;<br /><br />    distancia_x = abs&#40;mouse_x - x&#41;;<br />    distancia_y = abs&#40;mouse_y - y&#41;;<br /><br />    angulo = &#40;atan2&#40;-distancia_y, distancia_x&#41; * 180&#41; / PI;<br /><br />    DrawSurface&#40;src, x, y, 1.0, 1.0, angulo&#41;;<br />&#125;<br /></code></dd></dl><br /><br />Si este código funciona... debería imprimir la superficie que le envíes como<br />parámetro 'rotada' en la dirección a donde apunta el mouse. Habría que probarlo,<br />imagino que funcionará. La imagen original debería señalar hacia la derecha<br />(angulo 0).<br /><br />Si añades una función como esta a tu programa recuerda indicarle al<br />compilador el parámetro '-lm' en el momento que quiera enlazar el programa para<br />generar un programa ejecutable. Así se vincula la biblioteca matemática que <br />implementa la función 'atan2' a tu programa, de otra forma falla.<br /><br />Ah, también sería bueno que consultes el artículo 'usando seno y coseno'[2] donde<br />se que explica como utilizar estas funciones trigonométricas.<br /><br />Buena suerte.<br /><br />Referencias:<br />    <br />    1 - <!-- m --><a class="postlink" href="http://www.losersjuegos.com.ar/referencia/articulos/conceptos_basicos/conceptos_basicos.php">http://www.losersjuegos.com.ar/referenc ... asicos.php</a><!-- m --><br />    2 - <!-- m --><a class="postlink" href="http://www.losersjuegos.com.ar/referencia/articulos/seno_coseno/seno_coseno.php">http://www.losersjuegos.com.ar/referenc ... coseno.php</a><!-- m --><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=3">hugoruscitti</a> — Dom Abr 22, 2007 3:37 am</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[astut]]></name></author>
<updated>2007-04-21T21:38:09+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=276#p276</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=276#p276"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=276#p276"><![CDATA[
Gracias, aunque prefiero usar una funcion aparte de la de dibujado para mayor organizacion (CfgAngulo), bueno, ahora pretendo que el angulo de la imagen apunte hacia la posicion del raton:<br /><dl class="codebox"><dt>Code: </dt><dd><code>if &#40;evento.type== SDL_MOUSEMOTION&#41;<br />    avion.CfgAngulo&#40;evento.motion.x,1&#41;;</code></dd></dl><br />Vale, pero es la coordenada x... de que forma ago que apunte hacia el raton???, gracias!! ^^<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=893">astut</a> — Sab Abr 21, 2007 9:38 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[rcaf]]></name></author>
<updated>2007-04-21T20:15:03+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=275#p275</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=275#p275"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=275#p275"><![CDATA[
Me falto comentar un detalle de la función anterior.<br /><br />Si estás dibujando y rotando una imagen, esta se rotará por defecto con respecto al punto (0,0) de la imagen, lo que provocará que la rotación no se vea bien.<br /><br />La solución es suponer que rotamos con respecto al centro de la imagen, lo que significará que la posición (x, y) no hará referencia al punto (0,0) sino al centro (cx, cy) de la imagen, por lo tanto antes de dibujar la imagen en pantalla deberás restarle a cada eje, la mitad de la diferencia de las dimensiones de la imagen resultante y la imagen inicial, me explico:<br /><br /><span style="font-weight: bold">src</span> es la superficie original<br /><span style="font-weight: bold">tmp</span> la superficie resultante (rotada o escalada)<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>pos.x -= &#40;tmp-&gt;w - src-&gt;w&#41; / 2;<br />pos.y -= &#40;tmp-&gt;h - src-&gt;h&#41; / 2;<br /></code></dd></dl><br /><br />Por lo tanto el código anterior con la nueva modificación quedaría de la siguiente forma:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>void DrawSurface&#40;SDL_Surface *src, int x, int y, float zoomx, float zoomy, float angle&#41;<br />&#123;<br />    // Superficie temporal con las modificaciones correspondientes<br />    SDL_Surface *tmp;<br /><br />    // Posición donde dibujaremos la superficie en pantalla<br />    SDL_Rect pos=&#123;x, y, 0, 0&#125;;<br /><br />    // Creamos superficie rotada y/o escalada sin anti-aliasing<br />    tmp=rotozoomSurfaceXY&#40;src, angle, zoomx, zoomy, 0&#41;;<br /><br />    // Arreglo posición de la imagen ya que la rotación<br />    // es con respecto al centro de la imagen<br />    pos.x -= &#40;tmp-&gt;w - src-&gt;w&#41; / 2;<br />    pos.y -= &#40;tmp-&gt;h - src-&gt;h&#41; / 2;<br /><br />    // Dibujamos en pantalla la nueva superficie<br />    // Nota: screen es la variable que nos devolvió <br />    // la función SDL_SetVideoMode<br />    SDL_BlitSurface&#40;tmp, NULL, screen, &amp;pos&#41;;<br /><br />    // Eliminamos de la memoria la superficie temporal<br />    SDL_FreeSurface&#40;tmp&#41;;<br />&#125;<br /></code></dd></dl><p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=8">rcaf</a> — Sab Abr 21, 2007 8:15 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[rcaf]]></name></author>
<updated>2007-04-21T19:42:30+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=274#p274</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=274#p274"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=274#p274"><![CDATA[
En realidad no debería deformarse ya que el factor de escalamiento en el eje x e y siempre es el mismo, solo estás cambiando el ángulo.<br /><br />Pero ojo que deberías crear una superficie temporal donde guardes la superficie modificada (ya rotada), luego copiar a la pantalla la superficie temporal, y por último eliminar la memoria de la superficie temporal.<br /><br />El prototipo de la función rotozoomSurfaceXY es:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>SDL_Surface * rotozoomSurfaceXY &#40;SDL_Surface *src, double angle, double zoomx, double zoomy, int smooth&#41;;<br /></code></dd></dl><br /><br />- Devuelve una superficie ya modificada (rotada y/o escalada).<br /><br />- El primero parámetro src, es la superficie original a modificar.<br /><br />- El segundo parámetro es el ángulo con que rotarás la superficie y medido en  grados (0-360)<br /><br />- El tercer y cuarto parámetro es el factor de escalamiento que aplicarás a la superficie, en el eje x e y respectivamente. Un valor de 1.0 corresponde al tamaño original.<br /><br />- Y el último parámetro corresponde a un flag que indica si se dibujará o no con anti-aliasing.<br /><br />Yo utilizo la siguiente función para dibujar superficies escaladas y/o rotadas en la pantalla:<br /><br /><dl class="codebox"><dt>Code: </dt><dd><code>void DrawSurface&#40;SDL_Surface *src, int x, int y, float zoomx, float zoomy, float angle&#41;<br />&#123;<br />    // Superficie temporal con las modificaciones correspondientes<br />    SDL_Surface *tmp;<br /><br />    // Posición donde dibujaremos la superficie en pantalla<br />    SDL_Rect pos=&#123;x, y, 0, 0&#125;;<br /><br />    // Creamos superficie rotada y/o escalada sin anti-aliasing<br />    tmp=rotozoomSurfaceXY&#40;src, angle, zoomx, zoomy, 0&#41;;<br /><br />    // Dibujamos en pantalla la nueva superficie<br />    // Nota: screen es la variable que nos devolvió <br />    // la función SDL_SetVideoMode<br />    SDL_BlitSurface&#40;tmp, NULL, screen, &amp;pos&#41;;<br /><br />    // Eliminamos de la memoria la superficie temporal<br />    SDL_FreeSurface&#40;tmp&#41;;<br />&#125;<br /></code></dd></dl><br /><br />Saludos!<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=8">rcaf</a> — Sab Abr 21, 2007 7:42 pm</p><hr />
]]></content>
</entry>
<entry>
<author><name><![CDATA[astut]]></name></author>
<updated>2007-04-21T13:13:43+00:00</updated>
<id>http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=273#p273</id>
<link href="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=273#p273"/>
<title type="html"><![CDATA[rotozoomSurfaceXY que ocurre?]]></title>

<content type="html" xml:base="http://losersjuegos.com.ar/foro/viewtopic.php?t=79&amp;p=273#p273"><![CDATA[
Bueno uso esta funcion, pero cada vez que la utilizo en mi programa la imagen se aleja cada vez mas de su centro y ademas se &quot;deforma&quot;, utilizo el siguiente metodo:<br /><dl class="codebox"><dt>Code: </dt><dd><code>void CImagen::CfgAngulo&#40;int angulo,int imagen&#41;<br />&#123;<br /> repositorio&#91;imagen&#93;= rotozoomSurfaceXY&#40;repositorio&#91;imagen&#93;,angulo,1,-1,0&#41;;<br />&#125;</code></dd></dl><br />¿Como deberia utilizarlo? esque los parametros no me quedan claros, solo los 2 primeros, gracias<p>Estadísticas: Publicado por <a href="http://losersjuegos.com.ar/foro/memberlist.php?mode=viewprofile&amp;u=893">astut</a> — Sab Abr 21, 2007 1:13 pm</p><hr />
]]></content>
</entry>
</feed>